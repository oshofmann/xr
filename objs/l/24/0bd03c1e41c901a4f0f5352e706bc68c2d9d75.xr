var __xr_tmp = [
"#<a class=\"id\" href=\"#ifndef\">ifndef</a> <a class=\"id\" href=\"#_LINUX_U64_STATS_SYNC_H\">_LINUX_U64_STATS_SYNC_H</a>", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#_LINUX_U64_STATS_SYNC_H\">_LINUX_U64_STATS_SYNC_H</a>", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * To properly implement 64bits network statistics on 32bit and 64bit hosts,</span>", 
"<span class=\"comment\"> * we provide a synchronization point, that is a noop on 64bit or UP kernels.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Key points :</span>", 
"<span class=\"comment\"> * 1) Use a seqcount on SMP 32bits, with low overhead.</span>", 
"<span class=\"comment\"> * 2) Whole thing is a noop on 64bit arches or UP kernels.</span>", 
"<span class=\"comment\"> * 3) Write side must ensure mutual exclusion or one seqcount update could</span>", 
"<span class=\"comment\"> *    be lost, thus blocking readers forever.</span>", 
"<span class=\"comment\"> *    If this synchronization point is not a mutex, but a spinlock or</span>", 
"<span class=\"comment\"> *    spinlock_bh() or disable_bh() :</span>", 
"<span class=\"comment\"> * 3.1) Write side should not sleep.</span>", 
"<span class=\"comment\"> * 3.2) Write side should not allow preemption.</span>", 
"<span class=\"comment\"> * 3.3) If applicable, interrupts should be disabled.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * 4) If reader fetches several counters, there is no guarantee the whole values</span>", 
"<span class=\"comment\"> *    are consistent (remember point 1) : this is a noop on 64bit arches anyway)</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * 5) readers are allowed to sleep or be preempted/interrupted : They perform</span>", 
"<span class=\"comment\"> *    pure reads. But if they have to fetch many values, it's better to not allow</span>", 
"<span class=\"comment\"> *    preemptions/interruptions to avoid many retries.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * 6) If counter might be written by an interrupt, readers should block interrupts.</span>", 
"<span class=\"comment\"> *    (On UP, there is no seqcount_t protection, a reader allowing interrupts could</span>", 
"<span class=\"comment\"> *     read partial values)</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * 7) For softirq uses, readers can use u64_stats_fetch_begin_bh() and</span>", 
"<span class=\"comment\"> *    u64_stats_fetch_retry_bh() helpers</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Usage :</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Stats producer (writer) should use following template granted it already got</span>", 
"<span class=\"comment\"> * an exclusive access to counters (a lock is already taken, or per cpu</span>", 
"<span class=\"comment\"> * data is used [in a non preemptable context])</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> *   spin_lock_bh(...) or other synchronization to get exclusive access</span>", 
"<span class=\"comment\"> *   ...</span>", 
"<span class=\"comment\"> *   u64_stats_update_begin(&amp;stats-&gt;syncp);</span>", 
"<span class=\"comment\"> *   stats-&gt;bytes64 += len; // non atomic operation</span>", 
"<span class=\"comment\"> *   stats-&gt;packets64++;    // non atomic operation</span>", 
"<span class=\"comment\"> *   u64_stats_update_end(&amp;stats-&gt;syncp);</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * While a consumer (reader) should use following template to get consistent</span>", 
"<span class=\"comment\"> * snapshot for each variable (but no guarantee on several ones)</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * u64 tbytes, tpackets;</span>", 
"<span class=\"comment\"> * unsigned int start;</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * do {</span>", 
"<span class=\"comment\"> *         start = u64_stats_fetch_begin(&amp;stats-&gt;syncp);</span>", 
"<span class=\"comment\"> *         tbytes = stats-&gt;bytes64; // non atomic operation</span>", 
"<span class=\"comment\"> *         tpackets = stats-&gt;packets64; // non atomic operation</span>", 
"<span class=\"comment\"> * } while (u64_stats_fetch_retry(&amp;stats-&gt;syncp, start));</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Example of use in drivers/net/loopback.c, using per_cpu containers,</span>", 
"<span class=\"comment\"> * in BH disabled context.</span>", 
"<span class=\"comment\"> */</span>", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#seqlock\">seqlock</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"", 
"struct <a class=\"id\" href=\"#u64_stats_sync\">u64_stats_sync</a> {", 
"#if <a class=\"id\" href=\"#BITS_PER_LONG\">BITS_PER_LONG</a>==32 && <a class=\"id\" href=\"#defined\">defined</a>(<a class=\"id\" href=\"#CONFIG_SMP\">CONFIG_SMP</a>)", 
"<span class=\"ts\"/><a class=\"id\" href=\"#seqcount_t\">seqcount_t</a><span class=\"ts\"/><a class=\"id\" href=\"#seq\">seq</a>;", 
"#<a class=\"id\" href=\"#endif\">endif</a>", 
"};", 
"", 
"static void <a class=\"id\" href=\"#inline\">inline</a> <a class=\"id\" href=\"#u64_stats_update_begin\">u64_stats_update_begin</a>(struct <a class=\"id\" href=\"#u64_stats_sync\">u64_stats_sync</a> *<a class=\"id\" href=\"#syncp\">syncp</a>)", 
"{", 
"#if <a class=\"id\" href=\"#BITS_PER_LONG\">BITS_PER_LONG</a>==32 && <a class=\"id\" href=\"#defined\">defined</a>(<a class=\"id\" href=\"#CONFIG_SMP\">CONFIG_SMP</a>)", 
"<span class=\"ts\"/><a class=\"id\" href=\"#write_seqcount_begin\">write_seqcount_begin</a>(&amp;<a class=\"id\" href=\"#syncp\">syncp</a>-><a class=\"id\" href=\"#seq\">seq</a>);", 
"#<a class=\"id\" href=\"#endif\">endif</a>", 
"}", 
"", 
"static void <a class=\"id\" href=\"#inline\">inline</a> <a class=\"id\" href=\"#u64_stats_update_end\">u64_stats_update_end</a>(struct <a class=\"id\" href=\"#u64_stats_sync\">u64_stats_sync</a> *<a class=\"id\" href=\"#syncp\">syncp</a>)", 
"{", 
"#if <a class=\"id\" href=\"#BITS_PER_LONG\">BITS_PER_LONG</a>==32 && <a class=\"id\" href=\"#defined\">defined</a>(<a class=\"id\" href=\"#CONFIG_SMP\">CONFIG_SMP</a>)", 
"<span class=\"ts\"/><a class=\"id\" href=\"#write_seqcount_end\">write_seqcount_end</a>(&amp;<a class=\"id\" href=\"#syncp\">syncp</a>-><a class=\"id\" href=\"#seq\">seq</a>);", 
"#<a class=\"id\" href=\"#endif\">endif</a>", 
"}", 
"", 
"static unsigned int <a class=\"id\" href=\"#inline\">inline</a> <a class=\"id\" href=\"#u64_stats_fetch_begin\">u64_stats_fetch_begin</a>(const struct <a class=\"id\" href=\"#u64_stats_sync\">u64_stats_sync</a> *<a class=\"id\" href=\"#syncp\">syncp</a>)", 
"{", 
"#if <a class=\"id\" href=\"#BITS_PER_LONG\">BITS_PER_LONG</a>==32 && <a class=\"id\" href=\"#defined\">defined</a>(<a class=\"id\" href=\"#CONFIG_SMP\">CONFIG_SMP</a>)", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#read_seqcount_begin\">read_seqcount_begin</a>(&amp;<a class=\"id\" href=\"#syncp\">syncp</a>-><a class=\"id\" href=\"#seq\">seq</a>);", 
"#else", 
"#if <a class=\"id\" href=\"#BITS_PER_LONG\">BITS_PER_LONG</a>==32", 
"<span class=\"ts\"/><a class=\"id\" href=\"#preempt_disable\">preempt_disable</a>();", 
"#<a class=\"id\" href=\"#endif\">endif</a>", 
"<span class=\"ts\"/>return 0;", 
"#<a class=\"id\" href=\"#endif\">endif</a>", 
"}", 
"", 
"static <a class=\"id\" href=\"#bool\">bool</a> <a class=\"id\" href=\"#inline\">inline</a> <a class=\"id\" href=\"#u64_stats_fetch_retry\">u64_stats_fetch_retry</a>(const struct <a class=\"id\" href=\"#u64_stats_sync\">u64_stats_sync</a> *<a class=\"id\" href=\"#syncp\">syncp</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/> unsigned int <a class=\"id\" href=\"#start\">start</a>)", 
"{", 
"#if <a class=\"id\" href=\"#BITS_PER_LONG\">BITS_PER_LONG</a>==32 && <a class=\"id\" href=\"#defined\">defined</a>(<a class=\"id\" href=\"#CONFIG_SMP\">CONFIG_SMP</a>)", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#read_seqcount_retry\">read_seqcount_retry</a>(&amp;<a class=\"id\" href=\"#syncp\">syncp</a>-><a class=\"id\" href=\"#seq\">seq</a>, <a class=\"id\" href=\"#start\">start</a>);", 
"#else", 
"#if <a class=\"id\" href=\"#BITS_PER_LONG\">BITS_PER_LONG</a>==32", 
"<span class=\"ts\"/><a class=\"id\" href=\"#preempt_enable\">preempt_enable</a>();", 
"#<a class=\"id\" href=\"#endif\">endif</a>", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#false\">false</a>;", 
"#<a class=\"id\" href=\"#endif\">endif</a>", 
"}", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * In case softirq handlers can update u64 counters, readers can use following helpers</span>", 
"<span class=\"comment\"> * - SMP 32bit arches use seqcount protection, irq safe.</span>", 
"<span class=\"comment\"> * - UP 32bit must disable BH.</span>", 
"<span class=\"comment\"> * - 64bit have no problem atomically reading u64 values, irq safe.</span>", 
"<span class=\"comment\"> */</span>", 
"static unsigned int <a class=\"id\" href=\"#inline\">inline</a> <a class=\"id\" href=\"#u64_stats_fetch_begin_bh\">u64_stats_fetch_begin_bh</a>(const struct <a class=\"id\" href=\"#u64_stats_sync\">u64_stats_sync</a> *<a class=\"id\" href=\"#syncp\">syncp</a>)", 
"{", 
"#if <a class=\"id\" href=\"#BITS_PER_LONG\">BITS_PER_LONG</a>==32 && <a class=\"id\" href=\"#defined\">defined</a>(<a class=\"id\" href=\"#CONFIG_SMP\">CONFIG_SMP</a>)", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#read_seqcount_begin\">read_seqcount_begin</a>(&amp;<a class=\"id\" href=\"#syncp\">syncp</a>-><a class=\"id\" href=\"#seq\">seq</a>);", 
"#else", 
"#if <a class=\"id\" href=\"#BITS_PER_LONG\">BITS_PER_LONG</a>==32", 
"<span class=\"ts\"/><a class=\"id\" href=\"#local_bh_disable\">local_bh_disable</a>();", 
"#<a class=\"id\" href=\"#endif\">endif</a>", 
"<span class=\"ts\"/>return 0;", 
"#<a class=\"id\" href=\"#endif\">endif</a>", 
"}", 
"", 
"static <a class=\"id\" href=\"#bool\">bool</a> <a class=\"id\" href=\"#inline\">inline</a> <a class=\"id\" href=\"#u64_stats_fetch_retry_bh\">u64_stats_fetch_retry_bh</a>(const struct <a class=\"id\" href=\"#u64_stats_sync\">u64_stats_sync</a> *<a class=\"id\" href=\"#syncp\">syncp</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/> unsigned int <a class=\"id\" href=\"#start\">start</a>)", 
"{", 
"#if <a class=\"id\" href=\"#BITS_PER_LONG\">BITS_PER_LONG</a>==32 && <a class=\"id\" href=\"#defined\">defined</a>(<a class=\"id\" href=\"#CONFIG_SMP\">CONFIG_SMP</a>)", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#read_seqcount_retry\">read_seqcount_retry</a>(&amp;<a class=\"id\" href=\"#syncp\">syncp</a>-><a class=\"id\" href=\"#seq\">seq</a>, <a class=\"id\" href=\"#start\">start</a>);", 
"#else", 
"#if <a class=\"id\" href=\"#BITS_PER_LONG\">BITS_PER_LONG</a>==32", 
"<span class=\"ts\"/><a class=\"id\" href=\"#local_bh_enable\">local_bh_enable</a>();", 
"#<a class=\"id\" href=\"#endif\">endif</a>", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#false\">false</a>;", 
"#<a class=\"id\" href=\"#endif\">endif</a>", 
"}", 
"", 
"#<a class=\"id\" href=\"#endif\">endif</a> <span class=\"comment\">/* _LINUX_U64_STATS_SYNC_H */</span>", 
];
xr_frag_insert('l/24/0bd03c1e41c901a4f0f5352e706bc68c2d9d75.xr', __xr_tmp);
