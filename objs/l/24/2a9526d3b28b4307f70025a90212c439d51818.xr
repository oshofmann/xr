var __xr_tmp = [
"#<a class=\"id\" href=\"#ifndef\">ifndef</a> <a class=\"id\" href=\"#_LINUX_TTY_DRIVER_H\">_LINUX_TTY_DRIVER_H</a>", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#_LINUX_TTY_DRIVER_H\">_LINUX_TTY_DRIVER_H</a>", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * This structure defines the interface between the low-level tty</span>", 
"<span class=\"comment\"> * driver and the tty routines.  The following routines can be</span>", 
"<span class=\"comment\"> * defined; unless noted otherwise, they are optional, and can be</span>", 
"<span class=\"comment\"> * filled in with a null pointer.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * struct tty_struct * (*lookup)(struct tty_driver *self, int idx)</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>Return the tty device corresponding to idx, NULL if there is not</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>one currently in use and an ERR_PTR value on error. Called under</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>tty_mutex (for now!)</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>Optional method. Default behaviour is to use the ttys array</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * int (*install)(struct tty_driver *self, struct tty_struct *tty)</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>Install a new tty into the tty driver internal tables. Used in</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>conjunction with lookup and remove methods.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>Optional method. Default behaviour is to use the ttys array</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * void (*remove)(struct tty_driver *self, struct tty_struct *tty)</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>Remove a closed tty from the tty driver internal tables. Used in</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>conjunction with lookup and remove methods.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>Optional method. Default behaviour is to use the ttys array</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * int  (*open)(struct tty_struct * tty, struct file * filp);</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * <span class=\"ts\"/>This routine is called when a particular tty device is opened.</span>", 
"<span class=\"comment\"> * <span class=\"ts\"/>This routine is mandatory; if this routine is not filled in,</span>", 
"<span class=\"comment\"> * <span class=\"ts\"/>the attempted open will fail with ENODEV.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>Required method.</span>", 
"<span class=\"comment\"> *     </span>", 
"<span class=\"comment\"> * void (*close)(struct tty_struct * tty, struct file * filp);</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * <span class=\"ts\"/>This routine is called when a particular tty device is closed.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>Required method.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * void (*shutdown)(struct tty_struct * tty);</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * <span class=\"ts\"/>This routine is called synchronously when a particular tty device</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>is closed for the last time freeing up the resources.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * void (*cleanup)(struct tty_struct * tty);</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>This routine is called asynchronously when a particular tty device</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>is closed for the last time freeing up the resources. This is</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>actually the second part of shutdown for routines that might sleep.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * int (*write)(struct tty_struct * tty,</span>", 
"<span class=\"comment\"> * <span class=\"ts\"/><span class=\"ts\"/> const unsigned char *buf, int count);</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * <span class=\"ts\"/>This routine is called by the kernel to write a series of</span>", 
"<span class=\"comment\"> * <span class=\"ts\"/>characters to the tty device.  The characters may come from</span>", 
"<span class=\"comment\"> * <span class=\"ts\"/>user space or kernel space.  This routine will return the</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>number of characters actually accepted for writing.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>Optional: Required for writable devices.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * int (*put_char)(struct tty_struct *tty, unsigned char ch);</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * <span class=\"ts\"/>This routine is called by the kernel to write a single</span>", 
"<span class=\"comment\"> * <span class=\"ts\"/>character to the tty device.  If the kernel uses this routine,</span>", 
"<span class=\"comment\"> * <span class=\"ts\"/>it must call the flush_chars() routine (if defined) when it is</span>", 
"<span class=\"comment\"> * <span class=\"ts\"/>done stuffing characters into the driver.  If there is no room</span>", 
"<span class=\"comment\"> * <span class=\"ts\"/>in the queue, the character is ignored.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>Optional: Kernel will use the write method if not provided.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>Note: Do not call this function directly, call tty_put_char</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * void (*flush_chars)(struct tty_struct *tty);</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * <span class=\"ts\"/>This routine is called by the kernel after it has written a</span>", 
"<span class=\"comment\"> * <span class=\"ts\"/>series of characters to the tty device using put_char().  </span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>Optional:</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>Note: Do not call this function directly, call tty_driver_flush_chars</span>", 
"<span class=\"comment\"> * </span>", 
"<span class=\"comment\"> * int  (*write_room)(struct tty_struct *tty);</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * <span class=\"ts\"/>This routine returns the numbers of characters the tty driver</span>", 
"<span class=\"comment\"> * <span class=\"ts\"/>will accept for queuing to be written.  This number is subject</span>", 
"<span class=\"comment\"> * <span class=\"ts\"/>to change as output buffers get emptied, or if the output flow</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>control is acted.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>Required if write method is provided else not needed.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>Note: Do not call this function directly, call tty_write_room</span>", 
"<span class=\"comment\"> * </span>", 
"<span class=\"comment\"> * int  (*ioctl)(struct tty_struct *tty, struct file * file,</span>", 
"<span class=\"comment\"> * <span class=\"ts\"/>    unsigned int cmd, unsigned long arg);</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * <span class=\"ts\"/>This routine allows the tty driver to implement</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>device-specific ioctl's.  If the ioctl number passed in cmd</span>", 
"<span class=\"comment\"> * <span class=\"ts\"/>is not recognized by the driver, it should return ENOIOCTLCMD.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>Optional</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * long (*compat_ioctl)(struct tty_struct *tty, struct file * file,</span>", 
"<span class=\"comment\"> * <span class=\"ts\"/>                unsigned int cmd, unsigned long arg);</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * <span class=\"ts\"/>implement ioctl processing for 32 bit process on 64 bit system</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>Optional</span>", 
"<span class=\"comment\"> * </span>", 
"<span class=\"comment\"> * void (*set_termios)(struct tty_struct *tty, struct ktermios * old);</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * <span class=\"ts\"/>This routine allows the tty driver to be notified when</span>", 
"<span class=\"comment\"> * <span class=\"ts\"/>device's termios settings have changed.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>Optional: Called under the termios lock</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * void (*set_ldisc)(struct tty_struct *tty);</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * <span class=\"ts\"/>This routine allows the tty driver to be notified when the</span>", 
"<span class=\"comment\"> * <span class=\"ts\"/>device's termios settings have changed.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>Optional: Called under BKL (currently)</span>", 
"<span class=\"comment\"> * </span>", 
"<span class=\"comment\"> * void (*throttle)(struct tty_struct * tty);</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * <span class=\"ts\"/>This routine notifies the tty driver that input buffers for</span>", 
"<span class=\"comment\"> * <span class=\"ts\"/>the line discipline are close to full, and it should somehow</span>", 
"<span class=\"comment\"> * <span class=\"ts\"/>signal that no more characters should be sent to the tty.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>Optional: Always invoke via tty_throttle(), called under the</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>termios lock.</span>", 
"<span class=\"comment\"> * </span>", 
"<span class=\"comment\"> * void (*unthrottle)(struct tty_struct * tty);</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * <span class=\"ts\"/>This routine notifies the tty drivers that it should signals</span>", 
"<span class=\"comment\"> * <span class=\"ts\"/>that characters can now be sent to the tty without fear of</span>", 
"<span class=\"comment\"> * <span class=\"ts\"/>overrunning the input buffers of the line disciplines.</span>", 
"<span class=\"comment\"> * </span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>Optional: Always invoke via tty_unthrottle(), called under the</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>termios lock.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * void (*stop)(struct tty_struct *tty);</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * <span class=\"ts\"/>This routine notifies the tty driver that it should stop</span>", 
"<span class=\"comment\"> * <span class=\"ts\"/>outputting characters to the tty device.  </span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>Optional:</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>Note: Call stop_tty not this method.</span>", 
"<span class=\"comment\"> * </span>", 
"<span class=\"comment\"> * void (*start)(struct tty_struct *tty);</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * <span class=\"ts\"/>This routine notifies the tty driver that it resume sending</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>characters to the tty device.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>Optional:</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>Note: Call start_tty not this method.</span>", 
"<span class=\"comment\"> * </span>", 
"<span class=\"comment\"> * void (*hangup)(struct tty_struct *tty);</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * <span class=\"ts\"/>This routine notifies the tty driver that it should hangup the</span>", 
"<span class=\"comment\"> * <span class=\"ts\"/>tty device.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>Optional:</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * int (*break_ctl)(struct tty_stuct *tty, int state);</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * <span class=\"ts\"/>This optional routine requests the tty driver to turn on or</span>", 
"<span class=\"comment\"> * <span class=\"ts\"/>off BREAK status on the RS-232 port.  If state is -1,</span>", 
"<span class=\"comment\"> * <span class=\"ts\"/>then the BREAK status should be turned on; if state is 0, then</span>", 
"<span class=\"comment\"> * <span class=\"ts\"/>BREAK should be turned off.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * <span class=\"ts\"/>If this routine is implemented, the high-level tty driver will</span>", 
"<span class=\"comment\"> * <span class=\"ts\"/>handle the following ioctls: TCSBRK, TCSBRKP, TIOCSBRK,</span>", 
"<span class=\"comment\"> * <span class=\"ts\"/>TIOCCBRK.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>If the driver sets TTY_DRIVER_HARDWARE_BREAK then the interface</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>will also be called with actual times and the hardware is expected</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>to do the delay work itself. 0 and -1 are still used for on/off.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>Optional: Required for TCSBRK/BRKP/etc handling.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * void (*wait_until_sent)(struct tty_struct *tty, int timeout);</span>", 
"<span class=\"comment\"> * </span>", 
"<span class=\"comment\"> * <span class=\"ts\"/>This routine waits until the device has written out all of the</span>", 
"<span class=\"comment\"> * <span class=\"ts\"/>characters in its transmitter FIFO.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>Optional: If not provided the device is assumed to have no FIFO</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>Note: Usually correct to call tty_wait_until_sent</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * void (*send_xchar)(struct tty_struct *tty, char ch);</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * <span class=\"ts\"/>This routine is used to send a high-priority XON/XOFF</span>", 
"<span class=\"comment\"> * <span class=\"ts\"/>character to the device.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>Optional: If not provided then the write method is called under</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>the atomic write lock to keep it serialized with the ldisc.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * int (*resize)(struct tty_struct *tty, struct winsize *ws)</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>Called when a termios request is issued which changes the</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>requested terminal geometry.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>Optional: the default action is to update the termios structure</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>without error. This is usually the correct behaviour. Drivers should</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>not force errors here if they are not resizable objects (eg a serial</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>line). See tty_do_resize() if you need to wrap the standard method</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>in your own logic - the usual case.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * void (*set_termiox)(struct tty_struct *tty, struct termiox *new);</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>Called when the device receives a termiox based ioctl. Passes down</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>the requested data from user space. This method will not be invoked</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>unless the tty also has a valid tty-&gt;termiox pointer.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>Optional: Called under the termios lock</span>", 
"<span class=\"comment\"> */</span>", 
"", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#fs\">fs</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#list\">list</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#cdev\">cdev</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"", 
];
xr_frag_insert('l/24/2a9526d3b28b4307f70025a90212c439d51818.xr', __xr_tmp);
