var __xr_tmp = [
"#<a class=\"id\" href=\"#ifndef\">ifndef</a> <a class=\"id\" href=\"#__RFKILL_H\">__RFKILL_H</a>", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#__RFKILL_H\">__RFKILL_H</a>", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * Copyright (C) 2006 - 2007 Ivo van Doorn</span>", 
"<span class=\"comment\"> * Copyright (C) 2007 Dmitry Torokhov</span>", 
"<span class=\"comment\"> * Copyright 2009 Johannes Berg &lt;johannes@sipsolutions.net&gt;</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Permission to use, copy, modify, and/or distribute this software for any</span>", 
"<span class=\"comment\"> * purpose with or without fee is hereby granted, provided that the above</span>", 
"<span class=\"comment\"> * copyright notice and this permission notice appear in all copies.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES</span>", 
"<span class=\"comment\"> * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>", 
"<span class=\"comment\"> * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR</span>", 
"<span class=\"comment\"> * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>", 
"<span class=\"comment\"> * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>", 
"<span class=\"comment\"> * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF</span>", 
"<span class=\"comment\"> * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>", 
"<span class=\"comment\"> */</span>", 
"", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#types\">types</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"", 
"<span class=\"comment\">/* define userspace visible states */</span>", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#RFKILL_STATE_SOFT_BLOCKED\">RFKILL_STATE_SOFT_BLOCKED</a><span class=\"ts\"/>0", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#RFKILL_STATE_UNBLOCKED\">RFKILL_STATE_UNBLOCKED</a><span class=\"ts\"/><span class=\"ts\"/>1", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#RFKILL_STATE_HARD_BLOCKED\">RFKILL_STATE_HARD_BLOCKED</a><span class=\"ts\"/>2", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * enum rfkill_type - type of rfkill switch.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * @RFKILL_TYPE_ALL: toggles all switches (requests only - not a switch type)</span>", 
"<span class=\"comment\"> * @RFKILL_TYPE_WLAN: switch is on a 802.11 wireless network device.</span>", 
"<span class=\"comment\"> * @RFKILL_TYPE_BLUETOOTH: switch is on a bluetooth device.</span>", 
"<span class=\"comment\"> * @RFKILL_TYPE_UWB: switch is on a ultra wideband device.</span>", 
"<span class=\"comment\"> * @RFKILL_TYPE_WIMAX: switch is on a WiMAX device.</span>", 
"<span class=\"comment\"> * @RFKILL_TYPE_WWAN: switch is on a wireless WAN device.</span>", 
"<span class=\"comment\"> * @RFKILL_TYPE_GPS: switch is on a GPS device.</span>", 
"<span class=\"comment\"> * @RFKILL_TYPE_FM: switch is on a FM radio device.</span>", 
"<span class=\"comment\"> * @NUM_RFKILL_TYPES: number of defined rfkill types</span>", 
"<span class=\"comment\"> */</span>", 
"enum <a class=\"id\" href=\"#rfkill_type\">rfkill_type</a> {", 
"<span class=\"ts\"/><a class=\"id\" href=\"#RFKILL_TYPE_ALL\">RFKILL_TYPE_ALL</a> = 0,", 
"<span class=\"ts\"/><a class=\"id\" href=\"#RFKILL_TYPE_WLAN\">RFKILL_TYPE_WLAN</a>,", 
"<span class=\"ts\"/><a class=\"id\" href=\"#RFKILL_TYPE_BLUETOOTH\">RFKILL_TYPE_BLUETOOTH</a>,", 
"<span class=\"ts\"/><a class=\"id\" href=\"#RFKILL_TYPE_UWB\">RFKILL_TYPE_UWB</a>,", 
"<span class=\"ts\"/><a class=\"id\" href=\"#RFKILL_TYPE_WIMAX\">RFKILL_TYPE_WIMAX</a>,", 
"<span class=\"ts\"/><a class=\"id\" href=\"#RFKILL_TYPE_WWAN\">RFKILL_TYPE_WWAN</a>,", 
"<span class=\"ts\"/><a class=\"id\" href=\"#RFKILL_TYPE_GPS\">RFKILL_TYPE_GPS</a>,", 
"<span class=\"ts\"/><a class=\"id\" href=\"#RFKILL_TYPE_FM\">RFKILL_TYPE_FM</a>,", 
"<span class=\"ts\"/><a class=\"id\" href=\"#NUM_RFKILL_TYPES\">NUM_RFKILL_TYPES</a>,", 
"};", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * enum rfkill_operation - operation types</span>", 
"<span class=\"comment\"> * @RFKILL_OP_ADD: a device was added</span>", 
"<span class=\"comment\"> * @RFKILL_OP_DEL: a device was removed</span>", 
"<span class=\"comment\"> * @RFKILL_OP_CHANGE: a device's state changed -- userspace changes one device</span>", 
"<span class=\"comment\"> * @RFKILL_OP_CHANGE_ALL: userspace changes all devices (of a type, or all)</span>", 
"<span class=\"comment\"> */</span>", 
"enum <a class=\"id\" href=\"#rfkill_operation\">rfkill_operation</a> {", 
"<span class=\"ts\"/><a class=\"id\" href=\"#RFKILL_OP_ADD\">RFKILL_OP_ADD</a> = 0,", 
"<span class=\"ts\"/><a class=\"id\" href=\"#RFKILL_OP_DEL\">RFKILL_OP_DEL</a>,", 
"<span class=\"ts\"/><a class=\"id\" href=\"#RFKILL_OP_CHANGE\">RFKILL_OP_CHANGE</a>,", 
"<span class=\"ts\"/><a class=\"id\" href=\"#RFKILL_OP_CHANGE_ALL\">RFKILL_OP_CHANGE_ALL</a>,", 
"};", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * struct rfkill_event - events for userspace on /dev/rfkill</span>", 
"<span class=\"comment\"> * @idx: index of dev rfkill</span>", 
"<span class=\"comment\"> * @type: type of the rfkill struct</span>", 
"<span class=\"comment\"> * @op: operation code</span>", 
"<span class=\"comment\"> * @hard: hard state (0/1)</span>", 
"<span class=\"comment\"> * @soft: soft state (0/1)</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Structure used for userspace communication on /dev/rfkill,</span>", 
"<span class=\"comment\"> * used for events from the kernel and control to the kernel.</span>", 
"<span class=\"comment\"> */</span>", 
"struct <a class=\"id\" href=\"#rfkill_event\">rfkill_event</a> {", 
"<span class=\"ts\"/><a class=\"id\" href=\"#__u32\">__u32</a> <a class=\"id\" href=\"#idx\">idx</a>;", 
"<span class=\"ts\"/><a class=\"id\" href=\"#__u8\">__u8</a>  <a class=\"id\" href=\"#type\">type</a>;", 
"<span class=\"ts\"/><a class=\"id\" href=\"#__u8\">__u8</a>  <a class=\"id\" href=\"#op\">op</a>;", 
"<span class=\"ts\"/><a class=\"id\" href=\"#__u8\">__u8</a>  <a class=\"id\" href=\"#soft\">soft</a>, <a class=\"id\" href=\"#hard\">hard</a>;", 
"} <a class=\"id\" href=\"#__attribute__\">__attribute__</a>((<a class=\"id\" href=\"#packed\">packed</a>));", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * We are planning to be backward and forward compatible with changes</span>", 
"<span class=\"comment\"> * to the event struct, by adding new, optional, members at the end.</span>", 
"<span class=\"comment\"> * When reading an event (whether the kernel from userspace or vice</span>", 
"<span class=\"comment\"> * versa) we need to accept anything that's at least as large as the</span>", 
"<span class=\"comment\"> * version 1 event size, but might be able to accept other sizes in</span>", 
"<span class=\"comment\"> * the future.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * One exception is the kernel -- we already have two event sizes in</span>", 
"<span class=\"comment\"> * that we've made the 'hard' member optional since our only option</span>", 
"<span class=\"comment\"> * is to ignore it anyway.</span>", 
"<span class=\"comment\"> */</span>", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#RFKILL_EVENT_SIZE_V1\">RFKILL_EVENT_SIZE_V1</a><span class=\"ts\"/>8", 
"", 
"<span class=\"comment\">/* ioctl for turning off rfkill-input (if present) */</span>", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#RFKILL_IOC_MAGIC\">RFKILL_IOC_MAGIC</a><span class=\"ts\"/>'R'", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#RFKILL_IOC_NOINPUT\">RFKILL_IOC_NOINPUT</a><span class=\"ts\"/>1", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#RFKILL_IOCTL_NOINPUT\">RFKILL_IOCTL_NOINPUT</a><span class=\"ts\"/><a class=\"id\" href=\"#_IO\">_IO</a>(<a class=\"id\" href=\"#RFKILL_IOC_MAGIC\">RFKILL_IOC_MAGIC</a>, <a class=\"id\" href=\"#RFKILL_IOC_NOINPUT\">RFKILL_IOC_NOINPUT</a>)", 
"", 
"<span class=\"comment\">/* and that's all userspace gets */</span>", 
"#<a class=\"id\" href=\"#ifdef\">ifdef</a> <a class=\"id\" href=\"#__KERNEL__\">__KERNEL__</a>", 
"<span class=\"comment\">/* don't allow anyone to use these in the kernel */</span>", 
"enum <a class=\"id\" href=\"#rfkill_user_states\">rfkill_user_states</a> {", 
"<span class=\"ts\"/><a class=\"id\" href=\"#RFKILL_USER_STATE_SOFT_BLOCKED\">RFKILL_USER_STATE_SOFT_BLOCKED</a><span class=\"ts\"/>= <a class=\"id\" href=\"#RFKILL_STATE_SOFT_BLOCKED\">RFKILL_STATE_SOFT_BLOCKED</a>,", 
"<span class=\"ts\"/><a class=\"id\" href=\"#RFKILL_USER_STATE_UNBLOCKED\">RFKILL_USER_STATE_UNBLOCKED</a><span class=\"ts\"/>= <a class=\"id\" href=\"#RFKILL_STATE_UNBLOCKED\">RFKILL_STATE_UNBLOCKED</a>,", 
"<span class=\"ts\"/><a class=\"id\" href=\"#RFKILL_USER_STATE_HARD_BLOCKED\">RFKILL_USER_STATE_HARD_BLOCKED</a><span class=\"ts\"/>= <a class=\"id\" href=\"#RFKILL_STATE_HARD_BLOCKED\">RFKILL_STATE_HARD_BLOCKED</a>,", 
"};", 
"#<a class=\"id\" href=\"#undef\">undef</a> <a class=\"id\" href=\"#RFKILL_STATE_SOFT_BLOCKED\">RFKILL_STATE_SOFT_BLOCKED</a>", 
"#<a class=\"id\" href=\"#undef\">undef</a> <a class=\"id\" href=\"#RFKILL_STATE_UNBLOCKED\">RFKILL_STATE_UNBLOCKED</a>", 
"#<a class=\"id\" href=\"#undef\">undef</a> <a class=\"id\" href=\"#RFKILL_STATE_HARD_BLOCKED\">RFKILL_STATE_HARD_BLOCKED</a>", 
"", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#kernel\">kernel</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#list\">list</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#mutex\">mutex</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#device\">device</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#leds\">leds</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#err\">err</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"", 
"<span class=\"comment\">/* this is opaque */</span>", 
"struct <a class=\"id\" href=\"#rfkill\">rfkill</a>;", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * struct rfkill_ops - rfkill driver methods</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * @poll: poll the rfkill block state(s) -- only assign this method</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>when you need polling. When called, simply call one of the</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>rfkill_set{,_hw,_sw}_state family of functions. If the hw</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>is getting unblocked you need to take into account the return</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>value of those functions to make sure the software block is</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>properly used.</span>", 
"<span class=\"comment\"> * @query: query the rfkill block state(s) and call exactly one of the</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>rfkill_set{,_hw,_sw}_state family of functions. Assign this</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>method if input events can cause hardware state changes to make</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>the rfkill core query your driver before setting a requested</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>block.</span>", 
"<span class=\"comment\"> * @set_block: turn the transmitter on (blocked == false) or off</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>(blocked == true) -- ignore and return 0 when hard blocked.</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>This callback must be assigned.</span>", 
"<span class=\"comment\"> */</span>", 
"struct <a class=\"id\" href=\"#rfkill_ops\">rfkill_ops</a> {", 
"<span class=\"ts\"/>void<span class=\"ts\"/>(*<a class=\"id\" href=\"#poll\">poll</a>)(struct <a class=\"id\" href=\"#rfkill\">rfkill</a> *<a class=\"id\" href=\"#rfkill\">rfkill</a>, void *<a class=\"id\" href=\"#data\">data</a>);", 
"<span class=\"ts\"/>void<span class=\"ts\"/>(*<a class=\"id\" href=\"#query\">query</a>)(struct <a class=\"id\" href=\"#rfkill\">rfkill</a> *<a class=\"id\" href=\"#rfkill\">rfkill</a>, void *<a class=\"id\" href=\"#data\">data</a>);", 
"<span class=\"ts\"/>int<span class=\"ts\"/>(*<a class=\"id\" href=\"#set_block\">set_block</a>)(void *<a class=\"id\" href=\"#data\">data</a>, <a class=\"id\" href=\"#bool\">bool</a> <a class=\"id\" href=\"#blocked\">blocked</a>);", 
"};", 
"", 
"#if <a class=\"id\" href=\"#defined\">defined</a>(<a class=\"id\" href=\"#CONFIG_RFKILL\">CONFIG_RFKILL</a>) || <a class=\"id\" href=\"#defined\">defined</a>(<a class=\"id\" href=\"#CONFIG_RFKILL_MODULE\">CONFIG_RFKILL_MODULE</a>)", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * rfkill_alloc - allocate rfkill structure</span>", 
"<span class=\"comment\"> * @name: name of the struct -- the string is not copied internally</span>", 
"<span class=\"comment\"> * @parent: device that has rf switch on it</span>", 
"<span class=\"comment\"> * @type: type of the switch (RFKILL_TYPE_*)</span>", 
"<span class=\"comment\"> * @ops: rfkill methods</span>", 
"<span class=\"comment\"> * @ops_data: data passed to each method</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * This function should be called by the transmitter driver to allocate an</span>", 
"<span class=\"comment\"> * rfkill structure. Returns %NULL on failure.</span>", 
"<span class=\"comment\"> */</span>", 
"struct <a class=\"id\" href=\"#rfkill\">rfkill</a> * <a class=\"id\" href=\"#__must_check\">__must_check</a> <a class=\"id\" href=\"#rfkill_alloc\">rfkill_alloc</a>(const char *<a class=\"id\" href=\"#name\">name</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>  struct <a class=\"id\" href=\"#device\">device</a> *<a class=\"id\" href=\"#parent\">parent</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>  const enum <a class=\"id\" href=\"#rfkill_type\">rfkill_type</a> <a class=\"id\" href=\"#type\">type</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>  const struct <a class=\"id\" href=\"#rfkill_ops\">rfkill_ops</a> *<a class=\"id\" href=\"#ops\">ops</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>  void *<a class=\"id\" href=\"#ops_data\">ops_data</a>);", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * rfkill_register - Register a rfkill structure.</span>", 
"<span class=\"comment\"> * @rfkill: rfkill structure to be registered</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * This function should be called by the transmitter driver to register</span>", 
"<span class=\"comment\"> * the rfkill structure. Before calling this function the driver needs</span>", 
"<span class=\"comment\"> * to be ready to service method calls from rfkill.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * If rfkill_init_sw_state() is not called before registration,</span>", 
"<span class=\"comment\"> * set_block() will be called to initialize the software blocked state</span>", 
"<span class=\"comment\"> * to a default value.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * If the hardware blocked state is not set before registration,</span>", 
"<span class=\"comment\"> * it is assumed to be unblocked.</span>", 
"<span class=\"comment\"> */</span>", 
"int <a class=\"id\" href=\"#__must_check\">__must_check</a> <a class=\"id\" href=\"#rfkill_register\">rfkill_register</a>(struct <a class=\"id\" href=\"#rfkill\">rfkill</a> *<a class=\"id\" href=\"#rfkill\">rfkill</a>);", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * rfkill_pause_polling(struct rfkill *rfkill)</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Pause polling -- say transmitter is off for other reasons.</span>", 
"<span class=\"comment\"> * NOTE: not necessary for suspend/resume -- in that case the</span>", 
"<span class=\"comment\"> * core stops polling anyway</span>", 
"<span class=\"comment\"> */</span>", 
"void <a class=\"id\" href=\"#rfkill_pause_polling\">rfkill_pause_polling</a>(struct <a class=\"id\" href=\"#rfkill\">rfkill</a> *<a class=\"id\" href=\"#rfkill\">rfkill</a>);", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * rfkill_resume_polling(struct rfkill *rfkill)</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Pause polling -- say transmitter is off for other reasons.</span>", 
"<span class=\"comment\"> * NOTE: not necessary for suspend/resume -- in that case the</span>", 
"<span class=\"comment\"> * core stops polling anyway</span>", 
"<span class=\"comment\"> */</span>", 
"void <a class=\"id\" href=\"#rfkill_resume_polling\">rfkill_resume_polling</a>(struct <a class=\"id\" href=\"#rfkill\">rfkill</a> *<a class=\"id\" href=\"#rfkill\">rfkill</a>);", 
"", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * rfkill_unregister - Unregister a rfkill structure.</span>", 
"<span class=\"comment\"> * @rfkill: rfkill structure to be unregistered</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * This function should be called by the network driver during device</span>", 
"<span class=\"comment\"> * teardown to destroy rfkill structure. Until it returns, the driver</span>", 
"<span class=\"comment\"> * needs to be able to service method calls.</span>", 
"<span class=\"comment\"> */</span>", 
"void <a class=\"id\" href=\"#rfkill_unregister\">rfkill_unregister</a>(struct <a class=\"id\" href=\"#rfkill\">rfkill</a> *<a class=\"id\" href=\"#rfkill\">rfkill</a>);", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * rfkill_destroy - free rfkill structure</span>", 
"<span class=\"comment\"> * @rfkill: rfkill structure to be destroyed</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Destroys the rfkill structure.</span>", 
"<span class=\"comment\"> */</span>", 
"void <a class=\"id\" href=\"#rfkill_destroy\">rfkill_destroy</a>(struct <a class=\"id\" href=\"#rfkill\">rfkill</a> *<a class=\"id\" href=\"#rfkill\">rfkill</a>);", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * rfkill_set_hw_state - Set the internal rfkill hardware block state</span>", 
"<span class=\"comment\"> * @rfkill: pointer to the rfkill class to modify.</span>", 
"<span class=\"comment\"> * @state: the current hardware block state to set</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * rfkill drivers that get events when the hard-blocked state changes</span>", 
"<span class=\"comment\"> * use this function to notify the rfkill core (and through that also</span>", 
"<span class=\"comment\"> * userspace) of the current state.  They should also use this after</span>", 
"<span class=\"comment\"> * resume if the state could have changed.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * You need not (but may) call this function if poll_state is assigned.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * This function can be called in any context, even from within rfkill</span>", 
"<span class=\"comment\"> * callbacks.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * The function returns the combined block state (true if transmitter</span>", 
"<span class=\"comment\"> * should be blocked) so that drivers need not keep track of the soft</span>", 
"<span class=\"comment\"> * block state -- which they might not be able to.</span>", 
"<span class=\"comment\"> */</span>", 
"<a class=\"id\" href=\"#bool\">bool</a> <a class=\"id\" href=\"#rfkill_set_hw_state\">rfkill_set_hw_state</a>(struct <a class=\"id\" href=\"#rfkill\">rfkill</a> *<a class=\"id\" href=\"#rfkill\">rfkill</a>, <a class=\"id\" href=\"#bool\">bool</a> <a class=\"id\" href=\"#blocked\">blocked</a>);", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * rfkill_set_sw_state - Set the internal rfkill software block state</span>", 
"<span class=\"comment\"> * @rfkill: pointer to the rfkill class to modify.</span>", 
"<span class=\"comment\"> * @state: the current software block state to set</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * rfkill drivers that get events when the soft-blocked state changes</span>", 
"<span class=\"comment\"> * (yes, some platforms directly act on input but allow changing again)</span>", 
"<span class=\"comment\"> * use this function to notify the rfkill core (and through that also</span>", 
"<span class=\"comment\"> * userspace) of the current state.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Drivers should also call this function after resume if the state has</span>", 
"<span class=\"comment\"> * been changed by the user.  This only makes sense for \"persistent\"</span>", 
"<span class=\"comment\"> * devices (see rfkill_init_sw_state()).</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * This function can be called in any context, even from within rfkill</span>", 
"<span class=\"comment\"> * callbacks.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * The function returns the combined block state (true if transmitter</span>", 
"<span class=\"comment\"> * should be blocked).</span>", 
"<span class=\"comment\"> */</span>", 
"<a class=\"id\" href=\"#bool\">bool</a> <a class=\"id\" href=\"#rfkill_set_sw_state\">rfkill_set_sw_state</a>(struct <a class=\"id\" href=\"#rfkill\">rfkill</a> *<a class=\"id\" href=\"#rfkill\">rfkill</a>, <a class=\"id\" href=\"#bool\">bool</a> <a class=\"id\" href=\"#blocked\">blocked</a>);", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * rfkill_init_sw_state - Initialize persistent software block state</span>", 
"<span class=\"comment\"> * @rfkill: pointer to the rfkill class to modify.</span>", 
"<span class=\"comment\"> * @state: the current software block state to set</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * rfkill drivers that preserve their software block state over power off</span>", 
"<span class=\"comment\"> * use this function to notify the rfkill core (and through that also</span>", 
"<span class=\"comment\"> * userspace) of their initial state.  It should only be used before</span>", 
"<span class=\"comment\"> * registration.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * In addition, it marks the device as \"persistent\", an attribute which</span>", 
"<span class=\"comment\"> * can be read by userspace.  Persistent devices are expected to preserve</span>", 
"<span class=\"comment\"> * their own state when suspended.</span>", 
"<span class=\"comment\"> */</span>", 
"void <a class=\"id\" href=\"#rfkill_init_sw_state\">rfkill_init_sw_state</a>(struct <a class=\"id\" href=\"#rfkill\">rfkill</a> *<a class=\"id\" href=\"#rfkill\">rfkill</a>, <a class=\"id\" href=\"#bool\">bool</a> <a class=\"id\" href=\"#blocked\">blocked</a>);", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * rfkill_set_states - Set the internal rfkill block states</span>", 
"<span class=\"comment\"> * @rfkill: pointer to the rfkill class to modify.</span>", 
"<span class=\"comment\"> * @sw: the current software block state to set</span>", 
"<span class=\"comment\"> * @hw: the current hardware block state to set</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * This function can be called in any context, even from within rfkill</span>", 
"<span class=\"comment\"> * callbacks.</span>", 
"<span class=\"comment\"> */</span>", 
"void <a class=\"id\" href=\"#rfkill_set_states\">rfkill_set_states</a>(struct <a class=\"id\" href=\"#rfkill\">rfkill</a> *<a class=\"id\" href=\"#rfkill\">rfkill</a>, <a class=\"id\" href=\"#bool\">bool</a> <a class=\"id\" href=\"#sw\">sw</a>, <a class=\"id\" href=\"#bool\">bool</a> <a class=\"id\" href=\"#hw\">hw</a>);", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * rfkill_blocked - query rfkill block</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * @rfkill: rfkill struct to query</span>", 
"<span class=\"comment\"> */</span>", 
"<a class=\"id\" href=\"#bool\">bool</a> <a class=\"id\" href=\"#rfkill_blocked\">rfkill_blocked</a>(struct <a class=\"id\" href=\"#rfkill\">rfkill</a> *<a class=\"id\" href=\"#rfkill\">rfkill</a>);", 
"#else <span class=\"comment\">/* !RFKILL */</span>", 
"static <a class=\"id\" href=\"#inline\">inline</a> struct <a class=\"id\" href=\"#rfkill\">rfkill</a> * <a class=\"id\" href=\"#__must_check\">__must_check</a>", 
"<a class=\"id\" href=\"#rfkill_alloc\">rfkill_alloc</a>(const char *<a class=\"id\" href=\"#name\">name</a>,", 
"<span class=\"ts\"/>     struct <a class=\"id\" href=\"#device\">device</a> *<a class=\"id\" href=\"#parent\">parent</a>,", 
"<span class=\"ts\"/>     const enum <a class=\"id\" href=\"#rfkill_type\">rfkill_type</a> <a class=\"id\" href=\"#type\">type</a>,", 
"<span class=\"ts\"/>     const struct <a class=\"id\" href=\"#rfkill_ops\">rfkill_ops</a> *<a class=\"id\" href=\"#ops\">ops</a>,", 
"<span class=\"ts\"/>     void *<a class=\"id\" href=\"#ops_data\">ops_data</a>)", 
"{", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#ERR_PTR\">ERR_PTR</a>(-<a class=\"id\" href=\"#ENODEV\">ENODEV</a>);", 
"}", 
"", 
"static <a class=\"id\" href=\"#inline\">inline</a> int <a class=\"id\" href=\"#__must_check\">__must_check</a> <a class=\"id\" href=\"#rfkill_register\">rfkill_register</a>(struct <a class=\"id\" href=\"#rfkill\">rfkill</a> *<a class=\"id\" href=\"#rfkill\">rfkill</a>)", 
"{", 
"<span class=\"ts\"/>if (<a class=\"id\" href=\"#rfkill\">rfkill</a> == <a class=\"id\" href=\"#ERR_PTR\">ERR_PTR</a>(-<a class=\"id\" href=\"#ENODEV\">ENODEV</a>))", 
"<span class=\"ts\"/><span class=\"ts\"/>return 0;", 
"<span class=\"ts\"/>return -<a class=\"id\" href=\"#EINVAL\">EINVAL</a>;", 
"}", 
"", 
"static <a class=\"id\" href=\"#inline\">inline</a> void <a class=\"id\" href=\"#rfkill_pause_polling\">rfkill_pause_polling</a>(struct <a class=\"id\" href=\"#rfkill\">rfkill</a> *<a class=\"id\" href=\"#rfkill\">rfkill</a>)", 
"{", 
"}", 
"", 
"static <a class=\"id\" href=\"#inline\">inline</a> void <a class=\"id\" href=\"#rfkill_resume_polling\">rfkill_resume_polling</a>(struct <a class=\"id\" href=\"#rfkill\">rfkill</a> *<a class=\"id\" href=\"#rfkill\">rfkill</a>)", 
"{", 
"}", 
"", 
"static <a class=\"id\" href=\"#inline\">inline</a> void <a class=\"id\" href=\"#rfkill_unregister\">rfkill_unregister</a>(struct <a class=\"id\" href=\"#rfkill\">rfkill</a> *<a class=\"id\" href=\"#rfkill\">rfkill</a>)", 
"{", 
"}", 
"", 
"static <a class=\"id\" href=\"#inline\">inline</a> void <a class=\"id\" href=\"#rfkill_destroy\">rfkill_destroy</a>(struct <a class=\"id\" href=\"#rfkill\">rfkill</a> *<a class=\"id\" href=\"#rfkill\">rfkill</a>)", 
"{", 
"}", 
"", 
"static <a class=\"id\" href=\"#inline\">inline</a> <a class=\"id\" href=\"#bool\">bool</a> <a class=\"id\" href=\"#rfkill_set_hw_state\">rfkill_set_hw_state</a>(struct <a class=\"id\" href=\"#rfkill\">rfkill</a> *<a class=\"id\" href=\"#rfkill\">rfkill</a>, <a class=\"id\" href=\"#bool\">bool</a> <a class=\"id\" href=\"#blocked\">blocked</a>)", 
"{", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#blocked\">blocked</a>;", 
"}", 
"", 
"static <a class=\"id\" href=\"#inline\">inline</a> <a class=\"id\" href=\"#bool\">bool</a> <a class=\"id\" href=\"#rfkill_set_sw_state\">rfkill_set_sw_state</a>(struct <a class=\"id\" href=\"#rfkill\">rfkill</a> *<a class=\"id\" href=\"#rfkill\">rfkill</a>, <a class=\"id\" href=\"#bool\">bool</a> <a class=\"id\" href=\"#blocked\">blocked</a>)", 
"{", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#blocked\">blocked</a>;", 
"}", 
"", 
"static <a class=\"id\" href=\"#inline\">inline</a> void <a class=\"id\" href=\"#rfkill_init_sw_state\">rfkill_init_sw_state</a>(struct <a class=\"id\" href=\"#rfkill\">rfkill</a> *<a class=\"id\" href=\"#rfkill\">rfkill</a>, <a class=\"id\" href=\"#bool\">bool</a> <a class=\"id\" href=\"#blocked\">blocked</a>)", 
"{", 
"}", 
"", 
"static <a class=\"id\" href=\"#inline\">inline</a> void <a class=\"id\" href=\"#rfkill_set_states\">rfkill_set_states</a>(struct <a class=\"id\" href=\"#rfkill\">rfkill</a> *<a class=\"id\" href=\"#rfkill\">rfkill</a>, <a class=\"id\" href=\"#bool\">bool</a> <a class=\"id\" href=\"#sw\">sw</a>, <a class=\"id\" href=\"#bool\">bool</a> <a class=\"id\" href=\"#hw\">hw</a>)", 
"{", 
"}", 
"", 
"static <a class=\"id\" href=\"#inline\">inline</a> <a class=\"id\" href=\"#bool\">bool</a> <a class=\"id\" href=\"#rfkill_blocked\">rfkill_blocked</a>(struct <a class=\"id\" href=\"#rfkill\">rfkill</a> *<a class=\"id\" href=\"#rfkill\">rfkill</a>)", 
"{", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#false\">false</a>;", 
"}", 
"#<a class=\"id\" href=\"#endif\">endif</a> <span class=\"comment\">/* RFKILL || RFKILL_MODULE */</span>", 
"", 
"", 
"#<a class=\"id\" href=\"#ifdef\">ifdef</a> <a class=\"id\" href=\"#CONFIG_RFKILL_LEDS\">CONFIG_RFKILL_LEDS</a>", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * rfkill_get_led_trigger_name - Get the LED trigger name for the button's LED.</span>", 
"<span class=\"comment\"> * This function might return a NULL pointer if registering of the</span>", 
"<span class=\"comment\"> * LED trigger failed. Use this as \"default_trigger\" for the LED.</span>", 
"<span class=\"comment\"> */</span>", 
"const char *<a class=\"id\" href=\"#rfkill_get_led_trigger_name\">rfkill_get_led_trigger_name</a>(struct <a class=\"id\" href=\"#rfkill\">rfkill</a> *<a class=\"id\" href=\"#rfkill\">rfkill</a>);", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * rfkill_set_led_trigger_name -- set the LED trigger name</span>", 
"<span class=\"comment\"> * @rfkill: rfkill struct</span>", 
"<span class=\"comment\"> * @name: LED trigger name</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * This function sets the LED trigger name of the radio LED</span>", 
"<span class=\"comment\"> * trigger that rfkill creates. It is optional, but if called</span>", 
"<span class=\"comment\"> * must be called before rfkill_register() to be effective.</span>", 
"<span class=\"comment\"> */</span>", 
"void <a class=\"id\" href=\"#rfkill_set_led_trigger_name\">rfkill_set_led_trigger_name</a>(struct <a class=\"id\" href=\"#rfkill\">rfkill</a> *<a class=\"id\" href=\"#rfkill\">rfkill</a>, const char *<a class=\"id\" href=\"#name\">name</a>);", 
"#else", 
"static <a class=\"id\" href=\"#inline\">inline</a> const char *<a class=\"id\" href=\"#rfkill_get_led_trigger_name\">rfkill_get_led_trigger_name</a>(struct <a class=\"id\" href=\"#rfkill\">rfkill</a> *<a class=\"id\" href=\"#rfkill\">rfkill</a>)", 
"{", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#NULL\">NULL</a>;", 
"}", 
"", 
"static <a class=\"id\" href=\"#inline\">inline</a> void", 
"<a class=\"id\" href=\"#rfkill_set_led_trigger_name\">rfkill_set_led_trigger_name</a>(struct <a class=\"id\" href=\"#rfkill\">rfkill</a> *<a class=\"id\" href=\"#rfkill\">rfkill</a>, const char *<a class=\"id\" href=\"#name\">name</a>)", 
"{", 
"}", 
"#<a class=\"id\" href=\"#endif\">endif</a>", 
"", 
"#<a class=\"id\" href=\"#endif\">endif</a> <span class=\"comment\">/* __KERNEL__ */</span>", 
"", 
"#<a class=\"id\" href=\"#endif\">endif</a> <span class=\"comment\">/* RFKILL_H */</span>", 
];
xr_frag_insert('l/2e/87d6eefe8790739d29c78db11d5519db230ac5.xr', __xr_tmp);
