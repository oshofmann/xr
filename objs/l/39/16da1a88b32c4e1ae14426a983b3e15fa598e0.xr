var __xr_tmp = [
"<span class=\"comment\"> * need to be brought up before allocation services are running).</span>", 
"<span class=\"comment\"> * Unit grows as necessary and all units grow or shrink in unison.</span>", 
"<span class=\"comment\"> * When a chunk is filled up, another chunk is allocated.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> *  c0                           c1                         c2</span>", 
"<span class=\"comment\"> *  -------------------          -------------------        ------------</span>", 
"<span class=\"comment\"> * | u0 | u1 | u2 | u3 |        | u0 | u1 | u2 | u3 |      | u0 | u1 | u</span>", 
"<span class=\"comment\"> *  -------------------  ......  -------------------  ....  ------------</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Allocation is done in offset-size areas of single unit space.  Ie,</span>", 
"<span class=\"comment\"> * an area of 512 bytes at 6k in c1 occupies 512 bytes at 6k of c1:u0,</span>", 
"<span class=\"comment\"> * c1:u1, c1:u2 and c1:u3.  On UMA, units corresponds directly to</span>", 
"<span class=\"comment\"> * cpus.  On NUMA, the mapping can be non-linear and even sparse.</span>", 
"<span class=\"comment\"> * Percpu access can be done by configuring percpu base registers</span>", 
"<span class=\"comment\"> * according to cpu to unit mapping and pcpu_unit_size.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * There are usually many small percpu allocations many of them being</span>", 
"<span class=\"comment\"> * as small as 4 bytes.  The allocator organizes chunks into lists</span>", 
"<span class=\"comment\"> * according to free size and tries to allocate from the fullest one.</span>", 
"<span class=\"comment\"> * Each chunk keeps the maximum contiguous area size hint which is</span>", 
"<span class=\"comment\"> * guaranteed to be eqaul to or larger than the maximum contiguous</span>", 
"<span class=\"comment\"> * area in the chunk.  This helps the allocator not to iterate the</span>", 
"<span class=\"comment\"> * chunk maps unnecessarily.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Allocation state in each chunk is kept using an array of integers</span>", 
"<span class=\"comment\"> * on chunk-&gt;map.  A positive value in the map represents a free</span>", 
"<span class=\"comment\"> * region and negative allocated.  Allocation inside a chunk is done</span>", 
"<span class=\"comment\"> * by scanning this map sequentially and serving the first matching</span>", 
"<span class=\"comment\"> * entry.  This is mostly copied from the percpu_modalloc() allocator.</span>", 
"<span class=\"comment\"> * Chunks can be determined from the address using the index field</span>", 
"<span class=\"comment\"> * in the page struct. The index field contains a pointer to the chunk.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * To use this allocator, arch code should do the followings.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * - define __addr_to_pcpu_ptr() and __pcpu_ptr_to_addr() to translate</span>", 
"<span class=\"comment\"> *   regular address to percpu pointer and back if they need to be</span>", 
"<span class=\"comment\"> *   different from the default</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * - use pcpu_setup_first_chunk() during percpu area initialization to</span>", 
"<span class=\"comment\"> *   setup the first chunk containing the kernel static percpu area</span>", 
"<span class=\"comment\"> */</span>", 
"", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#bitmap\">bitmap</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#bootmem\">bootmem</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#err\">err</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#list\">list</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
];
xr_frag_insert('l/39/16da1a88b32c4e1ae14426a983b3e15fa598e0.xr', __xr_tmp);
