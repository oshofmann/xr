var __xr_tmp = [
"<span class=\"comment\"><span class=\"ts\"/><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#swapcache_free\">swapcache_free</a>(<a class=\"id\" href=\"#entry\">entry</a>, <a class=\"id\" href=\"#NULL\">NULL</a>);", 
"<span class=\"ts\"/>} while (<a class=\"id\" href=\"#err\">err</a> != -<a class=\"id\" href=\"#ENOMEM\">ENOMEM</a>);", 
"", 
"<span class=\"ts\"/>if (<a class=\"id\" href=\"#new_page\">new_page</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#page_cache_release\">page_cache_release</a>(<a class=\"id\" href=\"#new_page\">new_page</a>);", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#found_page\">found_page</a>;", 
"}", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * swapin_readahead - swap in pages in hope we need them soon</span>", 
"<span class=\"comment\"> * @entry: swap entry of this memory</span>", 
"<span class=\"comment\"> * @gfp_mask: memory allocation flags</span>", 
"<span class=\"comment\"> * @vma: user vma this address belongs to</span>", 
"<span class=\"comment\"> * @addr: target address for mempolicy</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Returns the struct page for entry and addr, after queueing swapin.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Primitive swap readahead code. We simply read an aligned block of</span>", 
"<span class=\"comment\"> * (1 &lt;&lt; page_cluster) entries in the swap area. This method is chosen</span>", 
"<span class=\"comment\"> * because it doesn't cost us any seek time.  We also make sure to queue</span>", 
"<span class=\"comment\"> * the 'original' request together with the readahead ones...</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * This has been extended to use the NUMA policies from the mm triggering</span>", 
"<span class=\"comment\"> * the readahead.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Caller must hold down_read on the vma-&gt;vm_mm if vma is not NULL.</span>", 
"<span class=\"comment\"> */</span>", 
"struct <a class=\"id\" href=\"#page\">page</a> *<a class=\"id\" href=\"#swapin_readahead\">swapin_readahead</a>(<a class=\"id\" href=\"#swp_entry_t\">swp_entry_t</a> <a class=\"id\" href=\"#entry\">entry</a>, <a class=\"id\" href=\"#gfp_t\">gfp_t</a> <a class=\"id\" href=\"#gfp_mask\">gfp_mask</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>struct <a class=\"id\" href=\"#vm_area_struct\">vm_area_struct</a> *<a class=\"id\" href=\"#vma\">vma</a>, unsigned long <a class=\"id\" href=\"#addr\">addr</a>)", 
"{", 
"<span class=\"ts\"/>int <a class=\"id\" href=\"#nr_pages\">nr_pages</a>;", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#page\">page</a> *<a class=\"id\" href=\"#page\">page</a>;", 
"<span class=\"ts\"/>unsigned long <a class=\"id\" href=\"#offset\">offset</a>;", 
"<span class=\"ts\"/>unsigned long <a class=\"id\" href=\"#end_offset\">end_offset</a>;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Get starting offset for readaround, and number of pages to read.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Adjust starting address by readbehind (for NUMA interleave case)?</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * No, it's very unlikely that swap layout would follow vma layout,</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * more likely that neighbouring swap pages came from the same node:</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * so use the same \"addr\" to choose the same node for each swap read.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/><a class=\"id\" href=\"#nr_pages\">nr_pages</a> = <a class=\"id\" href=\"#valid_swaphandles\">valid_swaphandles</a>(<a class=\"id\" href=\"#entry\">entry</a>, &amp;<a class=\"id\" href=\"#offset\">offset</a>);", 
"<span class=\"ts\"/>for (<a class=\"id\" href=\"#end_offset\">end_offset</a> = <a class=\"id\" href=\"#offset\">offset</a> + <a class=\"id\" href=\"#nr_pages\">nr_pages</a>; <a class=\"id\" href=\"#offset\">offset</a> &lt; <a class=\"id\" href=\"#end_offset\">end_offset</a>; <a class=\"id\" href=\"#offset\">offset</a>++) {", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"comment\">/* Ok, do the async read-ahead now */</span>", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#page\">page</a> = <a class=\"id\" href=\"#read_swap_cache_async\">read_swap_cache_async</a>(<a class=\"id\" href=\"#swp_entry\">swp_entry</a>(<a class=\"id\" href=\"#swp_type\">swp_type</a>(<a class=\"id\" href=\"#entry\">entry</a>), <a class=\"id\" href=\"#offset\">offset</a>),", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#gfp_mask\">gfp_mask</a>, <a class=\"id\" href=\"#vma\">vma</a>, <a class=\"id\" href=\"#addr\">addr</a>);", 
"<span class=\"ts\"/><span class=\"ts\"/>if (!<a class=\"id\" href=\"#page\">page</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>break;", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#page_cache_release\">page_cache_release</a>(<a class=\"id\" href=\"#page\">page</a>);", 
"<span class=\"ts\"/>}", 
"<span class=\"ts\"/><a class=\"id\" href=\"#lru_add_drain\">lru_add_drain</a>();<span class=\"ts\"/><span class=\"comment\">/* Push any new pages onto the LRU now */</span>", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#read_swap_cache_async\">read_swap_cache_async</a>(<a class=\"id\" href=\"#entry\">entry</a>, <a class=\"id\" href=\"#gfp_mask\">gfp_mask</a>, <a class=\"id\" href=\"#vma\">vma</a>, <a class=\"id\" href=\"#addr\">addr</a>);", 
"}", 
];
xr_frag_insert('l/3b/63fd38c21e8b72405fc10ed0b759fa95e63a5a.xr', __xr_tmp);
