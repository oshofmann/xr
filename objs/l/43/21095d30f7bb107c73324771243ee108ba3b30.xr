var __xr_tmp = [
"#<a class=\"id\" href=\"#ifndef\">ifndef</a> <a class=\"id\" href=\"#_LINUX_MEMPOLICY_H\">_LINUX_MEMPOLICY_H</a>", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#_LINUX_MEMPOLICY_H\">_LINUX_MEMPOLICY_H</a> 1", 
"", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#errno\">errno</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * NUMA memory policies for Linux.</span>", 
"<span class=\"comment\"> * Copyright 2003,2004 Andi Kleen SuSE Labs</span>", 
"<span class=\"comment\"> */</span>", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * Both the MPOL_* mempolicy mode and the MPOL_F_* optional mode flags are</span>", 
"<span class=\"comment\"> * passed by the user to either set_mempolicy() or mbind() in an 'int' actual.</span>", 
"<span class=\"comment\"> * The MPOL_MODE_FLAGS macro determines the legal set of optional mode flags.</span>", 
"<span class=\"comment\"> */</span>", 
"", 
"<span class=\"comment\">/* Policies */</span>", 
"enum {", 
"<span class=\"ts\"/><a class=\"id\" href=\"#MPOL_DEFAULT\">MPOL_DEFAULT</a>,", 
"<span class=\"ts\"/><a class=\"id\" href=\"#MPOL_PREFERRED\">MPOL_PREFERRED</a>,", 
"<span class=\"ts\"/><a class=\"id\" href=\"#MPOL_BIND\">MPOL_BIND</a>,", 
"<span class=\"ts\"/><a class=\"id\" href=\"#MPOL_INTERLEAVE\">MPOL_INTERLEAVE</a>,", 
"<span class=\"ts\"/><a class=\"id\" href=\"#MPOL_MAX\">MPOL_MAX</a>,<span class=\"ts\"/><span class=\"comment\">/* always last member of enum */</span>", 
"};", 
"", 
"enum <a class=\"id\" href=\"#mpol_rebind_step\">mpol_rebind_step</a> {", 
"<span class=\"ts\"/><a class=\"id\" href=\"#MPOL_REBIND_ONCE\">MPOL_REBIND_ONCE</a>,<span class=\"ts\"/><span class=\"comment\">/* do rebind work at once(not by two step) */</span>", 
"<span class=\"ts\"/><a class=\"id\" href=\"#MPOL_REBIND_STEP1\">MPOL_REBIND_STEP1</a>,<span class=\"ts\"/><span class=\"comment\">/* first step(set all the newly nodes) */</span>", 
"<span class=\"ts\"/><a class=\"id\" href=\"#MPOL_REBIND_STEP2\">MPOL_REBIND_STEP2</a>,<span class=\"ts\"/><span class=\"comment\">/* second step(clean all the disallowed nodes)*/</span>", 
"<span class=\"ts\"/><a class=\"id\" href=\"#MPOL_REBIND_NSTEP\">MPOL_REBIND_NSTEP</a>,", 
"};", 
"", 
"<span class=\"comment\">/* Flags for set_mempolicy */</span>", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#MPOL_F_STATIC_NODES\">MPOL_F_STATIC_NODES</a><span class=\"ts\"/>(1 << 15)", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#MPOL_F_RELATIVE_NODES\">MPOL_F_RELATIVE_NODES</a><span class=\"ts\"/>(1 << 14)", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * MPOL_MODE_FLAGS is the union of all possible optional mode flags passed to</span>", 
"<span class=\"comment\"> * either set_mempolicy() or mbind().</span>", 
"<span class=\"comment\"> */</span>", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#MPOL_MODE_FLAGS\">MPOL_MODE_FLAGS</a><span class=\"ts\"/>(<a class=\"id\" href=\"#MPOL_F_STATIC_NODES\">MPOL_F_STATIC_NODES</a> | <a class=\"id\" href=\"#MPOL_F_RELATIVE_NODES\">MPOL_F_RELATIVE_NODES</a>)", 
"", 
"<span class=\"comment\">/* Flags for get_mempolicy */</span>", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#MPOL_F_NODE\">MPOL_F_NODE</a><span class=\"ts\"/>(1<<0)<span class=\"ts\"/><span class=\"comment\">/* return next IL mode instead of node mask */</span>", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#MPOL_F_ADDR\">MPOL_F_ADDR</a><span class=\"ts\"/>(1<<1)<span class=\"ts\"/><span class=\"comment\">/* look up vma using address */</span>", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#MPOL_F_MEMS_ALLOWED\">MPOL_F_MEMS_ALLOWED</a> (1<<2) <span class=\"comment\">/* return allowed memories */</span>", 
"", 
"<span class=\"comment\">/* Flags for mbind */</span>", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#MPOL_MF_STRICT\">MPOL_MF_STRICT</a><span class=\"ts\"/>(1<<0)<span class=\"ts\"/><span class=\"comment\">/* Verify existing pages in the mapping */</span>", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#MPOL_MF_MOVE\">MPOL_MF_MOVE</a><span class=\"ts\"/>(1<<1)<span class=\"ts\"/><span class=\"comment\">/* Move pages owned by this process to conform to mapping */</span>", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#MPOL_MF_MOVE_ALL\">MPOL_MF_MOVE_ALL</a> (1<<2)<span class=\"ts\"/><span class=\"comment\">/* Move every page to conform to mapping */</span>", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#MPOL_MF_INTERNAL\">MPOL_MF_INTERNAL</a> (1<<3)<span class=\"ts\"/><span class=\"comment\">/* Internal flags start here */</span>", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * Internal flags that share the struct mempolicy flags word with</span>", 
"<span class=\"comment\"> * \"mode flags\".  These flags are allocated from bit 0 up, as they</span>", 
"<span class=\"comment\"> * are never OR'ed into the mode in mempolicy API arguments.</span>", 
"<span class=\"comment\"> */</span>", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#MPOL_F_SHARED\">MPOL_F_SHARED</a>  (1 << 0)<span class=\"ts\"/><span class=\"comment\">/* identify shared policies */</span>", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#MPOL_F_LOCAL\">MPOL_F_LOCAL</a>   (1 << 1)<span class=\"ts\"/><span class=\"comment\">/* preferred local allocation */</span>", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#MPOL_F_REBINDING\">MPOL_F_REBINDING</a> (1 << 2)<span class=\"ts\"/><span class=\"comment\">/* identify policies in rebinding */</span>", 
"", 
"#<a class=\"id\" href=\"#ifdef\">ifdef</a> <a class=\"id\" href=\"#__KERNEL__\">__KERNEL__</a>", 
"", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#mmzone\">mmzone</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#slab\">slab</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#rbtree\">rbtree</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#spinlock\">spinlock</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#nodemask\">nodemask</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#pagemap\">pagemap</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"", 
"struct <a class=\"id\" href=\"#mm_struct\">mm_struct</a>;", 
"", 
"#<a class=\"id\" href=\"#ifdef\">ifdef</a> <a class=\"id\" href=\"#CONFIG_NUMA\">CONFIG_NUMA</a>", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * Describe a memory policy.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * A mempolicy can be either associated with a process or with a VMA.</span>", 
"<span class=\"comment\"> * For VMA related allocations the VMA policy is preferred, otherwise</span>", 
"<span class=\"comment\"> * the process policy is used. Interrupts ignore the memory policy</span>", 
"<span class=\"comment\"> * of the current process.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Locking policy for interlave:</span>", 
"<span class=\"comment\"> * In process context there is no locking because only the process accesses</span>", 
"<span class=\"comment\"> * its own state. All vma manipulation is somewhat protected by a down_read on</span>", 
"<span class=\"comment\"> * mmap_sem.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Freeing policy:</span>", 
"<span class=\"comment\"> * Mempolicy objects are reference counted.  A mempolicy will be freed when</span>", 
"<span class=\"comment\"> * mpol_put() decrements the reference count to zero.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Duplicating policy objects:</span>", 
"<span class=\"comment\"> * mpol_dup() allocates a new mempolicy and copies the specified mempolicy</span>", 
"<span class=\"comment\"> * to the new storage.  The reference count of the new object is initialized</span>", 
"<span class=\"comment\"> * to 1, representing the caller of mpol_dup().</span>", 
"<span class=\"comment\"> */</span>", 
"struct <a class=\"id\" href=\"#mempolicy\">mempolicy</a> {", 
"<span class=\"ts\"/><a class=\"id\" href=\"#atomic_t\">atomic_t</a> <a class=\"id\" href=\"#refcnt\">refcnt</a>;", 
"<span class=\"ts\"/>unsigned short <a class=\"id\" href=\"#mode\">mode</a>; <span class=\"ts\"/><span class=\"comment\">/* See MPOL_* above */</span>", 
"<span class=\"ts\"/>unsigned short <a class=\"id\" href=\"#flags\">flags</a>;<span class=\"ts\"/><span class=\"comment\">/* See set_mempolicy() MPOL_F_* above */</span>", 
"<span class=\"ts\"/>union {", 
"<span class=\"ts\"/><span class=\"ts\"/>short <span class=\"ts\"/><span class=\"ts\"/> <a class=\"id\" href=\"#preferred_node\">preferred_node</a>; <span class=\"comment\">/* preferred */</span>", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#nodemask_t\">nodemask_t</a><span class=\"ts\"/> <a class=\"id\" href=\"#nodes\">nodes</a>;<span class=\"ts\"/><span class=\"ts\"/><span class=\"comment\">/* interleave/bind */</span>", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"comment\">/* undefined for default */</span>", 
"<span class=\"ts\"/>} <a class=\"id\" href=\"#v\">v</a>;", 
"<span class=\"ts\"/>union {", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#nodemask_t\">nodemask_t</a> <a class=\"id\" href=\"#cpuset_mems_allowed\">cpuset_mems_allowed</a>;<span class=\"ts\"/><span class=\"comment\">/* relative to these nodes */</span>", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#nodemask_t\">nodemask_t</a> <a class=\"id\" href=\"#user_nodemask\">user_nodemask</a>;<span class=\"ts\"/><span class=\"comment\">/* nodemask passed by user */</span>", 
"<span class=\"ts\"/>} <a class=\"id\" href=\"#w\">w</a>;", 
"};", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * Support for managing mempolicy data objects (clone, copy, destroy)</span>", 
"<span class=\"comment\"> * The default fast path of a NULL MPOL_DEFAULT policy is always inlined.</span>", 
"<span class=\"comment\"> */</span>", 
"", 
"extern void <a class=\"id\" href=\"#__mpol_put\">__mpol_put</a>(struct <a class=\"id\" href=\"#mempolicy\">mempolicy</a> *<a class=\"id\" href=\"#pol\">pol</a>);", 
"static <a class=\"id\" href=\"#inline\">inline</a> void <a class=\"id\" href=\"#mpol_put\">mpol_put</a>(struct <a class=\"id\" href=\"#mempolicy\">mempolicy</a> *<a class=\"id\" href=\"#pol\">pol</a>)", 
"{", 
"<span class=\"ts\"/>if (<a class=\"id\" href=\"#pol\">pol</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#__mpol_put\">__mpol_put</a>(<a class=\"id\" href=\"#pol\">pol</a>);", 
"}", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * Does mempolicy pol need explicit unref after use?</span>", 
"<span class=\"comment\"> * Currently only needed for shared policies.</span>", 
"<span class=\"comment\"> */</span>", 
"static <a class=\"id\" href=\"#inline\">inline</a> int <a class=\"id\" href=\"#mpol_needs_cond_ref\">mpol_needs_cond_ref</a>(struct <a class=\"id\" href=\"#mempolicy\">mempolicy</a> *<a class=\"id\" href=\"#pol\">pol</a>)", 
"{", 
"<span class=\"ts\"/>return (<a class=\"id\" href=\"#pol\">pol</a> && (<a class=\"id\" href=\"#pol\">pol</a>-><a class=\"id\" href=\"#flags\">flags</a> &amp; <a class=\"id\" href=\"#MPOL_F_SHARED\">MPOL_F_SHARED</a>));", 
"}", 
"", 
"static <a class=\"id\" href=\"#inline\">inline</a> void <a class=\"id\" href=\"#mpol_cond_put\">mpol_cond_put</a>(struct <a class=\"id\" href=\"#mempolicy\">mempolicy</a> *<a class=\"id\" href=\"#pol\">pol</a>)", 
"{", 
"<span class=\"ts\"/>if (<a class=\"id\" href=\"#mpol_needs_cond_ref\">mpol_needs_cond_ref</a>(<a class=\"id\" href=\"#pol\">pol</a>))", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#__mpol_put\">__mpol_put</a>(<a class=\"id\" href=\"#pol\">pol</a>);", 
"}", 
"", 
"extern struct <a class=\"id\" href=\"#mempolicy\">mempolicy</a> *<a class=\"id\" href=\"#__mpol_cond_copy\">__mpol_cond_copy</a>(struct <a class=\"id\" href=\"#mempolicy\">mempolicy</a> *<a class=\"id\" href=\"#tompol\">tompol</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>  struct <a class=\"id\" href=\"#mempolicy\">mempolicy</a> *<a class=\"id\" href=\"#frompol\">frompol</a>);", 
"static <a class=\"id\" href=\"#inline\">inline</a> struct <a class=\"id\" href=\"#mempolicy\">mempolicy</a> *<a class=\"id\" href=\"#mpol_cond_copy\">mpol_cond_copy</a>(struct <a class=\"id\" href=\"#mempolicy\">mempolicy</a> *<a class=\"id\" href=\"#tompol\">tompol</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>struct <a class=\"id\" href=\"#mempolicy\">mempolicy</a> *<a class=\"id\" href=\"#frompol\">frompol</a>)", 
"{", 
"<span class=\"ts\"/>if (!<a class=\"id\" href=\"#frompol\">frompol</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/>return <a class=\"id\" href=\"#frompol\">frompol</a>;", 
];
xr_frag_insert('l/43/21095d30f7bb107c73324771243ee108ba3b30.xr', __xr_tmp);
