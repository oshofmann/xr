var __xr_tmp = [
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#page\">page</a> = <a class=\"id\" href=\"#pfn_to_page\">pfn_to_page</a>(<a class=\"id\" href=\"#pfn\">pfn</a>);", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#set_page_links\">set_page_links</a>(<a class=\"id\" href=\"#page\">page</a>, <a class=\"id\" href=\"#zone\">zone</a>, <a class=\"id\" href=\"#nid\">nid</a>, <a class=\"id\" href=\"#pfn\">pfn</a>);", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#mminit_verify_page_links\">mminit_verify_page_links</a>(<a class=\"id\" href=\"#page\">page</a>, <a class=\"id\" href=\"#zone\">zone</a>, <a class=\"id\" href=\"#nid\">nid</a>, <a class=\"id\" href=\"#pfn\">pfn</a>);", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#init_page_count\">init_page_count</a>(<a class=\"id\" href=\"#page\">page</a>);", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#reset_page_mapcount\">reset_page_mapcount</a>(<a class=\"id\" href=\"#page\">page</a>);", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#SetPageReserved\">SetPageReserved</a>(<a class=\"id\" href=\"#page\">page</a>);", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/><span class=\"ts\"/> * Mark the block movable so that blocks are reserved for</span>", 
"<span class=\"comment\"><span class=\"ts\"/><span class=\"ts\"/> * movable at startup. This will force kernel allocations</span>", 
"<span class=\"comment\"><span class=\"ts\"/><span class=\"ts\"/> * to reserve their blocks rather than leaking throughout</span>", 
"<span class=\"comment\"><span class=\"ts\"/><span class=\"ts\"/> * the address space during boot when many long-lived</span>", 
"<span class=\"comment\"><span class=\"ts\"/><span class=\"ts\"/> * kernel allocations are made. Later some blocks near</span>", 
"<span class=\"comment\"><span class=\"ts\"/><span class=\"ts\"/> * the start are marked MIGRATE_RESERVE by</span>", 
"<span class=\"comment\"><span class=\"ts\"/><span class=\"ts\"/> * setup_zone_migrate_reserve()</span>", 
"<span class=\"comment\"><span class=\"ts\"/><span class=\"ts\"/> *</span>", 
"<span class=\"comment\"><span class=\"ts\"/><span class=\"ts\"/> * bitmap is created for zone's valid pfn range. but memmap</span>", 
"<span class=\"comment\"><span class=\"ts\"/><span class=\"ts\"/> * can be created for invalid pages (for alignment)</span>", 
"<span class=\"comment\"><span class=\"ts\"/><span class=\"ts\"/> * check here not to call set_pageblock_migratetype() against</span>", 
"<span class=\"comment\"><span class=\"ts\"/><span class=\"ts\"/> * pfn out of zone.</span>", 
"<span class=\"comment\"><span class=\"ts\"/><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/><span class=\"ts\"/>if ((<a class=\"id\" href=\"#z\">z</a>-><a class=\"id\" href=\"#zone_start_pfn\">zone_start_pfn</a> <= <a class=\"id\" href=\"#pfn\">pfn</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/>    && (<a class=\"id\" href=\"#pfn\">pfn</a> &lt; <a class=\"id\" href=\"#z\">z</a>-><a class=\"id\" href=\"#zone_start_pfn\">zone_start_pfn</a> + <a class=\"id\" href=\"#z\">z</a>-><a class=\"id\" href=\"#spanned_pages\">spanned_pages</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/>    && !(<a class=\"id\" href=\"#pfn\">pfn</a> &amp; (<a class=\"id\" href=\"#pageblock_nr_pages\">pageblock_nr_pages</a> - 1)))", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#set_pageblock_migratetype\">set_pageblock_migratetype</a>(<a class=\"id\" href=\"#page\">page</a>, <a class=\"id\" href=\"#MIGRATE_MOVABLE\">MIGRATE_MOVABLE</a>);", 
"", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#INIT_LIST_HEAD\">INIT_LIST_HEAD</a>(&amp;<a class=\"id\" href=\"#page\">page</a>-><a class=\"id\" href=\"#lru\">lru</a>);", 
"#<a class=\"id\" href=\"#ifdef\">ifdef</a> <a class=\"id\" href=\"#WANT_PAGE_VIRTUAL\">WANT_PAGE_VIRTUAL</a>", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"comment\">/* The shift won't overflow because ZONE_NORMAL is below 4G. */</span>", 
"<span class=\"ts\"/><span class=\"ts\"/>if (!<a class=\"id\" href=\"#is_highmem_idx\">is_highmem_idx</a>(<a class=\"id\" href=\"#zone\">zone</a>))", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#set_page_address\">set_page_address</a>(<a class=\"id\" href=\"#page\">page</a>, <a class=\"id\" href=\"#__va\">__va</a>(<a class=\"id\" href=\"#pfn\">pfn</a> << <a class=\"id\" href=\"#PAGE_SHIFT\">PAGE_SHIFT</a>));", 
"#<a class=\"id\" href=\"#endif\">endif</a>", 
"<span class=\"ts\"/>}", 
"}", 
"", 
"static void <a class=\"id\" href=\"#__meminit\">__meminit</a> <a class=\"id\" href=\"#zone_init_free_lists\">zone_init_free_lists</a>(struct <a class=\"id\" href=\"#zone\">zone</a> *<a class=\"id\" href=\"#zone\">zone</a>)", 
"{", 
"<span class=\"ts\"/>int <a class=\"id\" href=\"#order\">order</a>, <a class=\"id\" href=\"#t\">t</a>;", 
"<span class=\"ts\"/><a class=\"id\" href=\"#for_each_migratetype_order\">for_each_migratetype_order</a>(<a class=\"id\" href=\"#order\">order</a>, <a class=\"id\" href=\"#t\">t</a>) {", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#INIT_LIST_HEAD\">INIT_LIST_HEAD</a>(&amp;<a class=\"id\" href=\"#zone\">zone</a>-><a class=\"id\" href=\"#free_area\">free_area</a>[<a class=\"id\" href=\"#order\">order</a>].<a class=\"id\" href=\"#free_list\">free_list</a>[<a class=\"id\" href=\"#t\">t</a>]);", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#zone\">zone</a>-><a class=\"id\" href=\"#free_area\">free_area</a>[<a class=\"id\" href=\"#order\">order</a>].<a class=\"id\" href=\"#nr_free\">nr_free</a> = 0;", 
"<span class=\"ts\"/>}", 
"}", 
"", 
"#<a class=\"id\" href=\"#ifndef\">ifndef</a> <a class=\"id\" href=\"#__HAVE_ARCH_MEMMAP_INIT\">__HAVE_ARCH_MEMMAP_INIT</a>", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#memmap_init\">memmap_init</a>(<a class=\"id\" href=\"#size\">size</a>, <a class=\"id\" href=\"#nid\">nid</a>, <a class=\"id\" href=\"#zone\">zone</a>, <a class=\"id\" href=\"#start_pfn\">start_pfn</a>) \\", 
"<span class=\"ts\"/><a class=\"id\" href=\"#memmap_init_zone\">memmap_init_zone</a>((<a class=\"id\" href=\"#size\">size</a>), (<a class=\"id\" href=\"#nid\">nid</a>), (<a class=\"id\" href=\"#zone\">zone</a>), (<a class=\"id\" href=\"#start_pfn\">start_pfn</a>), <a class=\"id\" href=\"#MEMMAP_EARLY\">MEMMAP_EARLY</a>)", 
"#<a class=\"id\" href=\"#endif\">endif</a>", 
"", 
"static int <a class=\"id\" href=\"#zone_batchsize\">zone_batchsize</a>(struct <a class=\"id\" href=\"#zone\">zone</a> *<a class=\"id\" href=\"#zone\">zone</a>)", 
"{", 
"#<a class=\"id\" href=\"#ifdef\">ifdef</a> <a class=\"id\" href=\"#CONFIG_MMU\">CONFIG_MMU</a>", 
"<span class=\"ts\"/>int <a class=\"id\" href=\"#batch\">batch</a>;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * The per-cpu-pages pools are set to around 1000th of the</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * size of the zone.  But no more than 1/2 of a meg.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * OK, so we don't know how big the cache is.  So guess.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/><a class=\"id\" href=\"#batch\">batch</a> = <a class=\"id\" href=\"#zone\">zone</a>-><a class=\"id\" href=\"#present_pages\">present_pages</a> / 1024;", 
"<span class=\"ts\"/>if (<a class=\"id\" href=\"#batch\">batch</a> * <a class=\"id\" href=\"#PAGE_SIZE\">PAGE_SIZE</a> &gt; 512 * 1024)", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#batch\">batch</a> = (512 * 1024) / <a class=\"id\" href=\"#PAGE_SIZE\">PAGE_SIZE</a>;", 
"<span class=\"ts\"/><a class=\"id\" href=\"#batch\">batch</a> /= 4;<span class=\"ts\"/><span class=\"ts\"/><span class=\"comment\">/* We effectively *= 4 below */</span>", 
"<span class=\"ts\"/>if (<a class=\"id\" href=\"#batch\">batch</a> &lt; 1)", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#batch\">batch</a> = 1;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Clamp the batch to a 2^n - 1 value. Having a power</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * of 2 value was found to be more likely to have</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * suboptimal cache aliasing properties in some cases.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * For example if 2 tasks are alternately allocating</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * batches of pages, one task can end up with a lot</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * of pages of one half of the possible page colors</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * and the other with pages of the other colors.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/><a class=\"id\" href=\"#batch\">batch</a> = <a class=\"id\" href=\"#rounddown_pow_of_two\">rounddown_pow_of_two</a>(<a class=\"id\" href=\"#batch\">batch</a> + <a class=\"id\" href=\"#batch\">batch</a>/2) - 1;", 
"", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#batch\">batch</a>;", 
"", 
"#else", 
"<span class=\"ts\"/><span class=\"comment\">/* The deferral and batching of frees should be suppressed under NOMMU</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * conditions.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * The problem is that NOMMU needs to be able to allocate large chunks</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * of contiguous memory as there's no hardware page translation to</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * assemble apparent contiguous memory from discontiguous pages.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Queueing large contiguous runs of pages for batching, however,</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * causes the pages to actually be freed in smaller chunks.  As there</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * can be a significant delay between the individual batches being</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * recycled, this leads to the once large chunks of space being</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * fragmented and becoming unavailable for high-order allocations.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>return 0;", 
"#<a class=\"id\" href=\"#endif\">endif</a>", 
"}", 
"", 
"static void <a class=\"id\" href=\"#setup_pageset\">setup_pageset</a>(struct <a class=\"id\" href=\"#per_cpu_pageset\">per_cpu_pageset</a> *<a class=\"id\" href=\"#p\">p</a>, unsigned long <a class=\"id\" href=\"#batch\">batch</a>)", 
"{", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#per_cpu_pages\">per_cpu_pages</a> *<a class=\"id\" href=\"#pcp\">pcp</a>;", 
"<span class=\"ts\"/>int <a class=\"id\" href=\"#migratetype\">migratetype</a>;", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#memset\">memset</a>(<a class=\"id\" href=\"#p\">p</a>, 0, sizeof(*<a class=\"id\" href=\"#p\">p</a>));", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#pcp\">pcp</a> = &amp;<a class=\"id\" href=\"#p\">p</a>-><a class=\"id\" href=\"#pcp\">pcp</a>;", 
"<span class=\"ts\"/><a class=\"id\" href=\"#pcp\">pcp</a>-><a class=\"id\" href=\"#count\">count</a> = 0;", 
"<span class=\"ts\"/><a class=\"id\" href=\"#pcp\">pcp</a>-><a class=\"id\" href=\"#high\">high</a> = 6 * <a class=\"id\" href=\"#batch\">batch</a>;", 
"<span class=\"ts\"/><a class=\"id\" href=\"#pcp\">pcp</a>-><a class=\"id\" href=\"#batch\">batch</a> = <a class=\"id\" href=\"#max\">max</a>(1UL, 1 * <a class=\"id\" href=\"#batch\">batch</a>);", 
"<span class=\"ts\"/>for (<a class=\"id\" href=\"#migratetype\">migratetype</a> = 0; <a class=\"id\" href=\"#migratetype\">migratetype</a> &lt; <a class=\"id\" href=\"#MIGRATE_PCPTYPES\">MIGRATE_PCPTYPES</a>; <a class=\"id\" href=\"#migratetype\">migratetype</a>++)", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#INIT_LIST_HEAD\">INIT_LIST_HEAD</a>(&amp;<a class=\"id\" href=\"#pcp\">pcp</a>-><a class=\"id\" href=\"#lists\">lists</a>[<a class=\"id\" href=\"#migratetype\">migratetype</a>]);", 
"}", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * setup_pagelist_highmark() sets the high water mark for hot per_cpu_pagelist</span>", 
"<span class=\"comment\"> * to the value high for the pageset p.</span>", 
"<span class=\"comment\"> */</span>", 
"", 
"static void <a class=\"id\" href=\"#setup_pagelist_highmark\">setup_pagelist_highmark</a>(struct <a class=\"id\" href=\"#per_cpu_pageset\">per_cpu_pageset</a> *<a class=\"id\" href=\"#p\">p</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>unsigned long <a class=\"id\" href=\"#high\">high</a>)", 
"{", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#per_cpu_pages\">per_cpu_pages</a> *<a class=\"id\" href=\"#pcp\">pcp</a>;", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#pcp\">pcp</a> = &amp;<a class=\"id\" href=\"#p\">p</a>-><a class=\"id\" href=\"#pcp\">pcp</a>;", 
"<span class=\"ts\"/><a class=\"id\" href=\"#pcp\">pcp</a>-><a class=\"id\" href=\"#high\">high</a> = <a class=\"id\" href=\"#high\">high</a>;", 
"<span class=\"ts\"/><a class=\"id\" href=\"#pcp\">pcp</a>-><a class=\"id\" href=\"#batch\">batch</a> = <a class=\"id\" href=\"#max\">max</a>(1UL, <a class=\"id\" href=\"#high\">high</a>/4);", 
"<span class=\"ts\"/>if ((<a class=\"id\" href=\"#high\">high</a>/4) &gt; (<a class=\"id\" href=\"#PAGE_SHIFT\">PAGE_SHIFT</a> * 8))", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#pcp\">pcp</a>-><a class=\"id\" href=\"#batch\">batch</a> = <a class=\"id\" href=\"#PAGE_SHIFT\">PAGE_SHIFT</a> * 8;", 
"}", 
"", 
"static <a class=\"id\" href=\"#__meminit\">__meminit</a> void <a class=\"id\" href=\"#setup_zone_pageset\">setup_zone_pageset</a>(struct <a class=\"id\" href=\"#zone\">zone</a> *<a class=\"id\" href=\"#zone\">zone</a>)", 
"{", 
"<span class=\"ts\"/>int <a class=\"id\" href=\"#cpu\">cpu</a>;", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#zone\">zone</a>-><a class=\"id\" href=\"#pageset\">pageset</a> = <a class=\"id\" href=\"#alloc_percpu\">alloc_percpu</a>(struct <a class=\"id\" href=\"#per_cpu_pageset\">per_cpu_pageset</a>);", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#for_each_possible_cpu\">for_each_possible_cpu</a>(<a class=\"id\" href=\"#cpu\">cpu</a>) {", 
"<span class=\"ts\"/><span class=\"ts\"/>struct <a class=\"id\" href=\"#per_cpu_pageset\">per_cpu_pageset</a> *<a class=\"id\" href=\"#pcp\">pcp</a> = <a class=\"id\" href=\"#per_cpu_ptr\">per_cpu_ptr</a>(<a class=\"id\" href=\"#zone\">zone</a>-><a class=\"id\" href=\"#pageset\">pageset</a>, <a class=\"id\" href=\"#cpu\">cpu</a>);", 
"", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#setup_pageset\">setup_pageset</a>(<a class=\"id\" href=\"#pcp\">pcp</a>, <a class=\"id\" href=\"#zone_batchsize\">zone_batchsize</a>(<a class=\"id\" href=\"#zone\">zone</a>));", 
"", 
"<span class=\"ts\"/><span class=\"ts\"/>if (<a class=\"id\" href=\"#percpu_pagelist_fraction\">percpu_pagelist_fraction</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#setup_pagelist_highmark\">setup_pagelist_highmark</a>(<a class=\"id\" href=\"#pcp\">pcp</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>(<a class=\"id\" href=\"#zone\">zone</a>-><a class=\"id\" href=\"#present_pages\">present_pages</a> /", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#percpu_pagelist_fraction\">percpu_pagelist_fraction</a>));", 
"<span class=\"ts\"/>}", 
"}", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * Allocate per cpu pagesets and initialize them.</span>", 
"<span class=\"comment\"> * Before this call only boot pagesets were available.</span>", 
"<span class=\"comment\"> */</span>", 
"void <a class=\"id\" href=\"#__init\">__init</a> <a class=\"id\" href=\"#setup_per_cpu_pageset\">setup_per_cpu_pageset</a>(void)", 
"{", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#zone\">zone</a> *<a class=\"id\" href=\"#zone\">zone</a>;", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#for_each_populated_zone\">for_each_populated_zone</a>(<a class=\"id\" href=\"#zone\">zone</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#setup_zone_pageset\">setup_zone_pageset</a>(<a class=\"id\" href=\"#zone\">zone</a>);", 
"}", 
"", 
"static <a class=\"id\" href=\"#noinline\">noinline</a> <a class=\"id\" href=\"#__init_refok\">__init_refok</a>", 
"int <a class=\"id\" href=\"#zone_wait_table_init\">zone_wait_table_init</a>(struct <a class=\"id\" href=\"#zone\">zone</a> *<a class=\"id\" href=\"#zone\">zone</a>, unsigned long <a class=\"id\" href=\"#zone_size_pages\">zone_size_pages</a>)", 
"{", 
"<span class=\"ts\"/>int <a class=\"id\" href=\"#i\">i</a>;", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#pglist_data\">pglist_data</a> *<a class=\"id\" href=\"#pgdat\">pgdat</a> = <a class=\"id\" href=\"#zone\">zone</a>-><a class=\"id\" href=\"#zone_pgdat\">zone_pgdat</a>;", 
"<span class=\"ts\"/><a class=\"id\" href=\"#size_t\">size_t</a> <a class=\"id\" href=\"#alloc_size\">alloc_size</a>;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * The per-page waitqueue mechanism uses hashed waitqueues</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * per zone.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/><a class=\"id\" href=\"#zone\">zone</a>-><a class=\"id\" href=\"#wait_table_hash_nr_entries\">wait_table_hash_nr_entries</a> =", 
"<span class=\"ts\"/><span class=\"ts\"/> <a class=\"id\" href=\"#wait_table_hash_nr_entries\">wait_table_hash_nr_entries</a>(<a class=\"id\" href=\"#zone_size_pages\">zone_size_pages</a>);", 
"<span class=\"ts\"/><a class=\"id\" href=\"#zone\">zone</a>-><a class=\"id\" href=\"#wait_table_bits\">wait_table_bits</a> =", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#wait_table_bits\">wait_table_bits</a>(<a class=\"id\" href=\"#zone\">zone</a>-><a class=\"id\" href=\"#wait_table_hash_nr_entries\">wait_table_hash_nr_entries</a>);", 
"<span class=\"ts\"/><a class=\"id\" href=\"#alloc_size\">alloc_size</a> = <a class=\"id\" href=\"#zone\">zone</a>-><a class=\"id\" href=\"#wait_table_hash_nr_entries\">wait_table_hash_nr_entries</a>", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>* sizeof(<a class=\"id\" href=\"#wait_queue_head_t\">wait_queue_head_t</a>);", 
"", 
"<span class=\"ts\"/>if (!<a class=\"id\" href=\"#slab_is_available\">slab_is_available</a>()) {", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#zone\">zone</a>-><a class=\"id\" href=\"#wait_table\">wait_table</a> = (<a class=\"id\" href=\"#wait_queue_head_t\">wait_queue_head_t</a> *)", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#alloc_bootmem_node\">alloc_bootmem_node</a>(<a class=\"id\" href=\"#pgdat\">pgdat</a>, <a class=\"id\" href=\"#alloc_size\">alloc_size</a>);", 
"<span class=\"ts\"/>} else {", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/><span class=\"ts\"/> * This case means that a zone whose size was 0 gets new memory</span>", 
"<span class=\"comment\"><span class=\"ts\"/><span class=\"ts\"/> * via memory hot-add.</span>", 
"<span class=\"comment\"><span class=\"ts\"/><span class=\"ts\"/> * But it may be the case that a new node was hot-added.  In</span>", 
"<span class=\"comment\"><span class=\"ts\"/><span class=\"ts\"/> * this case vmalloc() will not be able to use this new node's</span>", 
"<span class=\"comment\"><span class=\"ts\"/><span class=\"ts\"/> * memory - this wait_table must be initialized to use this new</span>", 
"<span class=\"comment\"><span class=\"ts\"/><span class=\"ts\"/> * node itself as well.</span>", 
"<span class=\"comment\"><span class=\"ts\"/><span class=\"ts\"/> * To use this new node's memory, further consideration will be</span>", 
"<span class=\"comment\"><span class=\"ts\"/><span class=\"ts\"/> * necessary.</span>", 
"<span class=\"comment\"><span class=\"ts\"/><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#zone\">zone</a>-><a class=\"id\" href=\"#wait_table\">wait_table</a> = <a class=\"id\" href=\"#vmalloc\">vmalloc</a>(<a class=\"id\" href=\"#alloc_size\">alloc_size</a>);", 
"<span class=\"ts\"/>}", 
"<span class=\"ts\"/>if (!<a class=\"id\" href=\"#zone\">zone</a>-><a class=\"id\" href=\"#wait_table\">wait_table</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/>return -<a class=\"id\" href=\"#ENOMEM\">ENOMEM</a>;", 
"", 
"<span class=\"ts\"/>for(<a class=\"id\" href=\"#i\">i</a> = 0; <a class=\"id\" href=\"#i\">i</a> &lt; <a class=\"id\" href=\"#zone\">zone</a>-><a class=\"id\" href=\"#wait_table_hash_nr_entries\">wait_table_hash_nr_entries</a>; ++<a class=\"id\" href=\"#i\">i</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#init_waitqueue_head\">init_waitqueue_head</a>(<a class=\"id\" href=\"#zone\">zone</a>-><a class=\"id\" href=\"#wait_table\">wait_table</a> + <a class=\"id\" href=\"#i\">i</a>);", 
"", 
"<span class=\"ts\"/>return 0;", 
"}", 
"", 
"static int <a class=\"id\" href=\"#__zone_pcp_update\">__zone_pcp_update</a>(void *<a class=\"id\" href=\"#data\">data</a>)", 
"{", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#zone\">zone</a> *<a class=\"id\" href=\"#zone\">zone</a> = <a class=\"id\" href=\"#data\">data</a>;", 
"<span class=\"ts\"/>int <a class=\"id\" href=\"#cpu\">cpu</a>;", 
"<span class=\"ts\"/>unsigned long <a class=\"id\" href=\"#batch\">batch</a> = <a class=\"id\" href=\"#zone_batchsize\">zone_batchsize</a>(<a class=\"id\" href=\"#zone\">zone</a>), <a class=\"id\" href=\"#flags\">flags</a>;", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#for_each_possible_cpu\">for_each_possible_cpu</a>(<a class=\"id\" href=\"#cpu\">cpu</a>) {", 
"<span class=\"ts\"/><span class=\"ts\"/>struct <a class=\"id\" href=\"#per_cpu_pageset\">per_cpu_pageset</a> *<a class=\"id\" href=\"#pset\">pset</a>;", 
"<span class=\"ts\"/><span class=\"ts\"/>struct <a class=\"id\" href=\"#per_cpu_pages\">per_cpu_pages</a> *<a class=\"id\" href=\"#pcp\">pcp</a>;", 
"", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#pset\">pset</a> = <a class=\"id\" href=\"#per_cpu_ptr\">per_cpu_ptr</a>(<a class=\"id\" href=\"#zone\">zone</a>-><a class=\"id\" href=\"#pageset\">pageset</a>, <a class=\"id\" href=\"#cpu\">cpu</a>);", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#pcp\">pcp</a> = &amp;<a class=\"id\" href=\"#pset\">pset</a>-><a class=\"id\" href=\"#pcp\">pcp</a>;", 
"", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#local_irq_save\">local_irq_save</a>(<a class=\"id\" href=\"#flags\">flags</a>);", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#free_pcppages_bulk\">free_pcppages_bulk</a>(<a class=\"id\" href=\"#zone\">zone</a>, <a class=\"id\" href=\"#pcp\">pcp</a>-><a class=\"id\" href=\"#count\">count</a>, <a class=\"id\" href=\"#pcp\">pcp</a>);", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#setup_pageset\">setup_pageset</a>(<a class=\"id\" href=\"#pset\">pset</a>, <a class=\"id\" href=\"#batch\">batch</a>);", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#local_irq_restore\">local_irq_restore</a>(<a class=\"id\" href=\"#flags\">flags</a>);", 
"<span class=\"ts\"/>}", 
"<span class=\"ts\"/>return 0;", 
"}", 
"", 
"void <a class=\"id\" href=\"#zone_pcp_update\">zone_pcp_update</a>(struct <a class=\"id\" href=\"#zone\">zone</a> *<a class=\"id\" href=\"#zone\">zone</a>)", 
"{", 
"<span class=\"ts\"/><a class=\"id\" href=\"#stop_machine\">stop_machine</a>(<a class=\"id\" href=\"#__zone_pcp_update\">__zone_pcp_update</a>, <a class=\"id\" href=\"#zone\">zone</a>, <a class=\"id\" href=\"#NULL\">NULL</a>);", 
"}", 
"", 
"static <a class=\"id\" href=\"#__meminit\">__meminit</a> void <a class=\"id\" href=\"#zone_pcp_init\">zone_pcp_init</a>(struct <a class=\"id\" href=\"#zone\">zone</a> *<a class=\"id\" href=\"#zone\">zone</a>)", 
"{", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * per cpu subsystem is not up at this point. The following code</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * relies on the ability of the linker to provide the</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * offset of a (static) per cpu variable into the per cpu area.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/><a class=\"id\" href=\"#zone\">zone</a>-><a class=\"id\" href=\"#pageset\">pageset</a> = &amp;<a class=\"id\" href=\"#boot_pageset\">boot_pageset</a>;", 
"", 
"<span class=\"ts\"/>if (<a class=\"id\" href=\"#zone\">zone</a>-><a class=\"id\" href=\"#present_pages\">present_pages</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#printk\">printk</a>(<a class=\"id\" href=\"#KERN_DEBUG\">KERN_DEBUG</a> \"  %s zone: %lu pages, LIFO batch:%u\\n\",", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#zone\">zone</a>-><a class=\"id\" href=\"#name\">name</a>, <a class=\"id\" href=\"#zone\">zone</a>-><a class=\"id\" href=\"#present_pages\">present_pages</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/> <a class=\"id\" href=\"#zone_batchsize\">zone_batchsize</a>(<a class=\"id\" href=\"#zone\">zone</a>));", 
"}", 
"", 
"<a class=\"id\" href=\"#__meminit\">__meminit</a> int <a class=\"id\" href=\"#init_currently_empty_zone\">init_currently_empty_zone</a>(struct <a class=\"id\" href=\"#zone\">zone</a> *<a class=\"id\" href=\"#zone\">zone</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>unsigned long <a class=\"id\" href=\"#zone_start_pfn\">zone_start_pfn</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>unsigned long <a class=\"id\" href=\"#size\">size</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>enum <a class=\"id\" href=\"#memmap_context\">memmap_context</a> <a class=\"id\" href=\"#context\">context</a>)", 
"{", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#pglist_data\">pglist_data</a> *<a class=\"id\" href=\"#pgdat\">pgdat</a> = <a class=\"id\" href=\"#zone\">zone</a>-><a class=\"id\" href=\"#zone_pgdat\">zone_pgdat</a>;", 
"<span class=\"ts\"/>int <a class=\"id\" href=\"#ret\">ret</a>;", 
"<span class=\"ts\"/><a class=\"id\" href=\"#ret\">ret</a> = <a class=\"id\" href=\"#zone_wait_table_init\">zone_wait_table_init</a>(<a class=\"id\" href=\"#zone\">zone</a>, <a class=\"id\" href=\"#size\">size</a>);", 
"<span class=\"ts\"/>if (<a class=\"id\" href=\"#ret\">ret</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/>return <a class=\"id\" href=\"#ret\">ret</a>;", 
"<span class=\"ts\"/><a class=\"id\" href=\"#pgdat\">pgdat</a>-><a class=\"id\" href=\"#nr_zones\">nr_zones</a> = <a class=\"id\" href=\"#zone_idx\">zone_idx</a>(<a class=\"id\" href=\"#zone\">zone</a>) + 1;", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#zone\">zone</a>-><a class=\"id\" href=\"#zone_start_pfn\">zone_start_pfn</a> = <a class=\"id\" href=\"#zone_start_pfn\">zone_start_pfn</a>;", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#mminit_dprintk\">mminit_dprintk</a>(<a class=\"id\" href=\"#MMINIT_TRACE\">MMINIT_TRACE</a>, \"memmap_init\",", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>\"Initialising map node %d zone %lu pfns %lu -> %lu\\n\",", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#pgdat\">pgdat</a>-><a class=\"id\" href=\"#node_id\">node_id</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>(unsigned long)<a class=\"id\" href=\"#zone_idx\">zone_idx</a>(<a class=\"id\" href=\"#zone\">zone</a>),", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#zone_start_pfn\">zone_start_pfn</a>, (<a class=\"id\" href=\"#zone_start_pfn\">zone_start_pfn</a> + <a class=\"id\" href=\"#size\">size</a>));", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#zone_init_free_lists\">zone_init_free_lists</a>(<a class=\"id\" href=\"#zone\">zone</a>);", 
"", 
"<span class=\"ts\"/>return 0;", 
"}", 
"", 
"#<a class=\"id\" href=\"#ifdef\">ifdef</a> <a class=\"id\" href=\"#CONFIG_ARCH_POPULATES_NODE_MAP\">CONFIG_ARCH_POPULATES_NODE_MAP</a>", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * Basic iterator support. Return the first range of PFNs for a node</span>", 
"<span class=\"comment\"> * Note: nid == MAX_NUMNODES returns first region regardless of node</span>", 
"<span class=\"comment\"> */</span>", 
"static int <a class=\"id\" href=\"#__meminit\">__meminit</a> <a class=\"id\" href=\"#first_active_region_index_in_nid\">first_active_region_index_in_nid</a>(int <a class=\"id\" href=\"#nid\">nid</a>)", 
"{", 
"<span class=\"ts\"/>int <a class=\"id\" href=\"#i\">i</a>;", 
"", 
"<span class=\"ts\"/>for (<a class=\"id\" href=\"#i\">i</a> = 0; <a class=\"id\" href=\"#i\">i</a> &lt; <a class=\"id\" href=\"#nr_nodemap_entries\">nr_nodemap_entries</a>; <a class=\"id\" href=\"#i\">i</a>++)", 
"<span class=\"ts\"/><span class=\"ts\"/>if (<a class=\"id\" href=\"#nid\">nid</a> == <a class=\"id\" href=\"#MAX_NUMNODES\">MAX_NUMNODES</a> || <a class=\"id\" href=\"#early_node_map\">early_node_map</a>[<a class=\"id\" href=\"#i\">i</a>].<a class=\"id\" href=\"#nid\">nid</a> == <a class=\"id\" href=\"#nid\">nid</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>return <a class=\"id\" href=\"#i\">i</a>;", 
"", 
"<span class=\"ts\"/>return -1;", 
"}", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * Basic iterator support. Return the next active range of PFNs for a node</span>", 
"<span class=\"comment\"> * Note: nid == MAX_NUMNODES returns next region regardless of node</span>", 
"<span class=\"comment\"> */</span>", 
"static int <a class=\"id\" href=\"#__meminit\">__meminit</a> <a class=\"id\" href=\"#next_active_region_index_in_nid\">next_active_region_index_in_nid</a>(int <a class=\"id\" href=\"#index\">index</a>, int <a class=\"id\" href=\"#nid\">nid</a>)", 
"{", 
"<span class=\"ts\"/>for (<a class=\"id\" href=\"#index\">index</a> = <a class=\"id\" href=\"#index\">index</a> + 1; <a class=\"id\" href=\"#index\">index</a> &lt; <a class=\"id\" href=\"#nr_nodemap_entries\">nr_nodemap_entries</a>; <a class=\"id\" href=\"#index\">index</a>++)", 
"<span class=\"ts\"/><span class=\"ts\"/>if (<a class=\"id\" href=\"#nid\">nid</a> == <a class=\"id\" href=\"#MAX_NUMNODES\">MAX_NUMNODES</a> || <a class=\"id\" href=\"#early_node_map\">early_node_map</a>[<a class=\"id\" href=\"#index\">index</a>].<a class=\"id\" href=\"#nid\">nid</a> == <a class=\"id\" href=\"#nid\">nid</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>return <a class=\"id\" href=\"#index\">index</a>;", 
"", 
"<span class=\"ts\"/>return -1;", 
"}", 
"", 
"#<a class=\"id\" href=\"#ifndef\">ifndef</a> <a class=\"id\" href=\"#CONFIG_HAVE_ARCH_EARLY_PFN_TO_NID\">CONFIG_HAVE_ARCH_EARLY_PFN_TO_NID</a>", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * Required by SPARSEMEM. Given a PFN, return what node the PFN is on.</span>", 
"<span class=\"comment\"> * Architectures may implement their own version but if add_active_range()</span>", 
"<span class=\"comment\"> * was used and there are no special requirements, this is a convenient</span>", 
"<span class=\"comment\"> * alternative</span>", 
"<span class=\"comment\"> */</span>", 
"int <a class=\"id\" href=\"#__meminit\">__meminit</a> <a class=\"id\" href=\"#__early_pfn_to_nid\">__early_pfn_to_nid</a>(unsigned long <a class=\"id\" href=\"#pfn\">pfn</a>)", 
"{", 
"<span class=\"ts\"/>int <a class=\"id\" href=\"#i\">i</a>;", 
"", 
"<span class=\"ts\"/>for (<a class=\"id\" href=\"#i\">i</a> = 0; <a class=\"id\" href=\"#i\">i</a> &lt; <a class=\"id\" href=\"#nr_nodemap_entries\">nr_nodemap_entries</a>; <a class=\"id\" href=\"#i\">i</a>++) {", 
"<span class=\"ts\"/><span class=\"ts\"/>unsigned long <a class=\"id\" href=\"#start_pfn\">start_pfn</a> = <a class=\"id\" href=\"#early_node_map\">early_node_map</a>[<a class=\"id\" href=\"#i\">i</a>].<a class=\"id\" href=\"#start_pfn\">start_pfn</a>;", 
"<span class=\"ts\"/><span class=\"ts\"/>unsigned long <a class=\"id\" href=\"#end_pfn\">end_pfn</a> = <a class=\"id\" href=\"#early_node_map\">early_node_map</a>[<a class=\"id\" href=\"#i\">i</a>].<a class=\"id\" href=\"#end_pfn\">end_pfn</a>;", 
"", 
"<span class=\"ts\"/><span class=\"ts\"/>if (<a class=\"id\" href=\"#start_pfn\">start_pfn</a> <= <a class=\"id\" href=\"#pfn\">pfn</a> && <a class=\"id\" href=\"#pfn\">pfn</a> &lt; <a class=\"id\" href=\"#end_pfn\">end_pfn</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>return <a class=\"id\" href=\"#early_node_map\">early_node_map</a>[<a class=\"id\" href=\"#i\">i</a>].<a class=\"id\" href=\"#nid\">nid</a>;", 
"<span class=\"ts\"/>}", 
"<span class=\"ts\"/><span class=\"comment\">/* This is a memory hole */</span>", 
"<span class=\"ts\"/>return -1;", 
"}", 
"#<a class=\"id\" href=\"#endif\">endif</a> <span class=\"comment\">/* CONFIG_HAVE_ARCH_EARLY_PFN_TO_NID */</span>", 
"", 
"int <a class=\"id\" href=\"#__meminit\">__meminit</a> <a class=\"id\" href=\"#early_pfn_to_nid\">early_pfn_to_nid</a>(unsigned long <a class=\"id\" href=\"#pfn\">pfn</a>)", 
"{", 
"<span class=\"ts\"/>int <a class=\"id\" href=\"#nid\">nid</a>;", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#nid\">nid</a> = <a class=\"id\" href=\"#__early_pfn_to_nid\">__early_pfn_to_nid</a>(<a class=\"id\" href=\"#pfn\">pfn</a>);", 
"<span class=\"ts\"/>if (<a class=\"id\" href=\"#nid\">nid</a> >= 0)", 
"<span class=\"ts\"/><span class=\"ts\"/>return <a class=\"id\" href=\"#nid\">nid</a>;", 
"<span class=\"ts\"/><span class=\"comment\">/* just returns 0 */</span>", 
"<span class=\"ts\"/>return 0;", 
"}", 
"", 
"#<a class=\"id\" href=\"#ifdef\">ifdef</a> <a class=\"id\" href=\"#CONFIG_NODES_SPAN_OTHER_NODES\">CONFIG_NODES_SPAN_OTHER_NODES</a>", 
"<a class=\"id\" href=\"#bool\">bool</a> <a class=\"id\" href=\"#__meminit\">__meminit</a> <a class=\"id\" href=\"#early_pfn_in_nid\">early_pfn_in_nid</a>(unsigned long <a class=\"id\" href=\"#pfn\">pfn</a>, int <a class=\"id\" href=\"#node\">node</a>)", 
"{", 
"<span class=\"ts\"/>int <a class=\"id\" href=\"#nid\">nid</a>;", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#nid\">nid</a> = <a class=\"id\" href=\"#__early_pfn_to_nid\">__early_pfn_to_nid</a>(<a class=\"id\" href=\"#pfn\">pfn</a>);", 
"<span class=\"ts\"/>if (<a class=\"id\" href=\"#nid\">nid</a> >= 0 && <a class=\"id\" href=\"#nid\">nid</a> != <a class=\"id\" href=\"#node\">node</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/>return <a class=\"id\" href=\"#false\">false</a>;", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#true\">true</a>;", 
"}", 
"#<a class=\"id\" href=\"#endif\">endif</a>", 
"", 
"<span class=\"comment\">/* Basic iterator support to walk early_node_map[] */</span>", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#for_each_active_range_index_in_nid\">for_each_active_range_index_in_nid</a>(<a class=\"id\" href=\"#i\">i</a>, <a class=\"id\" href=\"#nid\">nid</a>) \\", 
"<span class=\"ts\"/>for (<a class=\"id\" href=\"#i\">i</a> = <a class=\"id\" href=\"#first_active_region_index_in_nid\">first_active_region_index_in_nid</a>(<a class=\"id\" href=\"#nid\">nid</a>); <a class=\"id\" href=\"#i\">i</a> != -1; \\", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#i\">i</a> = <a class=\"id\" href=\"#next_active_region_index_in_nid\">next_active_region_index_in_nid</a>(<a class=\"id\" href=\"#i\">i</a>, <a class=\"id\" href=\"#nid\">nid</a>))", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * free_bootmem_with_active_regions - Call free_bootmem_node for each active range</span>", 
"<span class=\"comment\"> * @nid: The node to free memory on. If MAX_NUMNODES, all nodes are freed.</span>", 
];
xr_frag_insert('l/49/415a21e90bb6a7d21d6f3ee1ce734cf71c1d2a.xr', __xr_tmp);
