var __xr_tmp = [
"#<a class=\"id\" href=\"#ifndef\">ifndef</a> <a class=\"id\" href=\"#_ASM_X86_SYNC_BITOPS_H\">_ASM_X86_SYNC_BITOPS_H</a>", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#_ASM_X86_SYNC_BITOPS_H\">_ASM_X86_SYNC_BITOPS_H</a>", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * Copyright 1992, Linus Torvalds.</span>", 
"<span class=\"comment\"> */</span>", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * These have to be done with inline assembly: that way the bit-setting</span>", 
"<span class=\"comment\"> * is guaranteed to be atomic. All bit operations return 0 if the bit</span>", 
"<span class=\"comment\"> * was cleared before the operation and != 0 if it was not.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * bit 0 is the LSB of addr; bit 32 is the LSB of (addr+1).</span>", 
"<span class=\"comment\"> */</span>", 
"", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#ADDR\">ADDR</a> (*(volatile long *)<a class=\"id\" href=\"#addr\">addr</a>)", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * sync_set_bit - Atomically set a bit in memory</span>", 
"<span class=\"comment\"> * @nr: the bit to set</span>", 
"<span class=\"comment\"> * @addr: the address to start counting from</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * This function is atomic and may not be reordered.  See __set_bit()</span>", 
"<span class=\"comment\"> * if you do not require the atomic guarantees.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Note that @nr may be almost arbitrarily large; this function is not</span>", 
"<span class=\"comment\"> * restricted to acting on a single-word quantity.</span>", 
"<span class=\"comment\"> */</span>", 
"static <a class=\"id\" href=\"#inline\">inline</a> void <a class=\"id\" href=\"#sync_set_bit\">sync_set_bit</a>(int <a class=\"id\" href=\"#nr\">nr</a>, volatile unsigned long *<a class=\"id\" href=\"#addr\">addr</a>)", 
"{", 
"<span class=\"ts\"/><a class=\"id\" href=\"#asm\">asm</a> volatile(\"lock; btsl %1,%0\"", 
"<span class=\"ts\"/><span class=\"ts\"/>     : \"+m\" (<a class=\"id\" href=\"#ADDR\">ADDR</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/>     : \"Ir\" (<a class=\"id\" href=\"#nr\">nr</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/>     : \"memory\");", 
"}", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * sync_clear_bit - Clears a bit in memory</span>", 
"<span class=\"comment\"> * @nr: Bit to clear</span>", 
"<span class=\"comment\"> * @addr: Address to start counting from</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * sync_clear_bit() is atomic and may not be reordered.  However, it does</span>", 
"<span class=\"comment\"> * not contain a memory barrier, so if it is used for locking purposes,</span>", 
"<span class=\"comment\"> * you should call smp_mb__before_clear_bit() and/or smp_mb__after_clear_bit()</span>", 
"<span class=\"comment\"> * in order to ensure changes are visible on other processors.</span>", 
"<span class=\"comment\"> */</span>", 
"static <a class=\"id\" href=\"#inline\">inline</a> void <a class=\"id\" href=\"#sync_clear_bit\">sync_clear_bit</a>(int <a class=\"id\" href=\"#nr\">nr</a>, volatile unsigned long *<a class=\"id\" href=\"#addr\">addr</a>)", 
"{", 
"<span class=\"ts\"/><a class=\"id\" href=\"#asm\">asm</a> volatile(\"lock; btrl %1,%0\"", 
"<span class=\"ts\"/><span class=\"ts\"/>     : \"+m\" (<a class=\"id\" href=\"#ADDR\">ADDR</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/>     : \"Ir\" (<a class=\"id\" href=\"#nr\">nr</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/>     : \"memory\");", 
"}", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * sync_change_bit - Toggle a bit in memory</span>", 
"<span class=\"comment\"> * @nr: Bit to change</span>", 
"<span class=\"comment\"> * @addr: Address to start counting from</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * sync_change_bit() is atomic and may not be reordered.</span>", 
"<span class=\"comment\"> * Note that @nr may be almost arbitrarily large; this function is not</span>", 
"<span class=\"comment\"> * restricted to acting on a single-word quantity.</span>", 
"<span class=\"comment\"> */</span>", 
"static <a class=\"id\" href=\"#inline\">inline</a> void <a class=\"id\" href=\"#sync_change_bit\">sync_change_bit</a>(int <a class=\"id\" href=\"#nr\">nr</a>, volatile unsigned long *<a class=\"id\" href=\"#addr\">addr</a>)", 
"{", 
"<span class=\"ts\"/><a class=\"id\" href=\"#asm\">asm</a> volatile(\"lock; btcl %1,%0\"", 
"<span class=\"ts\"/><span class=\"ts\"/>     : \"+m\" (<a class=\"id\" href=\"#ADDR\">ADDR</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/>     : \"Ir\" (<a class=\"id\" href=\"#nr\">nr</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/>     : \"memory\");", 
"}", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * sync_test_and_set_bit - Set a bit and return its old value</span>", 
"<span class=\"comment\"> * @nr: Bit to set</span>", 
"<span class=\"comment\"> * @addr: Address to count from</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * This operation is atomic and cannot be reordered.</span>", 
"<span class=\"comment\"> * It also implies a memory barrier.</span>", 
"<span class=\"comment\"> */</span>", 
"static <a class=\"id\" href=\"#inline\">inline</a> int <a class=\"id\" href=\"#sync_test_and_set_bit\">sync_test_and_set_bit</a>(int <a class=\"id\" href=\"#nr\">nr</a>, volatile unsigned long *<a class=\"id\" href=\"#addr\">addr</a>)", 
"{", 
"<span class=\"ts\"/>int <a class=\"id\" href=\"#oldbit\">oldbit</a>;", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#asm\">asm</a> volatile(\"lock; btsl %2,%1\\n\\tsbbl %0,%0\"", 
"<span class=\"ts\"/><span class=\"ts\"/>     : \"=r\" (<a class=\"id\" href=\"#oldbit\">oldbit</a>), \"+m\" (<a class=\"id\" href=\"#ADDR\">ADDR</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/>     : \"Ir\" (<a class=\"id\" href=\"#nr\">nr</a>) : \"memory\");", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#oldbit\">oldbit</a>;", 
"}", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * sync_test_and_clear_bit - Clear a bit and return its old value</span>", 
"<span class=\"comment\"> * @nr: Bit to clear</span>", 
"<span class=\"comment\"> * @addr: Address to count from</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * This operation is atomic and cannot be reordered.</span>", 
"<span class=\"comment\"> * It also implies a memory barrier.</span>", 
"<span class=\"comment\"> */</span>", 
"static <a class=\"id\" href=\"#inline\">inline</a> int <a class=\"id\" href=\"#sync_test_and_clear_bit\">sync_test_and_clear_bit</a>(int <a class=\"id\" href=\"#nr\">nr</a>, volatile unsigned long *<a class=\"id\" href=\"#addr\">addr</a>)", 
"{", 
"<span class=\"ts\"/>int <a class=\"id\" href=\"#oldbit\">oldbit</a>;", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#asm\">asm</a> volatile(\"lock; btrl %2,%1\\n\\tsbbl %0,%0\"", 
"<span class=\"ts\"/><span class=\"ts\"/>     : \"=r\" (<a class=\"id\" href=\"#oldbit\">oldbit</a>), \"+m\" (<a class=\"id\" href=\"#ADDR\">ADDR</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/>     : \"Ir\" (<a class=\"id\" href=\"#nr\">nr</a>) : \"memory\");", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#oldbit\">oldbit</a>;", 
"}", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * sync_test_and_change_bit - Change a bit and return its old value</span>", 
"<span class=\"comment\"> * @nr: Bit to change</span>", 
"<span class=\"comment\"> * @addr: Address to count from</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * This operation is atomic and cannot be reordered.</span>", 
"<span class=\"comment\"> * It also implies a memory barrier.</span>", 
"<span class=\"comment\"> */</span>", 
"static <a class=\"id\" href=\"#inline\">inline</a> int <a class=\"id\" href=\"#sync_test_and_change_bit\">sync_test_and_change_bit</a>(int <a class=\"id\" href=\"#nr\">nr</a>, volatile unsigned long *<a class=\"id\" href=\"#addr\">addr</a>)", 
"{", 
"<span class=\"ts\"/>int <a class=\"id\" href=\"#oldbit\">oldbit</a>;", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#asm\">asm</a> volatile(\"lock; btcl %2,%1\\n\\tsbbl %0,%0\"", 
"<span class=\"ts\"/><span class=\"ts\"/>     : \"=r\" (<a class=\"id\" href=\"#oldbit\">oldbit</a>), \"+m\" (<a class=\"id\" href=\"#ADDR\">ADDR</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/>     : \"Ir\" (<a class=\"id\" href=\"#nr\">nr</a>) : \"memory\");", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#oldbit\">oldbit</a>;", 
"}", 
"", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#sync_test_bit\">sync_test_bit</a>(<a class=\"id\" href=\"#nr\">nr</a>, <a class=\"id\" href=\"#addr\">addr</a>) <a class=\"id\" href=\"#test_bit\">test_bit</a>(<a class=\"id\" href=\"#nr\">nr</a>, <a class=\"id\" href=\"#addr\">addr</a>)", 
"", 
"#<a class=\"id\" href=\"#undef\">undef</a> <a class=\"id\" href=\"#ADDR\">ADDR</a>", 
"", 
"#<a class=\"id\" href=\"#endif\">endif</a> <span class=\"comment\">/* _ASM_X86_SYNC_BITOPS_H */</span>", 
];
xr_frag_insert('l/4a/a3657348ea17098e0ed06136bcec6f303ba428.xr', __xr_tmp);
