var __xr_tmp = [
"<span class=\"comment\">/* zlib.h -- interface of the 'zlib' general purpose compression library</span>", 
"<span class=\"comment\"></span>", 
"<span class=\"comment\">  Copyright (C) 1995-2005 Jean-loup Gailly and Mark Adler</span>", 
"<span class=\"comment\"></span>", 
"<span class=\"comment\">  This software is provided 'as-is', without any express or implied</span>", 
"<span class=\"comment\">  warranty.  In no event will the authors be held liable for any damages</span>", 
"<span class=\"comment\">  arising from the use of this software.</span>", 
"<span class=\"comment\"></span>", 
"<span class=\"comment\">  Permission is granted to anyone to use this software for any purpose,</span>", 
"<span class=\"comment\">  including commercial applications, and to alter it and redistribute it</span>", 
"<span class=\"comment\">  freely, subject to the following restrictions:</span>", 
"<span class=\"comment\"></span>", 
"<span class=\"comment\">  1. The origin of this software must not be misrepresented; you must not</span>", 
"<span class=\"comment\">     claim that you wrote the original software. If you use this software</span>", 
"<span class=\"comment\">     in a product, an acknowledgment in the product documentation would be</span>", 
"<span class=\"comment\">     appreciated but is not required.</span>", 
"<span class=\"comment\">  2. Altered source versions must be plainly marked as such, and must not be</span>", 
"<span class=\"comment\">     misrepresented as being the original software.</span>", 
"<span class=\"comment\">  3. This notice may not be removed or altered from any source distribution.</span>", 
"<span class=\"comment\"></span>", 
"<span class=\"comment\">  Jean-loup Gailly        Mark Adler</span>", 
"<span class=\"comment\">  jloup@gzip.org          madler@alumni.caltech.edu</span>", 
"<span class=\"comment\"></span>", 
"<span class=\"comment\"></span>", 
"<span class=\"comment\">  The data format used by the zlib library is described by RFCs (Request for</span>", 
"<span class=\"comment\">  Comments) 1950 to 1952 in the files http://www.ietf.org/rfc/rfc1950.txt</span>", 
"<span class=\"comment\">  (zlib format), rfc1951.txt (deflate format) and rfc1952.txt (gzip format).</span>", 
"<span class=\"comment\">*/</span>", 
"", 
"#<a class=\"id\" href=\"#ifndef\">ifndef</a> <a class=\"id\" href=\"#_ZLIB_H\">_ZLIB_H</a>", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#_ZLIB_H\">_ZLIB_H</a>", 
"", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#zconf\">zconf</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"", 
"<span class=\"comment\">/* zlib deflate based on ZLIB_VERSION \"1.1.3\" */</span>", 
"<span class=\"comment\">/* zlib inflate based on ZLIB_VERSION \"1.2.3\" */</span>", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\">  This is a modified version of zlib for use inside the Linux kernel.</span>", 
"<span class=\"comment\">  The main changes are to perform all memory allocation in advance.</span>", 
"<span class=\"comment\"></span>", 
"<span class=\"comment\">  Inflation Changes:</span>", 
"<span class=\"comment\">    * Z_PACKET_FLUSH is added and used by ppp_deflate. Before returning</span>", 
"<span class=\"comment\">      this checks there is no more input data available and the next data</span>", 
"<span class=\"comment\">      is a STORED block. It also resets the mode to be read for the next</span>", 
"<span class=\"comment\">      data, all as per PPP requirements.</span>", 
"<span class=\"comment\">    * Addition of zlib_inflateIncomp which copies incompressible data into</span>", 
"<span class=\"comment\">      the history window and adjusts the accoutning without calling</span>", 
"<span class=\"comment\">      zlib_inflate itself to inflate the data.</span>", 
"<span class=\"comment\">*/</span>", 
"", 
"<span class=\"comment\">/* </span>", 
"<span class=\"comment\">     The 'zlib' compression library provides in-memory compression and</span>", 
"<span class=\"comment\">  decompression functions, including integrity checks of the uncompressed</span>", 
"<span class=\"comment\">  data.  This version of the library supports only one compression method</span>", 
"<span class=\"comment\">  (deflation) but other algorithms will be added later and will have the same</span>", 
"<span class=\"comment\">  stream interface.</span>", 
"<span class=\"comment\"></span>", 
"<span class=\"comment\">     Compression can be done in a single step if the buffers are large</span>", 
"<span class=\"comment\">  enough (for example if an input file is mmap'ed), or can be done by</span>", 
"<span class=\"comment\">  repeated calls of the compression function.  In the latter case, the</span>", 
"<span class=\"comment\">  application must provide more input and/or consume the output</span>", 
"<span class=\"comment\">  (providing more output space) before each call.</span>", 
"<span class=\"comment\"></span>", 
"<span class=\"comment\">     The compressed data format used by default by the in-memory functions is</span>", 
"<span class=\"comment\">  the zlib format, which is a zlib wrapper documented in RFC 1950, wrapped</span>", 
"<span class=\"comment\">  around a deflate stream, which is itself documented in RFC 1951.</span>", 
"<span class=\"comment\"></span>", 
"<span class=\"comment\">     The library also supports reading and writing files in gzip (.gz) format</span>", 
"<span class=\"comment\">  with an interface similar to that of stdio.</span>", 
"<span class=\"comment\"></span>", 
"<span class=\"comment\">     The zlib format was designed to be compact and fast for use in memory</span>", 
"<span class=\"comment\">  and on communications channels.  The gzip format was designed for single-</span>", 
"<span class=\"comment\">  file compression on file systems, has a larger header than zlib to maintain</span>", 
"<span class=\"comment\">  directory information, and uses a different, slower check method than zlib.</span>", 
"<span class=\"comment\"></span>", 
"<span class=\"comment\">     The library does not install any signal handler. The decoder checks</span>", 
"<span class=\"comment\">  the consistency of the compressed data, so the library should never</span>", 
"<span class=\"comment\">  crash even in case of corrupted input.</span>", 
"<span class=\"comment\">*/</span>", 
"", 
"struct <a class=\"id\" href=\"#internal_state\">internal_state</a>;", 
"", 
"typedef struct <a class=\"id\" href=\"#z_stream_s\">z_stream_s</a> {", 
"    const <a class=\"id\" href=\"#Byte\">Byte</a> *<a class=\"id\" href=\"#next_in\">next_in</a>;   <span class=\"comment\">/* next input byte */</span>", 
"    <a class=\"id\" href=\"#uInt\">uInt</a>     <a class=\"id\" href=\"#avail_in\">avail_in</a>;  <span class=\"comment\">/* number of bytes available at next_in */</span>", 
"    <a class=\"id\" href=\"#uLong\">uLong</a>    <a class=\"id\" href=\"#total_in\">total_in</a>;  <span class=\"comment\">/* total nb of input bytes read so far */</span>", 
"", 
"    <a class=\"id\" href=\"#Byte\">Byte</a>    *<a class=\"id\" href=\"#next_out\">next_out</a>;  <span class=\"comment\">/* next output byte should be put there */</span>", 
"    <a class=\"id\" href=\"#uInt\">uInt</a>     <a class=\"id\" href=\"#avail_out\">avail_out</a>; <span class=\"comment\">/* remaining free space at next_out */</span>", 
"    <a class=\"id\" href=\"#uLong\">uLong</a>    <a class=\"id\" href=\"#total_out\">total_out</a>; <span class=\"comment\">/* total nb of bytes output so far */</span>", 
"", 
"    char     *<a class=\"id\" href=\"#msg\">msg</a>;      <span class=\"comment\">/* last error message, NULL if no error */</span>", 
"    struct <a class=\"id\" href=\"#internal_state\">internal_state</a> *<a class=\"id\" href=\"#state\">state</a>; <span class=\"comment\">/* not visible by applications */</span>", 
"", 
"    void     *<a class=\"id\" href=\"#workspace\">workspace</a>; <span class=\"comment\">/* memory allocated for this stream */</span>", 
"", 
"    int     <a class=\"id\" href=\"#data_type\">data_type</a>;  <span class=\"comment\">/* best guess about the data type: ascii or binary */</span>", 
"    <a class=\"id\" href=\"#uLong\">uLong</a>   <a class=\"id\" href=\"#adler\">adler</a>;      <span class=\"comment\">/* adler32 value of the uncompressed data */</span>", 
"    <a class=\"id\" href=\"#uLong\">uLong</a>   <a class=\"id\" href=\"#reserved\">reserved</a>;   <span class=\"comment\">/* reserved for future use */</span>", 
"} <a class=\"id\" href=\"#z_stream\">z_stream</a>;", 
"", 
"typedef <a class=\"id\" href=\"#z_stream\">z_stream</a> *<a class=\"id\" href=\"#z_streamp\">z_streamp</a>;", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\">   The application must update next_in and avail_in when avail_in has</span>", 
"<span class=\"comment\">   dropped to zero. It must update next_out and avail_out when avail_out</span>", 
"<span class=\"comment\">   has dropped to zero. The application must initialize zalloc, zfree and</span>", 
"<span class=\"comment\">   opaque before calling the init function. All other fields are set by the</span>", 
"<span class=\"comment\">   compression library and must not be updated by the application.</span>", 
"<span class=\"comment\"></span>", 
"<span class=\"comment\">   The opaque value provided by the application will be passed as the first</span>", 
"<span class=\"comment\">   parameter for calls of zalloc and zfree. This can be useful for custom</span>", 
"<span class=\"comment\">   memory management. The compression library attaches no meaning to the</span>", 
"<span class=\"comment\">   opaque value.</span>", 
"<span class=\"comment\"></span>", 
"<span class=\"comment\">   zalloc must return NULL if there is not enough memory for the object.</span>", 
"<span class=\"comment\">   If zlib is used in a multi-threaded application, zalloc and zfree must be</span>", 
"<span class=\"comment\">   thread safe.</span>", 
"<span class=\"comment\"></span>", 
"<span class=\"comment\">   On 16-bit systems, the functions zalloc and zfree must be able to allocate</span>", 
"<span class=\"comment\">   exactly 65536 bytes, but will not be required to allocate more than this</span>", 
"<span class=\"comment\">   if the symbol MAXSEG_64K is defined (see zconf.h). WARNING: On MSDOS,</span>", 
"<span class=\"comment\">   pointers returned by zalloc for objects of exactly 65536 bytes *must*</span>", 
"<span class=\"comment\">   have their offset normalized to zero. The default allocation function</span>", 
"<span class=\"comment\">   provided by this library ensures this (see zutil.c). To reduce memory</span>", 
"<span class=\"comment\">   requirements and avoid any allocation of 64K objects, at the expense of</span>", 
"<span class=\"comment\">   compression ratio, compile the library with -DMAX_WBITS=14 (see zconf.h).</span>", 
"<span class=\"comment\"></span>", 
"<span class=\"comment\">   The fields total_in and total_out can be used for statistics or</span>", 
"<span class=\"comment\">   progress reports. After compression, total_in holds the total size of</span>", 
"<span class=\"comment\">   the uncompressed data and may be saved for use in the decompressor</span>", 
"<span class=\"comment\">   (particularly if the decompressor wants to decompress everything in</span>", 
"<span class=\"comment\">   a single step).</span>", 
"<span class=\"comment\">*/</span>", 
"", 
"                        <span class=\"comment\">/* constants */</span>", 
"", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#Z_NO_FLUSH\">Z_NO_FLUSH</a>      0", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#Z_PARTIAL_FLUSH\">Z_PARTIAL_FLUSH</a> 1 <span class=\"comment\">/* will be removed, use Z_SYNC_FLUSH instead */</span>", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#Z_PACKET_FLUSH\">Z_PACKET_FLUSH</a>  2", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#Z_SYNC_FLUSH\">Z_SYNC_FLUSH</a>    3", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#Z_FULL_FLUSH\">Z_FULL_FLUSH</a>    4", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#Z_FINISH\">Z_FINISH</a>        5", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#Z_BLOCK\">Z_BLOCK</a>         6 <span class=\"comment\">/* Only for inflate at present */</span>", 
"<span class=\"comment\">/* Allowed flush values; see deflate() and inflate() below for details */</span>", 
"", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#Z_OK\">Z_OK</a>            0", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#Z_STREAM_END\">Z_STREAM_END</a>    1", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#Z_NEED_DICT\">Z_NEED_DICT</a>     2", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#Z_ERRNO\">Z_ERRNO</a>        (-1)", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#Z_STREAM_ERROR\">Z_STREAM_ERROR</a> (-2)", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#Z_DATA_ERROR\">Z_DATA_ERROR</a>   (-3)", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#Z_MEM_ERROR\">Z_MEM_ERROR</a>    (-4)", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#Z_BUF_ERROR\">Z_BUF_ERROR</a>    (-5)", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#Z_VERSION_ERROR\">Z_VERSION_ERROR</a> (-6)", 
"<span class=\"comment\">/* Return codes for the compression/decompression functions. Negative</span>", 
"<span class=\"comment\"> * values are errors, positive values are used for special but normal events.</span>", 
"<span class=\"comment\"> */</span>", 
"", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#Z_NO_COMPRESSION\">Z_NO_COMPRESSION</a>         0", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#Z_BEST_SPEED\">Z_BEST_SPEED</a>             1", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#Z_BEST_COMPRESSION\">Z_BEST_COMPRESSION</a>       9", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#Z_DEFAULT_COMPRESSION\">Z_DEFAULT_COMPRESSION</a>  (-1)", 
"<span class=\"comment\">/* compression levels */</span>", 
"", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#Z_FILTERED\">Z_FILTERED</a>            1", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#Z_HUFFMAN_ONLY\">Z_HUFFMAN_ONLY</a>        2", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#Z_DEFAULT_STRATEGY\">Z_DEFAULT_STRATEGY</a>    0", 
"<span class=\"comment\">/* compression strategy; see deflateInit2() below for details */</span>", 
"", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#Z_BINARY\">Z_BINARY</a>   0", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#Z_ASCII\">Z_ASCII</a>    1", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#Z_UNKNOWN\">Z_UNKNOWN</a>  2", 
"<span class=\"comment\">/* Possible values of the data_type field */</span>", 
"", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#Z_DEFLATED\">Z_DEFLATED</a>   8", 
"<span class=\"comment\">/* The deflate compression method (the only one supported in this version) */</span>", 
"", 
"                        <span class=\"comment\">/* basic functions */</span>", 
"", 
"extern int <a class=\"id\" href=\"#zlib_deflate_workspacesize\">zlib_deflate_workspacesize</a> (void);", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\">   Returns the number of bytes that needs to be allocated for a per-</span>", 
"<span class=\"comment\">   stream workspace.  A pointer to this number of bytes should be</span>", 
"<span class=\"comment\">   returned in stream-&gt;workspace before calling zlib_deflateInit().</span>", 
"<span class=\"comment\">*/</span>", 
"", 
"<span class=\"comment\">/* </span>", 
"<span class=\"comment\">extern int deflateInit (z_streamp strm, int level);</span>", 
"<span class=\"comment\"></span>", 
"<span class=\"comment\">     Initializes the internal stream state for compression. The fields</span>", 
"<span class=\"comment\">   zalloc, zfree and opaque must be initialized before by the caller.</span>", 
"<span class=\"comment\">   If zalloc and zfree are set to NULL, deflateInit updates them to</span>", 
"<span class=\"comment\">   use default allocation functions.</span>", 
"<span class=\"comment\"></span>", 
"<span class=\"comment\">     The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:</span>", 
"<span class=\"comment\">   1 gives best speed, 9 gives best compression, 0 gives no compression at</span>", 
"<span class=\"comment\">   all (the input data is simply copied a block at a time).</span>", 
"<span class=\"comment\">   Z_DEFAULT_COMPRESSION requests a default compromise between speed and</span>", 
"<span class=\"comment\">   compression (currently equivalent to level 6).</span>", 
"<span class=\"comment\"></span>", 
"<span class=\"comment\">     deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not</span>", 
"<span class=\"comment\">   enough memory, Z_STREAM_ERROR if level is not a valid compression level,</span>", 
"<span class=\"comment\">   Z_VERSION_ERROR if the zlib library version (zlib_version) is incompatible</span>", 
"<span class=\"comment\">   with the version assumed by the caller (ZLIB_VERSION).</span>", 
"<span class=\"comment\">   msg is set to null if there is no error message.  deflateInit does not</span>", 
"<span class=\"comment\">   perform any compression: this will be done by deflate().</span>", 
"<span class=\"comment\">*/</span>", 
"", 
"", 
"extern int <a class=\"id\" href=\"#zlib_deflate\">zlib_deflate</a> (<a class=\"id\" href=\"#z_streamp\">z_streamp</a> <a class=\"id\" href=\"#strm\">strm</a>, int <a class=\"id\" href=\"#flush\">flush</a>);", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\">    deflate compresses as much data as possible, and stops when the input</span>", 
"<span class=\"comment\">  buffer becomes empty or the output buffer becomes full. It may introduce some</span>", 
"<span class=\"comment\">  output latency (reading input without producing any output) except when</span>", 
"<span class=\"comment\">  forced to flush.</span>", 
"<span class=\"comment\"></span>", 
"<span class=\"comment\">    The detailed semantics are as follows. deflate performs one or both of the</span>", 
"<span class=\"comment\">  following actions:</span>", 
"<span class=\"comment\"></span>", 
"<span class=\"comment\">  - Compress more input starting at next_in and update next_in and avail_in</span>", 
"<span class=\"comment\">    accordingly. If not all input can be processed (because there is not</span>", 
"<span class=\"comment\">    enough room in the output buffer), next_in and avail_in are updated and</span>", 
"<span class=\"comment\">    processing will resume at this point for the next call of deflate().</span>", 
"<span class=\"comment\"></span>", 
"<span class=\"comment\">  - Provide more output starting at next_out and update next_out and avail_out</span>", 
"<span class=\"comment\">    accordingly. This action is forced if the parameter flush is non zero.</span>", 
"<span class=\"comment\">    Forcing flush frequently degrades the compression ratio, so this parameter</span>", 
"<span class=\"comment\">    should be set only when necessary (in interactive applications).</span>", 
"<span class=\"comment\">    Some output may be provided even if flush is not set.</span>", 
"<span class=\"comment\"></span>", 
"<span class=\"comment\">  Before the call of deflate(), the application should ensure that at least</span>", 
"<span class=\"comment\">  one of the actions is possible, by providing more input and/or consuming</span>", 
"<span class=\"comment\">  more output, and updating avail_in or avail_out accordingly; avail_out</span>", 
"<span class=\"comment\">  should never be zero before the call. The application can consume the</span>", 
"<span class=\"comment\">  compressed output when it wants, for example when the output buffer is full</span>", 
"<span class=\"comment\">  (avail_out == 0), or after each call of deflate(). If deflate returns Z_OK</span>", 
"<span class=\"comment\">  and with zero avail_out, it must be called again after making room in the</span>", 
"<span class=\"comment\">  output buffer because there might be more output pending.</span>", 
"<span class=\"comment\"></span>", 
"<span class=\"comment\">    If the parameter flush is set to Z_SYNC_FLUSH, all pending output is</span>", 
"<span class=\"comment\">  flushed to the output buffer and the output is aligned on a byte boundary, so</span>", 
"<span class=\"comment\">  that the decompressor can get all input data available so far. (In particular</span>", 
"<span class=\"comment\">  avail_in is zero after the call if enough output space has been provided</span>", 
"<span class=\"comment\">  before the call.)  Flushing may degrade compression for some compression</span>", 
"<span class=\"comment\">  algorithms and so it should be used only when necessary.</span>", 
"<span class=\"comment\"></span>", 
"<span class=\"comment\">    If flush is set to Z_FULL_FLUSH, all output is flushed as with</span>", 
"<span class=\"comment\">  Z_SYNC_FLUSH, and the compression state is reset so that decompression can</span>", 
"<span class=\"comment\">  restart from this point if previous compressed data has been damaged or if</span>", 
"<span class=\"comment\">  random access is desired. Using Z_FULL_FLUSH too often can seriously degrade</span>", 
"<span class=\"comment\">  the compression.</span>", 
"<span class=\"comment\"></span>", 
"<span class=\"comment\">    If deflate returns with avail_out == 0, this function must be called again</span>", 
"<span class=\"comment\">  with the same value of the flush parameter and more output space (updated</span>", 
"<span class=\"comment\">  avail_out), until the flush is complete (deflate returns with non-zero</span>", 
"<span class=\"comment\">  avail_out).</span>", 
"<span class=\"comment\"></span>", 
"<span class=\"comment\">    If the parameter flush is set to Z_FINISH, pending input is processed,</span>", 
"<span class=\"comment\">  pending output is flushed and deflate returns with Z_STREAM_END if there</span>", 
"<span class=\"comment\">  was enough output space; if deflate returns with Z_OK, this function must be</span>", 
"<span class=\"comment\">  called again with Z_FINISH and more output space (updated avail_out) but no</span>", 
"<span class=\"comment\">  more input data, until it returns with Z_STREAM_END or an error. After</span>", 
"<span class=\"comment\">  deflate has returned Z_STREAM_END, the only possible operations on the</span>", 
"<span class=\"comment\">  stream are deflateReset or deflateEnd.</span>", 
"<span class=\"comment\">  </span>", 
"<span class=\"comment\">    Z_FINISH can be used immediately after deflateInit if all the compression</span>", 
"<span class=\"comment\">  is to be done in a single step. In this case, avail_out must be at least</span>", 
"<span class=\"comment\">  0.1% larger than avail_in plus 12 bytes.  If deflate does not return</span>", 
"<span class=\"comment\">  Z_STREAM_END, then it must be called again as described above.</span>", 
"<span class=\"comment\"></span>", 
"<span class=\"comment\">    deflate() sets strm-&gt;adler to the adler32 checksum of all input read</span>", 
"<span class=\"comment\">  so far (that is, total_in bytes).</span>", 
"<span class=\"comment\"></span>", 
"<span class=\"comment\">    deflate() may update data_type if it can make a good guess about</span>", 
"<span class=\"comment\">  the input data type (Z_ASCII or Z_BINARY). In doubt, the data is considered</span>", 
"<span class=\"comment\">  binary. This field is only for information purposes and does not affect</span>", 
"<span class=\"comment\">  the compression algorithm in any manner.</span>", 
"<span class=\"comment\"></span>", 
"<span class=\"comment\">    deflate() returns Z_OK if some progress has been made (more input</span>", 
"<span class=\"comment\">  processed or more output produced), Z_STREAM_END if all input has been</span>", 
"<span class=\"comment\">  consumed and all output has been produced (only when flush is set to</span>", 
"<span class=\"comment\">  Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent (for example</span>", 
"<span class=\"comment\">  if next_in or next_out was NULL), Z_BUF_ERROR if no progress is possible</span>", 
"<span class=\"comment\">  (for example avail_in or avail_out was zero).</span>", 
"<span class=\"comment\">*/</span>", 
"", 
"", 
"extern int <a class=\"id\" href=\"#zlib_deflateEnd\">zlib_deflateEnd</a> (<a class=\"id\" href=\"#z_streamp\">z_streamp</a> <a class=\"id\" href=\"#strm\">strm</a>);", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\">     All dynamically allocated data structures for this stream are freed.</span>", 
"<span class=\"comment\">   This function discards any unprocessed input and does not flush any</span>", 
"<span class=\"comment\">   pending output.</span>", 
"<span class=\"comment\"></span>", 
"<span class=\"comment\">     deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the</span>", 
"<span class=\"comment\">   stream state was inconsistent, Z_DATA_ERROR if the stream was freed</span>", 
"<span class=\"comment\">   prematurely (some input or output was discarded). In the error case,</span>", 
"<span class=\"comment\">   msg may be set but then points to a static string (which must not be</span>", 
"<span class=\"comment\">   deallocated).</span>", 
"<span class=\"comment\">*/</span>", 
"", 
"", 
"extern int <a class=\"id\" href=\"#zlib_inflate_workspacesize\">zlib_inflate_workspacesize</a> (void);", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\">   Returns the number of bytes that needs to be allocated for a per-</span>", 
"<span class=\"comment\">   stream workspace.  A pointer to this number of bytes should be</span>", 
"<span class=\"comment\">   returned in stream-&gt;workspace before calling zlib_inflateInit().</span>", 
"<span class=\"comment\">*/</span>", 
"", 
"<span class=\"comment\">/* </span>", 
"<span class=\"comment\">extern int zlib_inflateInit (z_streamp strm);</span>", 
"<span class=\"comment\"></span>", 
"<span class=\"comment\">     Initializes the internal stream state for decompression. The fields</span>", 
"<span class=\"comment\">   next_in, avail_in, and workspace must be initialized before by</span>", 
"<span class=\"comment\">   the caller. If next_in is not NULL and avail_in is large enough (the exact</span>", 
"<span class=\"comment\">   value depends on the compression method), inflateInit determines the</span>", 
"<span class=\"comment\">   compression method from the zlib header and allocates all data structures</span>", 
"<span class=\"comment\">   accordingly; otherwise the allocation will be deferred to the first call of</span>", 
"<span class=\"comment\">   inflate.  If zalloc and zfree are set to NULL, inflateInit updates them to</span>", 
"<span class=\"comment\">   use default allocation functions.</span>", 
"<span class=\"comment\"></span>", 
"<span class=\"comment\">     inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough</span>", 
"<span class=\"comment\">   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the</span>", 
"<span class=\"comment\">   version assumed by the caller.  msg is set to null if there is no error</span>", 
"<span class=\"comment\">   message. inflateInit does not perform any decompression apart from reading</span>", 
"<span class=\"comment\">   the zlib header if present: this will be done by inflate().  (So next_in and</span>", 
"<span class=\"comment\">   avail_in may be modified, but next_out and avail_out are unchanged.)</span>", 
"<span class=\"comment\">*/</span>", 
"", 
"", 
"extern int <a class=\"id\" href=\"#zlib_inflate\">zlib_inflate</a> (<a class=\"id\" href=\"#z_streamp\">z_streamp</a> <a class=\"id\" href=\"#strm\">strm</a>, int <a class=\"id\" href=\"#flush\">flush</a>);", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\">    inflate decompresses as much data as possible, and stops when the input</span>", 
"<span class=\"comment\">  buffer becomes empty or the output buffer becomes full. It may introduce</span>", 
"<span class=\"comment\">  some output latency (reading input without producing any output) except when</span>", 
"<span class=\"comment\">  forced to flush.</span>", 
"<span class=\"comment\"></span>", 
"<span class=\"comment\">  The detailed semantics are as follows. inflate performs one or both of the</span>", 
"<span class=\"comment\">  following actions:</span>", 
"<span class=\"comment\"></span>", 
"<span class=\"comment\">  - Decompress more input starting at next_in and update next_in and avail_in</span>", 
"<span class=\"comment\">    accordingly. If not all input can be processed (because there is not</span>", 
"<span class=\"comment\">    enough room in the output buffer), next_in is updated and processing</span>", 
"<span class=\"comment\">    will resume at this point for the next call of inflate().</span>", 
"<span class=\"comment\"></span>", 
"<span class=\"comment\">  - Provide more output starting at next_out and update next_out and avail_out</span>", 
"<span class=\"comment\">    accordingly.  inflate() provides as much output as possible, until there</span>", 
"<span class=\"comment\">    is no more input data or no more space in the output buffer (see below</span>", 
"<span class=\"comment\">    about the flush parameter).</span>", 
"<span class=\"comment\"></span>", 
"<span class=\"comment\">  Before the call of inflate(), the application should ensure that at least</span>", 
"<span class=\"comment\">  one of the actions is possible, by providing more input and/or consuming</span>", 
"<span class=\"comment\">  more output, and updating the next_* and avail_* values accordingly.</span>", 
"<span class=\"comment\">  The application can consume the uncompressed output when it wants, for</span>", 
"<span class=\"comment\">  example when the output buffer is full (avail_out == 0), or after each</span>", 
"<span class=\"comment\">  call of inflate(). If inflate returns Z_OK and with zero avail_out, it</span>", 
"<span class=\"comment\">  must be called again after making room in the output buffer because there</span>", 
"<span class=\"comment\">  might be more output pending.</span>", 
"<span class=\"comment\"></span>", 
"<span class=\"comment\">    The flush parameter of inflate() can be Z_NO_FLUSH, Z_SYNC_FLUSH,</span>", 
"<span class=\"comment\">  Z_FINISH, or Z_BLOCK. Z_SYNC_FLUSH requests that inflate() flush as much</span>", 
"<span class=\"comment\">  output as possible to the output buffer. Z_BLOCK requests that inflate() stop</span>", 
"<span class=\"comment\">  if and when it gets to the next deflate block boundary. When decoding the</span>", 
"<span class=\"comment\">  zlib or gzip format, this will cause inflate() to return immediately after</span>", 
"<span class=\"comment\">  the header and before the first block. When doing a raw inflate, inflate()</span>", 
"<span class=\"comment\">  will go ahead and process the first block, and will return when it gets to</span>", 
"<span class=\"comment\">  the end of that block, or when it runs out of data.</span>", 
"<span class=\"comment\"></span>", 
"<span class=\"comment\">    The Z_BLOCK option assists in appending to or combining deflate streams.</span>", 
"<span class=\"comment\">  Also to assist in this, on return inflate() will set strm-&gt;data_type to the</span>", 
"<span class=\"comment\">  number of unused bits in the last byte taken from strm-&gt;next_in, plus 64</span>", 
"<span class=\"comment\">  if inflate() is currently decoding the last block in the deflate stream,</span>", 
"<span class=\"comment\">  plus 128 if inflate() returned immediately after decoding an end-of-block</span>", 
"<span class=\"comment\">  code or decoding the complete header up to just before the first byte of the</span>", 
"<span class=\"comment\">  deflate stream. The end-of-block will not be indicated until all of the</span>", 
"<span class=\"comment\">  uncompressed data from that block has been written to strm-&gt;next_out.  The</span>", 
"<span class=\"comment\">  number of unused bits may in general be greater than seven, except when</span>", 
"<span class=\"comment\">  bit 7 of data_type is set, in which case the number of unused bits will be</span>", 
"<span class=\"comment\">  less than eight.</span>", 
"<span class=\"comment\"></span>", 
"<span class=\"comment\">    inflate() should normally be called until it returns Z_STREAM_END or an</span>", 
"<span class=\"comment\">  error. However if all decompression is to be performed in a single step</span>", 
"<span class=\"comment\">  (a single call of inflate), the parameter flush should be set to</span>", 
"<span class=\"comment\">  Z_FINISH. In this case all pending input is processed and all pending</span>", 
"<span class=\"comment\">  output is flushed; avail_out must be large enough to hold all the</span>", 
"<span class=\"comment\">  uncompressed data. (The size of the uncompressed data may have been saved</span>", 
"<span class=\"comment\">  by the compressor for this purpose.) The next operation on this stream must</span>", 
"<span class=\"comment\">  be inflateEnd to deallocate the decompression state. The use of Z_FINISH</span>", 
"<span class=\"comment\">  is never required, but can be used to inform inflate that a faster approach</span>", 
"<span class=\"comment\">  may be used for the single inflate() call.</span>", 
"<span class=\"comment\"></span>", 
"<span class=\"comment\">     In this implementation, inflate() always flushes as much output as</span>", 
"<span class=\"comment\">  possible to the output buffer, and always uses the faster approach on the</span>", 
"<span class=\"comment\">  first call. So the only effect of the flush parameter in this implementation</span>", 
"<span class=\"comment\">  is on the return value of inflate(), as noted below, or when it returns early</span>", 
"<span class=\"comment\">  because Z_BLOCK is used.</span>", 
"<span class=\"comment\"></span>", 
"<span class=\"comment\">     If a preset dictionary is needed after this call (see inflateSetDictionary</span>", 
"<span class=\"comment\">  below), inflate sets strm-&gt;adler to the adler32 checksum of the dictionary</span>", 
"<span class=\"comment\">  chosen by the compressor and returns Z_NEED_DICT; otherwise it sets</span>", 
"<span class=\"comment\">  strm-&gt;adler to the adler32 checksum of all output produced so far (that is,</span>", 
"<span class=\"comment\">  total_out bytes) and returns Z_OK, Z_STREAM_END or an error code as described</span>", 
"<span class=\"comment\">  below. At the end of the stream, inflate() checks that its computed adler32</span>", 
"<span class=\"comment\">  checksum is equal to that saved by the compressor and returns Z_STREAM_END</span>", 
"<span class=\"comment\">  only if the checksum is correct.</span>", 
"<span class=\"comment\"></span>", 
"<span class=\"comment\">    inflate() will decompress and check either zlib-wrapped or gzip-wrapped</span>", 
"<span class=\"comment\">  deflate data.  The header type is detected automatically.  Any information</span>", 
"<span class=\"comment\">  contained in the gzip header is not retained, so applications that need that</span>", 
"<span class=\"comment\">  information should instead use raw inflate, see inflateInit2() below, or</span>", 
"<span class=\"comment\">  inflateBack() and perform their own processing of the gzip header and</span>", 
"<span class=\"comment\">  trailer.</span>", 
"<span class=\"comment\"></span>", 
"<span class=\"comment\">    inflate() returns Z_OK if some progress has been made (more input processed</span>", 
"<span class=\"comment\">  or more output produced), Z_STREAM_END if the end of the compressed data has</span>", 
"<span class=\"comment\">  been reached and all uncompressed output has been produced, Z_NEED_DICT if a</span>", 
"<span class=\"comment\">  preset dictionary is needed at this point, Z_DATA_ERROR if the input data was</span>", 
"<span class=\"comment\">  corrupted (input stream not conforming to the zlib format or incorrect check</span>", 
"<span class=\"comment\">  value), Z_STREAM_ERROR if the stream structure was inconsistent (for example</span>", 
"<span class=\"comment\">  if next_in or next_out was NULL), Z_MEM_ERROR if there was not enough memory,</span>", 
"<span class=\"comment\">  Z_BUF_ERROR if no progress is possible or if there was not enough room in the</span>", 
"<span class=\"comment\">  output buffer when Z_FINISH is used. Note that Z_BUF_ERROR is not fatal, and</span>", 
"<span class=\"comment\">  inflate() can be called again with more input and more output space to</span>", 
"<span class=\"comment\">  continue decompressing. If Z_DATA_ERROR is returned, the application may then</span>", 
"<span class=\"comment\">  call inflateSync() to look for a good compression block if a partial recovery</span>", 
"<span class=\"comment\">  of the data is desired.</span>", 
"<span class=\"comment\">*/</span>", 
"", 
"", 
"extern int <a class=\"id\" href=\"#zlib_inflateEnd\">zlib_inflateEnd</a> (<a class=\"id\" href=\"#z_streamp\">z_streamp</a> <a class=\"id\" href=\"#strm\">strm</a>);", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\">     All dynamically allocated data structures for this stream are freed.</span>", 
"<span class=\"comment\">   This function discards any unprocessed input and does not flush any</span>", 
"<span class=\"comment\">   pending output.</span>", 
"<span class=\"comment\"></span>", 
"<span class=\"comment\">     inflateEnd returns Z_OK if success, Z_STREAM_ERROR if the stream state</span>", 
"<span class=\"comment\">   was inconsistent. In the error case, msg may be set but then points to a</span>", 
"<span class=\"comment\">   static string (which must not be deallocated).</span>", 
"<span class=\"comment\">*/</span>", 
"", 
"                        <span class=\"comment\">/* Advanced functions */</span>", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\">    The following functions are needed only in some special applications.</span>", 
"<span class=\"comment\">*/</span>", 
"", 
"<span class=\"comment\">/*   </span>", 
"<span class=\"comment\">extern int deflateInit2 (z_streamp strm,</span>", 
"<span class=\"comment\">                                     int  level,</span>", 
"<span class=\"comment\">                                     int  method,</span>", 
"<span class=\"comment\">                                     int  windowBits,</span>", 
"<span class=\"comment\">                                     int  memLevel,</span>", 
"<span class=\"comment\">                                     int  strategy);</span>", 
"<span class=\"comment\"></span>", 
"<span class=\"comment\">     This is another version of deflateInit with more compression options. The</span>", 
"<span class=\"comment\">   fields next_in, zalloc, zfree and opaque must be initialized before by</span>", 
"<span class=\"comment\">   the caller.</span>", 
"<span class=\"comment\"></span>", 
"<span class=\"comment\">     The method parameter is the compression method. It must be Z_DEFLATED in</span>", 
"<span class=\"comment\">   this version of the library.</span>", 
"<span class=\"comment\"></span>", 
"<span class=\"comment\">     The windowBits parameter is the base two logarithm of the window size</span>", 
"<span class=\"comment\">   (the size of the history buffer).  It should be in the range 8..15 for this</span>", 
"<span class=\"comment\">   version of the library. Larger values of this parameter result in better</span>", 
"<span class=\"comment\">   compression at the expense of memory usage. The default value is 15 if</span>", 
"<span class=\"comment\">   deflateInit is used instead.</span>", 
"<span class=\"comment\"></span>", 
"<span class=\"comment\">     The memLevel parameter specifies how much memory should be allocated</span>", 
"<span class=\"comment\">   for the internal compression state. memLevel=1 uses minimum memory but</span>", 
"<span class=\"comment\">   is slow and reduces compression ratio; memLevel=9 uses maximum memory</span>", 
"<span class=\"comment\">   for optimal speed. The default value is 8. See zconf.h for total memory</span>", 
"<span class=\"comment\">   usage as a function of windowBits and memLevel.</span>", 
"<span class=\"comment\"></span>", 
"<span class=\"comment\">     The strategy parameter is used to tune the compression algorithm. Use the</span>", 
"<span class=\"comment\">   value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a</span>", 
"<span class=\"comment\">   filter (or predictor), or Z_HUFFMAN_ONLY to force Huffman encoding only (no</span>", 
"<span class=\"comment\">   string match).  Filtered data consists mostly of small values with a</span>", 
"<span class=\"comment\">   somewhat random distribution. In this case, the compression algorithm is</span>", 
"<span class=\"comment\">   tuned to compress them better. The effect of Z_FILTERED is to force more</span>", 
"<span class=\"comment\">   Huffman coding and less string matching; it is somewhat intermediate</span>", 
"<span class=\"comment\">   between Z_DEFAULT and Z_HUFFMAN_ONLY. The strategy parameter only affects</span>", 
"<span class=\"comment\">   the compression ratio but not the correctness of the compressed output even</span>", 
"<span class=\"comment\">   if it is not set appropriately.</span>", 
"<span class=\"comment\"></span>", 
"<span class=\"comment\">      deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough</span>", 
"<span class=\"comment\">   memory, Z_STREAM_ERROR if a parameter is invalid (such as an invalid</span>", 
"<span class=\"comment\">   method). msg is set to null if there is no error message.  deflateInit2 does</span>", 
"<span class=\"comment\">   not perform any compression: this will be done by deflate().</span>", 
"<span class=\"comment\">*/</span>", 
"                            ", 
"#if 0", 
"extern int <a class=\"id\" href=\"#zlib_deflateSetDictionary\">zlib_deflateSetDictionary</a> (<a class=\"id\" href=\"#z_streamp\">z_streamp</a> <a class=\"id\" href=\"#strm\">strm</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>     const <a class=\"id\" href=\"#Byte\">Byte</a> *<a class=\"id\" href=\"#dictionary\">dictionary</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>     <a class=\"id\" href=\"#uInt\">uInt</a>  <a class=\"id\" href=\"#dictLength\">dictLength</a>);", 
"#<a class=\"id\" href=\"#endif\">endif</a>", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\">     Initializes the compression dictionary from the given byte sequence</span>", 
"<span class=\"comment\">   without producing any compressed output. This function must be called</span>", 
"<span class=\"comment\">   immediately after deflateInit, deflateInit2 or deflateReset, before any</span>", 
"<span class=\"comment\">   call of deflate. The compressor and decompressor must use exactly the same</span>", 
"<span class=\"comment\">   dictionary (see inflateSetDictionary).</span>", 
"<span class=\"comment\"></span>", 
"<span class=\"comment\">     The dictionary should consist of strings (byte sequences) that are likely</span>", 
"<span class=\"comment\">   to be encountered later in the data to be compressed, with the most commonly</span>", 
"<span class=\"comment\">   used strings preferably put towards the end of the dictionary. Using a</span>", 
"<span class=\"comment\">   dictionary is most useful when the data to be compressed is short and can be</span>", 
"<span class=\"comment\">   predicted with good accuracy; the data can then be compressed better than</span>", 
"<span class=\"comment\">   with the default empty dictionary.</span>", 
"<span class=\"comment\"></span>", 
"<span class=\"comment\">     Depending on the size of the compression data structures selected by</span>", 
"<span class=\"comment\">   deflateInit or deflateInit2, a part of the dictionary may in effect be</span>", 
"<span class=\"comment\">   discarded, for example if the dictionary is larger than the window size in</span>", 
"<span class=\"comment\">   deflate or deflate2. Thus the strings most likely to be useful should be</span>", 
"<span class=\"comment\">   put at the end of the dictionary, not at the front.</span>", 
"<span class=\"comment\"></span>", 
"<span class=\"comment\">     Upon return of this function, strm-&gt;adler is set to the Adler32 value</span>", 
"<span class=\"comment\">   of the dictionary; the decompressor may later use this value to determine</span>", 
"<span class=\"comment\">   which dictionary has been used by the compressor. (The Adler32 value</span>", 
"<span class=\"comment\">   applies to the whole dictionary even if only a subset of the dictionary is</span>", 
"<span class=\"comment\">   actually used by the compressor.)</span>", 
"<span class=\"comment\"></span>", 
"<span class=\"comment\">     deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a</span>", 
"<span class=\"comment\">   parameter is invalid (such as NULL dictionary) or the stream state is</span>", 
"<span class=\"comment\">   inconsistent (for example if deflate has already been called for this stream</span>", 
"<span class=\"comment\">   or if the compression method is bsort). deflateSetDictionary does not</span>", 
"<span class=\"comment\">   perform any compression: this will be done by deflate().</span>", 
"<span class=\"comment\">*/</span>", 
"", 
"#if 0", 
"extern int <a class=\"id\" href=\"#zlib_deflateCopy\">zlib_deflateCopy</a> (<a class=\"id\" href=\"#z_streamp\">z_streamp</a> <a class=\"id\" href=\"#dest\">dest</a>, <a class=\"id\" href=\"#z_streamp\">z_streamp</a> <a class=\"id\" href=\"#source\">source</a>);", 
"#<a class=\"id\" href=\"#endif\">endif</a>", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\">     Sets the destination stream as a complete copy of the source stream.</span>", 
"<span class=\"comment\"></span>", 
"<span class=\"comment\">     This function can be useful when several compression strategies will be</span>", 
"<span class=\"comment\">   tried, for example when there are several ways of pre-processing the input</span>", 
"<span class=\"comment\">   data with a filter. The streams that will be discarded should then be freed</span>", 
"<span class=\"comment\">   by calling deflateEnd.  Note that deflateCopy duplicates the internal</span>", 
"<span class=\"comment\">   compression state which can be quite large, so this strategy is slow and</span>", 
"<span class=\"comment\">   can consume lots of memory.</span>", 
"<span class=\"comment\"></span>", 
"<span class=\"comment\">     deflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not</span>", 
"<span class=\"comment\">   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent</span>", 
"<span class=\"comment\">   (such as zalloc being NULL). msg is left unchanged in both source and</span>", 
"<span class=\"comment\">   destination.</span>", 
"<span class=\"comment\">*/</span>", 
"", 
"extern int <a class=\"id\" href=\"#zlib_deflateReset\">zlib_deflateReset</a> (<a class=\"id\" href=\"#z_streamp\">z_streamp</a> <a class=\"id\" href=\"#strm\">strm</a>);", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\">     This function is equivalent to deflateEnd followed by deflateInit,</span>", 
"<span class=\"comment\">   but does not free and reallocate all the internal compression state.</span>", 
"<span class=\"comment\">   The stream will keep the same compression level and any other attributes</span>", 
"<span class=\"comment\">   that may have been set by deflateInit2.</span>", 
"<span class=\"comment\"></span>", 
"<span class=\"comment\">      deflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source</span>", 
"<span class=\"comment\">   stream state was inconsistent (such as zalloc or state being NULL).</span>", 
"<span class=\"comment\">*/</span>", 
"", 
"static <a class=\"id\" href=\"#inline\">inline</a> unsigned long <a class=\"id\" href=\"#deflateBound\">deflateBound</a>(unsigned long <a class=\"id\" href=\"#s\">s</a>)", 
"{", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#s\">s</a> + ((<a class=\"id\" href=\"#s\">s</a> + 7) >> 3) + ((<a class=\"id\" href=\"#s\">s</a> + 63) >> 6) + 11;", 
"}", 
"", 
"#if 0", 
"extern int <a class=\"id\" href=\"#zlib_deflateParams\">zlib_deflateParams</a> (<a class=\"id\" href=\"#z_streamp\">z_streamp</a> <a class=\"id\" href=\"#strm\">strm</a>, int <a class=\"id\" href=\"#level\">level</a>, int <a class=\"id\" href=\"#strategy\">strategy</a>);", 
"#<a class=\"id\" href=\"#endif\">endif</a>", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\">     Dynamically update the compression level and compression strategy.  The</span>", 
"<span class=\"comment\">   interpretation of level and strategy is as in deflateInit2.  This can be</span>", 
"<span class=\"comment\">   used to switch between compression and straight copy of the input data, or</span>", 
"<span class=\"comment\">   to switch to a different kind of input data requiring a different</span>", 
"<span class=\"comment\">   strategy. If the compression level is changed, the input available so far</span>", 
"<span class=\"comment\">   is compressed with the old level (and may be flushed); the new level will</span>", 
"<span class=\"comment\">   take effect only at the next call of deflate().</span>", 
"<span class=\"comment\"></span>", 
"<span class=\"comment\">     Before the call of deflateParams, the stream state must be set as for</span>", 
"<span class=\"comment\">   a call of deflate(), since the currently available input may have to</span>", 
"<span class=\"comment\">   be compressed and flushed. In particular, strm-&gt;avail_out must be non-zero.</span>", 
"<span class=\"comment\"></span>", 
"<span class=\"comment\">     deflateParams returns Z_OK if success, Z_STREAM_ERROR if the source</span>", 
"<span class=\"comment\">   stream state was inconsistent or if a parameter was invalid, Z_BUF_ERROR</span>", 
"<span class=\"comment\">   if strm-&gt;avail_out was zero.</span>", 
"<span class=\"comment\">*/</span>", 
"", 
"<span class=\"comment\">/*   </span>", 
"<span class=\"comment\">extern int inflateInit2 (z_streamp strm, int  windowBits);</span>", 
"<span class=\"comment\"></span>", 
"<span class=\"comment\">     This is another version of inflateInit with an extra parameter. The</span>", 
"<span class=\"comment\">   fields next_in, avail_in, zalloc, zfree and opaque must be initialized</span>", 
"<span class=\"comment\">   before by the caller.</span>", 
"<span class=\"comment\"></span>", 
"<span class=\"comment\">     The windowBits parameter is the base two logarithm of the maximum window</span>", 
"<span class=\"comment\">   size (the size of the history buffer).  It should be in the range 8..15 for</span>", 
"<span class=\"comment\">   this version of the library. The default value is 15 if inflateInit is used</span>", 
"<span class=\"comment\">   instead. windowBits must be greater than or equal to the windowBits value</span>", 
"<span class=\"comment\">   provided to deflateInit2() while compressing, or it must be equal to 15 if</span>", 
"<span class=\"comment\">   deflateInit2() was not used. If a compressed stream with a larger window</span>", 
"<span class=\"comment\">   size is given as input, inflate() will return with the error code</span>", 
"<span class=\"comment\">   Z_DATA_ERROR instead of trying to allocate a larger window.</span>", 
"<span class=\"comment\"></span>", 
"<span class=\"comment\">     windowBits can also be -8..-15 for raw inflate. In this case, -windowBits</span>", 
"<span class=\"comment\">   determines the window size. inflate() will then process raw deflate data,</span>", 
"<span class=\"comment\">   not looking for a zlib or gzip header, not generating a check value, and not</span>", 
"<span class=\"comment\">   looking for any check values for comparison at the end of the stream. This</span>", 
"<span class=\"comment\">   is for use with other formats that use the deflate compressed data format</span>", 
"<span class=\"comment\">   such as zip.  Those formats provide their own check values. If a custom</span>", 
"<span class=\"comment\">   format is developed using the raw deflate format for compressed data, it is</span>", 
"<span class=\"comment\">   recommended that a check value such as an adler32 or a crc32 be applied to</span>", 
"<span class=\"comment\">   the uncompressed data as is done in the zlib, gzip, and zip formats.  For</span>", 
"<span class=\"comment\">   most applications, the zlib format should be used as is. Note that comments</span>", 
"<span class=\"comment\">   above on the use in deflateInit2() applies to the magnitude of windowBits.</span>", 
"<span class=\"comment\"></span>", 
"<span class=\"comment\">     windowBits can also be greater than 15 for optional gzip decoding. Add</span>", 
"<span class=\"comment\">   32 to windowBits to enable zlib and gzip decoding with automatic header</span>", 
"<span class=\"comment\">   detection, or add 16 to decode only the gzip format (the zlib format will</span>", 
"<span class=\"comment\">   return a Z_DATA_ERROR).  If a gzip stream is being decoded, strm-&gt;adler is</span>", 
"<span class=\"comment\">   a crc32 instead of an adler32.</span>", 
"<span class=\"comment\"></span>", 
"<span class=\"comment\">     inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough</span>", 
"<span class=\"comment\">   memory, Z_STREAM_ERROR if a parameter is invalid (such as a null strm). msg</span>", 
"<span class=\"comment\">   is set to null if there is no error message.  inflateInit2 does not perform</span>", 
"<span class=\"comment\">   any decompression apart from reading the zlib header if present: this will</span>", 
"<span class=\"comment\">   be done by inflate(). (So next_in and avail_in may be modified, but next_out</span>", 
"<span class=\"comment\">   and avail_out are unchanged.)</span>", 
"<span class=\"comment\">*/</span>", 
"", 
"extern int <a class=\"id\" href=\"#zlib_inflateSetDictionary\">zlib_inflateSetDictionary</a> (<a class=\"id\" href=\"#z_streamp\">z_streamp</a> <a class=\"id\" href=\"#strm\">strm</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>     const <a class=\"id\" href=\"#Byte\">Byte</a> *<a class=\"id\" href=\"#dictionary\">dictionary</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>     <a class=\"id\" href=\"#uInt\">uInt</a>  <a class=\"id\" href=\"#dictLength\">dictLength</a>);", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\">     Initializes the decompression dictionary from the given uncompressed byte</span>", 
"<span class=\"comment\">   sequence. This function must be called immediately after a call of inflate,</span>", 
"<span class=\"comment\">   if that call returned Z_NEED_DICT. The dictionary chosen by the compressor</span>", 
"<span class=\"comment\">   can be determined from the adler32 value returned by that call of inflate.</span>", 
"<span class=\"comment\">   The compressor and decompressor must use exactly the same dictionary (see</span>", 
"<span class=\"comment\">   deflateSetDictionary).  For raw inflate, this function can be called</span>", 
"<span class=\"comment\">   immediately after inflateInit2() or inflateReset() and before any call of</span>", 
"<span class=\"comment\">   inflate() to set the dictionary.  The application must insure that the</span>", 
"<span class=\"comment\">   dictionary that was used for compression is provided.</span>", 
"<span class=\"comment\"></span>", 
"<span class=\"comment\">     inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a</span>", 
"<span class=\"comment\">   parameter is invalid (such as NULL dictionary) or the stream state is</span>", 
"<span class=\"comment\">   inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the</span>", 
"<span class=\"comment\">   expected one (incorrect adler32 value). inflateSetDictionary does not</span>", 
"<span class=\"comment\">   perform any decompression: this will be done by subsequent calls of</span>", 
"<span class=\"comment\">   inflate().</span>", 
"<span class=\"comment\">*/</span>", 
"", 
"#if 0", 
"extern int <a class=\"id\" href=\"#zlib_inflateSync\">zlib_inflateSync</a> (<a class=\"id\" href=\"#z_streamp\">z_streamp</a> <a class=\"id\" href=\"#strm\">strm</a>);", 
"#<a class=\"id\" href=\"#endif\">endif</a>", 
"<span class=\"comment\">/* </span>", 
"<span class=\"comment\">    Skips invalid compressed data until a full flush point (see above the</span>", 
"<span class=\"comment\">  description of deflate with Z_FULL_FLUSH) can be found, or until all</span>", 
"<span class=\"comment\">  available input is skipped. No output is provided.</span>", 
"<span class=\"comment\"></span>", 
"<span class=\"comment\">    inflateSync returns Z_OK if a full flush point has been found, Z_BUF_ERROR</span>", 
"<span class=\"comment\">  if no more input was provided, Z_DATA_ERROR if no flush point has been found,</span>", 
"<span class=\"comment\">  or Z_STREAM_ERROR if the stream structure was inconsistent. In the success</span>", 
"<span class=\"comment\">  case, the application may save the current current value of total_in which</span>", 
"<span class=\"comment\">  indicates where valid compressed data was found. In the error case, the</span>", 
"<span class=\"comment\">  application may repeatedly call inflateSync, providing more input each time,</span>", 
"<span class=\"comment\">  until success or end of the input data.</span>", 
"<span class=\"comment\">*/</span>", 
"", 
"extern int <a class=\"id\" href=\"#zlib_inflateReset\">zlib_inflateReset</a> (<a class=\"id\" href=\"#z_streamp\">z_streamp</a> <a class=\"id\" href=\"#strm\">strm</a>);", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\">     This function is equivalent to inflateEnd followed by inflateInit,</span>", 
"<span class=\"comment\">   but does not free and reallocate all the internal decompression state.</span>", 
"<span class=\"comment\">   The stream will keep attributes that may have been set by inflateInit2.</span>", 
"<span class=\"comment\"></span>", 
"<span class=\"comment\">      inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source</span>", 
"<span class=\"comment\">   stream state was inconsistent (such as zalloc or state being NULL).</span>", 
"<span class=\"comment\">*/</span>", 
"", 
"extern int <a class=\"id\" href=\"#zlib_inflateIncomp\">zlib_inflateIncomp</a> (<a class=\"id\" href=\"#z_stream\">z_stream</a> *<a class=\"id\" href=\"#strm\">strm</a>);", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\">     This function adds the data at next_in (avail_in bytes) to the output</span>", 
"<span class=\"comment\">   history without performing any output.  There must be no pending output,</span>", 
"<span class=\"comment\">   and the decompressor must be expecting to see the start of a block.</span>", 
"<span class=\"comment\">   Calling this function is equivalent to decompressing a stored block</span>", 
"<span class=\"comment\">   containing the data at next_in (except that the data is not output).</span>", 
"<span class=\"comment\">*/</span>", 
"", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#zlib_deflateInit\">zlib_deflateInit</a>(<a class=\"id\" href=\"#strm\">strm</a>, <a class=\"id\" href=\"#level\">level</a>) \\", 
"<span class=\"ts\"/><a class=\"id\" href=\"#zlib_deflateInit2\">zlib_deflateInit2</a>((<a class=\"id\" href=\"#strm\">strm</a>), (<a class=\"id\" href=\"#level\">level</a>), <a class=\"id\" href=\"#Z_DEFLATED\">Z_DEFLATED</a>, <a class=\"id\" href=\"#MAX_WBITS\">MAX_WBITS</a>, \\", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>      <a class=\"id\" href=\"#DEF_MEM_LEVEL\">DEF_MEM_LEVEL</a>, <a class=\"id\" href=\"#Z_DEFAULT_STRATEGY\">Z_DEFAULT_STRATEGY</a>)", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#zlib_inflateInit\">zlib_inflateInit</a>(<a class=\"id\" href=\"#strm\">strm</a>) \\", 
"<span class=\"ts\"/><a class=\"id\" href=\"#zlib_inflateInit2\">zlib_inflateInit2</a>((<a class=\"id\" href=\"#strm\">strm</a>), <a class=\"id\" href=\"#DEF_WBITS\">DEF_WBITS</a>)", 
"", 
"extern int <a class=\"id\" href=\"#zlib_deflateInit2\">zlib_deflateInit2</a>(<a class=\"id\" href=\"#z_streamp\">z_streamp</a> <a class=\"id\" href=\"#strm\">strm</a>, int  <a class=\"id\" href=\"#level\">level</a>, int  <a class=\"id\" href=\"#method\">method</a>,", 
"                                      int <a class=\"id\" href=\"#windowBits\">windowBits</a>, int <a class=\"id\" href=\"#memLevel\">memLevel</a>,", 
"                                      int <a class=\"id\" href=\"#strategy\">strategy</a>);", 
"extern int <a class=\"id\" href=\"#zlib_inflateInit2\">zlib_inflateInit2</a>(<a class=\"id\" href=\"#z_streamp\">z_streamp</a> <a class=\"id\" href=\"#strm\">strm</a>, int  <a class=\"id\" href=\"#windowBits\">windowBits</a>);", 
"", 
"#if !<a class=\"id\" href=\"#defined\">defined</a>(<a class=\"id\" href=\"#_Z_UTIL_H\">_Z_UTIL_H</a>) && !<a class=\"id\" href=\"#defined\">defined</a>(<a class=\"id\" href=\"#NO_DUMMY_DECL\">NO_DUMMY_DECL</a>)", 
"    struct <a class=\"id\" href=\"#internal_state\">internal_state</a> {int <a class=\"id\" href=\"#dummy\">dummy</a>;}; <span class=\"comment\">/* hack for buggy compilers */</span>", 
"#<a class=\"id\" href=\"#endif\">endif</a>", 
"", 
"<span class=\"comment\">/* Utility function: initialize zlib, unpack binary blob, clean up zlib,</span>", 
"<span class=\"comment\"> * return len or negative error code. */</span>", 
"extern int <a class=\"id\" href=\"#zlib_inflate_blob\">zlib_inflate_blob</a>(void *<a class=\"id\" href=\"#dst\">dst</a>, unsigned <a class=\"id\" href=\"#dst_sz\">dst_sz</a>, const void *<a class=\"id\" href=\"#src\">src</a>, unsigned <a class=\"id\" href=\"#src_sz\">src_sz</a>);", 
"", 
"#<a class=\"id\" href=\"#endif\">endif</a> <span class=\"comment\">/* _ZLIB_H */</span>", 
];
xr_frag_insert('l/55/a4b10b356d38c008d16fd7e0b2d5ba1f754b80.xr', __xr_tmp);
