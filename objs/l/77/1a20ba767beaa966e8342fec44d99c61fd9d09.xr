var __xr_tmp = [
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * lib/kernel_lock.c</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * This is the traditional BKL - big kernel lock. Largely</span>", 
"<span class=\"comment\"> * relegated to obsolescence, but used by various less</span>", 
"<span class=\"comment\"> * important (or lazy) subsystems.</span>", 
"<span class=\"comment\"> */</span>", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#module\">module</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#kallsyms\">kallsyms</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#semaphore\">semaphore</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#smp_lock\">smp_lock</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#CREATE_TRACE_POINTS\">CREATE_TRACE_POINTS</a>", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#trace\">trace</a>/<a class=\"id\" href=\"#events\">events</a>/<a class=\"id\" href=\"#bkl\">bkl</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * The 'big kernel lock'</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * This spinlock is taken and released recursively by lock_kernel()</span>", 
"<span class=\"comment\"> * and unlock_kernel().  It is transparently dropped and reacquired</span>", 
"<span class=\"comment\"> * over schedule().  It is used to protect legacy code that hasn't</span>", 
"<span class=\"comment\"> * been migrated to a proper locking design yet.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Don't use in new code.</span>", 
"<span class=\"comment\"> */</span>", 
"static  <a class=\"id\" href=\"#__cacheline_aligned_in_smp\">__cacheline_aligned_in_smp</a> <a class=\"id\" href=\"#DEFINE_RAW_SPINLOCK\">DEFINE_RAW_SPINLOCK</a>(<a class=\"id\" href=\"#kernel_flag\">kernel_flag</a>);", 
"", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * Acquire/release the underlying lock from the scheduler.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * This is called with preemption disabled, and should</span>", 
"<span class=\"comment\"> * return an error value if it cannot get the lock and</span>", 
"<span class=\"comment\"> * TIF_NEED_RESCHED gets set.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * If it successfully gets the lock, it should increment</span>", 
"<span class=\"comment\"> * the preemption count like any spinlock does.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * (This works on UP too - do_raw_spin_trylock will never</span>", 
"<span class=\"comment\"> * return false in that case)</span>", 
"<span class=\"comment\"> */</span>", 
"int <a class=\"id\" href=\"#__lockfunc\">__lockfunc</a> <a class=\"id\" href=\"#__reacquire_kernel_lock\">__reacquire_kernel_lock</a>(void)", 
"{", 
"<span class=\"ts\"/>while (!<a class=\"id\" href=\"#do_raw_spin_trylock\">do_raw_spin_trylock</a>(&amp;<a class=\"id\" href=\"#kernel_flag\">kernel_flag</a>)) {", 
"<span class=\"ts\"/><span class=\"ts\"/>if (<a class=\"id\" href=\"#need_resched\">need_resched</a>())", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>return -<a class=\"id\" href=\"#EAGAIN\">EAGAIN</a>;", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#cpu_relax\">cpu_relax</a>();", 
"<span class=\"ts\"/>}", 
"<span class=\"ts\"/><a class=\"id\" href=\"#preempt_disable\">preempt_disable</a>();", 
"<span class=\"ts\"/>return 0;", 
"}", 
"", 
"void <a class=\"id\" href=\"#__lockfunc\">__lockfunc</a> <a class=\"id\" href=\"#__release_kernel_lock\">__release_kernel_lock</a>(void)", 
"{", 
"<span class=\"ts\"/><a class=\"id\" href=\"#do_raw_spin_unlock\">do_raw_spin_unlock</a>(&amp;<a class=\"id\" href=\"#kernel_flag\">kernel_flag</a>);", 
"<span class=\"ts\"/><a class=\"id\" href=\"#preempt_enable_no_resched\">preempt_enable_no_resched</a>();", 
"}", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * These are the BKL spinlocks - we try to be polite about preemption.</span>", 
"<span class=\"comment\"> * If SMP is not on (ie UP preemption), this all goes away because the</span>", 
"<span class=\"comment\"> * do_raw_spin_trylock() will always succeed.</span>", 
"<span class=\"comment\"> */</span>", 
"#<a class=\"id\" href=\"#ifdef\">ifdef</a> <a class=\"id\" href=\"#CONFIG_PREEMPT\">CONFIG_PREEMPT</a>", 
"static <a class=\"id\" href=\"#inline\">inline</a> void <a class=\"id\" href=\"#__lock_kernel\">__lock_kernel</a>(void)", 
"{", 
"<span class=\"ts\"/><a class=\"id\" href=\"#preempt_disable\">preempt_disable</a>();", 
"<span class=\"ts\"/>if (<a class=\"id\" href=\"#unlikely\">unlikely</a>(!<a class=\"id\" href=\"#do_raw_spin_trylock\">do_raw_spin_trylock</a>(&amp;<a class=\"id\" href=\"#kernel_flag\">kernel_flag</a>))) {", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/><span class=\"ts\"/> * If preemption was disabled even before this</span>", 
"<span class=\"comment\"><span class=\"ts\"/><span class=\"ts\"/> * was called, there's nothing we can be polite</span>", 
"<span class=\"comment\"><span class=\"ts\"/><span class=\"ts\"/> * about - just spin.</span>", 
"<span class=\"comment\"><span class=\"ts\"/><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/><span class=\"ts\"/>if (<a class=\"id\" href=\"#preempt_count\">preempt_count</a>() &gt; 1) {", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#do_raw_spin_lock\">do_raw_spin_lock</a>(&amp;<a class=\"id\" href=\"#kernel_flag\">kernel_flag</a>);", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>return;", 
"<span class=\"ts\"/><span class=\"ts\"/>}", 
"", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/><span class=\"ts\"/> * Otherwise, let's wait for the kernel lock</span>", 
"<span class=\"comment\"><span class=\"ts\"/><span class=\"ts\"/> * with preemption enabled..</span>", 
"<span class=\"comment\"><span class=\"ts\"/><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/><span class=\"ts\"/>do {", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#preempt_enable\">preempt_enable</a>();", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>while (<a class=\"id\" href=\"#raw_spin_is_locked\">raw_spin_is_locked</a>(&amp;<a class=\"id\" href=\"#kernel_flag\">kernel_flag</a>))", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#cpu_relax\">cpu_relax</a>();", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#preempt_disable\">preempt_disable</a>();", 
"<span class=\"ts\"/><span class=\"ts\"/>} while (!<a class=\"id\" href=\"#do_raw_spin_trylock\">do_raw_spin_trylock</a>(&amp;<a class=\"id\" href=\"#kernel_flag\">kernel_flag</a>));", 
"<span class=\"ts\"/>}", 
"}", 
"", 
"#else", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * Non-preemption case - just get the spinlock</span>", 
"<span class=\"comment\"> */</span>", 
"static <a class=\"id\" href=\"#inline\">inline</a> void <a class=\"id\" href=\"#__lock_kernel\">__lock_kernel</a>(void)", 
"{", 
"<span class=\"ts\"/><a class=\"id\" href=\"#do_raw_spin_lock\">do_raw_spin_lock</a>(&amp;<a class=\"id\" href=\"#kernel_flag\">kernel_flag</a>);", 
"}", 
"#<a class=\"id\" href=\"#endif\">endif</a>", 
"", 
"static <a class=\"id\" href=\"#inline\">inline</a> void <a class=\"id\" href=\"#__unlock_kernel\">__unlock_kernel</a>(void)", 
"{", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * the BKL is not covered by lockdep, so we open-code the</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * unlocking sequence (and thus avoid the dep-chain ops):</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/><a class=\"id\" href=\"#do_raw_spin_unlock\">do_raw_spin_unlock</a>(&amp;<a class=\"id\" href=\"#kernel_flag\">kernel_flag</a>);", 
"<span class=\"ts\"/><a class=\"id\" href=\"#preempt_enable\">preempt_enable</a>();", 
"}", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * Getting the big kernel lock.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * This cannot happen asynchronously, so we only need to</span>", 
"<span class=\"comment\"> * worry about other CPU's.</span>", 
"<span class=\"comment\"> */</span>", 
"void <a class=\"id\" href=\"#__lockfunc\">__lockfunc</a> <a class=\"id\" href=\"#_lock_kernel\">_lock_kernel</a>(const char *<a class=\"id\" href=\"#func\">func</a>, const char *<a class=\"id\" href=\"#file\">file</a>, int <a class=\"id\" href=\"#line\">line</a>)", 
"{", 
"<span class=\"ts\"/>int <a class=\"id\" href=\"#depth\">depth</a> = <a class=\"id\" href=\"#current\">current</a>-><a class=\"id\" href=\"#lock_depth\">lock_depth</a> + 1;", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#trace_lock_kernel\">trace_lock_kernel</a>(<a class=\"id\" href=\"#func\">func</a>, <a class=\"id\" href=\"#file\">file</a>, <a class=\"id\" href=\"#line\">line</a>);", 
"", 
"<span class=\"ts\"/>if (<a class=\"id\" href=\"#likely\">likely</a>(!<a class=\"id\" href=\"#depth\">depth</a>)) {", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#might_sleep\">might_sleep</a>();", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#__lock_kernel\">__lock_kernel</a>();", 
"<span class=\"ts\"/>}", 
"<span class=\"ts\"/><a class=\"id\" href=\"#current\">current</a>-><a class=\"id\" href=\"#lock_depth\">lock_depth</a> = <a class=\"id\" href=\"#depth\">depth</a>;", 
"}", 
"", 
"void <a class=\"id\" href=\"#__lockfunc\">__lockfunc</a> <a class=\"id\" href=\"#_unlock_kernel\">_unlock_kernel</a>(const char *<a class=\"id\" href=\"#func\">func</a>, const char *<a class=\"id\" href=\"#file\">file</a>, int <a class=\"id\" href=\"#line\">line</a>)", 
"{", 
"<span class=\"ts\"/><a class=\"id\" href=\"#BUG_ON\">BUG_ON</a>(<a class=\"id\" href=\"#current\">current</a>-><a class=\"id\" href=\"#lock_depth\">lock_depth</a> &lt; 0);", 
"<span class=\"ts\"/>if (<a class=\"id\" href=\"#likely\">likely</a>(--<a class=\"id\" href=\"#current\">current</a>-><a class=\"id\" href=\"#lock_depth\">lock_depth</a> &lt; 0))", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#__unlock_kernel\">__unlock_kernel</a>();", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#trace_unlock_kernel\">trace_unlock_kernel</a>(<a class=\"id\" href=\"#func\">func</a>, <a class=\"id\" href=\"#file\">file</a>, <a class=\"id\" href=\"#line\">line</a>);", 
"}", 
"", 
"<a class=\"id\" href=\"#EXPORT_SYMBOL\">EXPORT_SYMBOL</a>(<a class=\"id\" href=\"#_lock_kernel\">_lock_kernel</a>);", 
"<a class=\"id\" href=\"#EXPORT_SYMBOL\">EXPORT_SYMBOL</a>(<a class=\"id\" href=\"#_unlock_kernel\">_unlock_kernel</a>);", 
"", 
];
xr_frag_insert('l/77/1a20ba767beaa966e8342fec44d99c61fd9d09.xr', __xr_tmp);
