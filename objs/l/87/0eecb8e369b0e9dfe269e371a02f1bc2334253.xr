var __xr_tmp = [
"#<a class=\"id\" href=\"#ifndef\">ifndef</a> <a class=\"id\" href=\"#_LINUX_PIPE_FS_I_H\">_LINUX_PIPE_FS_I_H</a>", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#_LINUX_PIPE_FS_I_H\">_LINUX_PIPE_FS_I_H</a>", 
"", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#PIPEFS_MAGIC\">PIPEFS_MAGIC</a> 0x50495045", 
"", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#PIPE_DEF_BUFFERS\">PIPE_DEF_BUFFERS</a><span class=\"ts\"/>16", 
"", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#PIPE_BUF_FLAG_LRU\">PIPE_BUF_FLAG_LRU</a><span class=\"ts\"/>0x01<span class=\"ts\"/><span class=\"comment\">/* page is on the LRU */</span>", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#PIPE_BUF_FLAG_ATOMIC\">PIPE_BUF_FLAG_ATOMIC</a><span class=\"ts\"/>0x02<span class=\"ts\"/><span class=\"comment\">/* was atomically mapped */</span>", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#PIPE_BUF_FLAG_GIFT\">PIPE_BUF_FLAG_GIFT</a><span class=\"ts\"/>0x04<span class=\"ts\"/><span class=\"comment\">/* page is a gift */</span>", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>struct pipe_buffer - a linux kernel pipe buffer</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>@page: the page containing the data for the pipe buffer</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>@offset: offset of data inside the @page</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>@len: length of data inside the @page</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>@ops: operations associated with this buffer. See @pipe_buf_operations.</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>@flags: pipe buffer flags. See above.</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>@private: private data owned by the ops.</span>", 
"<span class=\"comment\"> **/</span>", 
"struct <a class=\"id\" href=\"#pipe_buffer\">pipe_buffer</a> {", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#page\">page</a> *<a class=\"id\" href=\"#page\">page</a>;", 
"<span class=\"ts\"/>unsigned int <a class=\"id\" href=\"#offset\">offset</a>, <a class=\"id\" href=\"#len\">len</a>;", 
"<span class=\"ts\"/>const struct <a class=\"id\" href=\"#pipe_buf_operations\">pipe_buf_operations</a> *<a class=\"id\" href=\"#ops\">ops</a>;", 
"<span class=\"ts\"/>unsigned int <a class=\"id\" href=\"#flags\">flags</a>;", 
"<span class=\"ts\"/>unsigned long <a class=\"id\" href=\"#private\">private</a>;", 
"};", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>struct pipe_inode_info - a linux kernel pipe</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>@wait: reader/writer wait point in case of empty/full pipe</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>@nrbufs: the number of non-empty pipe buffers in this pipe</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>@curbuf: the current pipe buffer entry</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>@tmp_page: cached released page</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>@readers: number of current readers of this pipe</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>@writers: number of current writers of this pipe</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>@waiting_writers: number of writers blocked waiting for room</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>@r_counter: reader counter</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>@w_counter: writer counter</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>@fasync_readers: reader side fasync</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>@fasync_writers: writer side fasync</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>@inode: inode this pipe is attached to</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>@bufs: the circular array of pipe buffers</span>", 
"<span class=\"comment\"> **/</span>", 
"struct <a class=\"id\" href=\"#pipe_inode_info\">pipe_inode_info</a> {", 
"<span class=\"ts\"/><a class=\"id\" href=\"#wait_queue_head_t\">wait_queue_head_t</a> <a class=\"id\" href=\"#wait\">wait</a>;", 
"<span class=\"ts\"/>unsigned int <a class=\"id\" href=\"#nrbufs\">nrbufs</a>, <a class=\"id\" href=\"#curbuf\">curbuf</a>, <a class=\"id\" href=\"#buffers\">buffers</a>;", 
"<span class=\"ts\"/>unsigned int <a class=\"id\" href=\"#readers\">readers</a>;", 
"<span class=\"ts\"/>unsigned int <a class=\"id\" href=\"#writers\">writers</a>;", 
"<span class=\"ts\"/>unsigned int <a class=\"id\" href=\"#waiting_writers\">waiting_writers</a>;", 
"<span class=\"ts\"/>unsigned int <a class=\"id\" href=\"#r_counter\">r_counter</a>;", 
"<span class=\"ts\"/>unsigned int <a class=\"id\" href=\"#w_counter\">w_counter</a>;", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#page\">page</a> *<a class=\"id\" href=\"#tmp_page\">tmp_page</a>;", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#fasync_struct\">fasync_struct</a> *<a class=\"id\" href=\"#fasync_readers\">fasync_readers</a>;", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#fasync_struct\">fasync_struct</a> *<a class=\"id\" href=\"#fasync_writers\">fasync_writers</a>;", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#inode\">inode</a> *<a class=\"id\" href=\"#inode\">inode</a>;", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#pipe_buffer\">pipe_buffer</a> *<a class=\"id\" href=\"#bufs\">bufs</a>;", 
"};", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * Note on the nesting of these functions:</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * -&gt;confirm()</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>-&gt;steal()</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>...</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>-&gt;map()</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>...</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>-&gt;unmap()</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * That is, -&gt;map() must be called on a confirmed buffer,</span>", 
"<span class=\"comment\"> * same goes for -&gt;steal(). See below for the meaning of each</span>", 
"<span class=\"comment\"> * operation. Also see kerneldoc in fs/pipe.c for the pipe</span>", 
"<span class=\"comment\"> * and generic variants of these hooks.</span>", 
"<span class=\"comment\"> */</span>", 
"struct <a class=\"id\" href=\"#pipe_buf_operations\">pipe_buf_operations</a> {", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * This is set to 1, if the generic pipe read/write may coalesce</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * data into an existing buffer. If this is set to 0, a new pipe</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * page segment is always used for new data.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>int <a class=\"id\" href=\"#can_merge\">can_merge</a>;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * -&gt;map() returns a virtual address mapping of the pipe buffer.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * The last integer flag reflects whether this should be an atomic</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * mapping or not. The atomic map is faster, however you can't take</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * page faults before calling -&gt;unmap() again. So if you need to eg</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * access user data through copy_to/from_user(), then you must get</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * a non-atomic map. -&gt;map() uses the KM_USER0 atomic slot for</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * atomic maps, so you can't map more than one pipe_buffer at once</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * and you have to be careful if mapping another page as source</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * or destination for a copy (IOW, it has to use something else</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * than KM_USER0).</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>void * (*<a class=\"id\" href=\"#map\">map</a>)(struct <a class=\"id\" href=\"#pipe_inode_info\">pipe_inode_info</a> *, struct <a class=\"id\" href=\"#pipe_buffer\">pipe_buffer</a> *, int);", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Undoes -&gt;map(), finishes the virtual mapping of the pipe buffer.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>void (*<a class=\"id\" href=\"#unmap\">unmap</a>)(struct <a class=\"id\" href=\"#pipe_inode_info\">pipe_inode_info</a> *, struct <a class=\"id\" href=\"#pipe_buffer\">pipe_buffer</a> *, void *);", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * -&gt;confirm() verifies that the data in the pipe buffer is there</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * and that the contents are good. If the pages in the pipe belong</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * to a file system, we may need to wait for IO completion in this</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * hook. Returns 0 for good, or a negative error value in case of</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * error.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>int (*<a class=\"id\" href=\"#confirm\">confirm</a>)(struct <a class=\"id\" href=\"#pipe_inode_info\">pipe_inode_info</a> *, struct <a class=\"id\" href=\"#pipe_buffer\">pipe_buffer</a> *);", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * When the contents of this pipe buffer has been completely</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * consumed by a reader, -&gt;release() is called.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>void (*<a class=\"id\" href=\"#release\">release</a>)(struct <a class=\"id\" href=\"#pipe_inode_info\">pipe_inode_info</a> *, struct <a class=\"id\" href=\"#pipe_buffer\">pipe_buffer</a> *);", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Attempt to take ownership of the pipe buffer and its contents.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * -&gt;steal() returns 0 for success, in which case the contents</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * of the pipe (the buf-&gt;page) is locked and now completely owned</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * by the caller. The page may then be transferred to a different</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * mapping, the most often used case is insertion into different</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * file address space cache.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>int (*<a class=\"id\" href=\"#steal\">steal</a>)(struct <a class=\"id\" href=\"#pipe_inode_info\">pipe_inode_info</a> *, struct <a class=\"id\" href=\"#pipe_buffer\">pipe_buffer</a> *);", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Get a reference to the pipe buffer.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>void (*<a class=\"id\" href=\"#get\">get</a>)(struct <a class=\"id\" href=\"#pipe_inode_info\">pipe_inode_info</a> *, struct <a class=\"id\" href=\"#pipe_buffer\">pipe_buffer</a> *);", 
"};", 
"", 
"<span class=\"comment\">/* Differs from PIPE_BUF in that PIPE_SIZE is the length of the actual</span>", 
"<span class=\"comment\">   memory allocation, whereas PIPE_BUF makes atomicity guarantees.  */</span>", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#PIPE_SIZE\">PIPE_SIZE</a><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#PAGE_SIZE\">PAGE_SIZE</a>", 
"", 
"<span class=\"comment\">/* Pipe lock and unlock operations */</span>", 
"void <a class=\"id\" href=\"#pipe_lock\">pipe_lock</a>(struct <a class=\"id\" href=\"#pipe_inode_info\">pipe_inode_info</a> *);", 
"void <a class=\"id\" href=\"#pipe_unlock\">pipe_unlock</a>(struct <a class=\"id\" href=\"#pipe_inode_info\">pipe_inode_info</a> *);", 
"void <a class=\"id\" href=\"#pipe_double_lock\">pipe_double_lock</a>(struct <a class=\"id\" href=\"#pipe_inode_info\">pipe_inode_info</a> *, struct <a class=\"id\" href=\"#pipe_inode_info\">pipe_inode_info</a> *);", 
"", 
"extern unsigned int <a class=\"id\" href=\"#pipe_max_size\">pipe_max_size</a>, <a class=\"id\" href=\"#pipe_min_size\">pipe_min_size</a>;", 
"int <a class=\"id\" href=\"#pipe_proc_fn\">pipe_proc_fn</a>(struct <a class=\"id\" href=\"#ctl_table\">ctl_table</a> *, int, void <a class=\"id\" href=\"#__user\">__user</a> *, <a class=\"id\" href=\"#size_t\">size_t</a> *, <a class=\"id\" href=\"#loff_t\">loff_t</a> *);", 
"", 
"", 
"<span class=\"comment\">/* Drop the inode semaphore and wait for a pipe event, atomically */</span>", 
"void <a class=\"id\" href=\"#pipe_wait\">pipe_wait</a>(struct <a class=\"id\" href=\"#pipe_inode_info\">pipe_inode_info</a> *<a class=\"id\" href=\"#pipe\">pipe</a>);", 
"", 
"struct <a class=\"id\" href=\"#pipe_inode_info\">pipe_inode_info</a> * <a class=\"id\" href=\"#alloc_pipe_info\">alloc_pipe_info</a>(struct <a class=\"id\" href=\"#inode\">inode</a> * <a class=\"id\" href=\"#inode\">inode</a>);", 
"void <a class=\"id\" href=\"#free_pipe_info\">free_pipe_info</a>(struct <a class=\"id\" href=\"#inode\">inode</a> * <a class=\"id\" href=\"#inode\">inode</a>);", 
"void <a class=\"id\" href=\"#__free_pipe_info\">__free_pipe_info</a>(struct <a class=\"id\" href=\"#pipe_inode_info\">pipe_inode_info</a> *);", 
"", 
"<span class=\"comment\">/* Generic pipe buffer ops functions */</span>", 
"void *<a class=\"id\" href=\"#generic_pipe_buf_map\">generic_pipe_buf_map</a>(struct <a class=\"id\" href=\"#pipe_inode_info\">pipe_inode_info</a> *, struct <a class=\"id\" href=\"#pipe_buffer\">pipe_buffer</a> *, int);", 
"void <a class=\"id\" href=\"#generic_pipe_buf_unmap\">generic_pipe_buf_unmap</a>(struct <a class=\"id\" href=\"#pipe_inode_info\">pipe_inode_info</a> *, struct <a class=\"id\" href=\"#pipe_buffer\">pipe_buffer</a> *, void *);", 
"void <a class=\"id\" href=\"#generic_pipe_buf_get\">generic_pipe_buf_get</a>(struct <a class=\"id\" href=\"#pipe_inode_info\">pipe_inode_info</a> *, struct <a class=\"id\" href=\"#pipe_buffer\">pipe_buffer</a> *);", 
"int <a class=\"id\" href=\"#generic_pipe_buf_confirm\">generic_pipe_buf_confirm</a>(struct <a class=\"id\" href=\"#pipe_inode_info\">pipe_inode_info</a> *, struct <a class=\"id\" href=\"#pipe_buffer\">pipe_buffer</a> *);", 
"int <a class=\"id\" href=\"#generic_pipe_buf_steal\">generic_pipe_buf_steal</a>(struct <a class=\"id\" href=\"#pipe_inode_info\">pipe_inode_info</a> *, struct <a class=\"id\" href=\"#pipe_buffer\">pipe_buffer</a> *);", 
"void <a class=\"id\" href=\"#generic_pipe_buf_release\">generic_pipe_buf_release</a>(struct <a class=\"id\" href=\"#pipe_inode_info\">pipe_inode_info</a> *, struct <a class=\"id\" href=\"#pipe_buffer\">pipe_buffer</a> *);", 
"", 
"<span class=\"comment\">/* for F_SETPIPE_SZ and F_GETPIPE_SZ */</span>", 
"long <a class=\"id\" href=\"#pipe_fcntl\">pipe_fcntl</a>(struct <a class=\"id\" href=\"#file\">file</a> *, unsigned int, unsigned long <a class=\"id\" href=\"#arg\">arg</a>);", 
"", 
"#<a class=\"id\" href=\"#endif\">endif</a>", 
];
xr_frag_insert('l/87/0eecb8e369b0e9dfe269e371a02f1bc2334253.xr', __xr_tmp);
