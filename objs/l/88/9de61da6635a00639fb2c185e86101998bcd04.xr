var __xr_tmp = [
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * Sleepable Read-Copy Update mechanism for mutual exclusion.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * This program is free software; you can redistribute it and/or modify</span>", 
"<span class=\"comment\"> * it under the terms of the GNU General Public License as published by</span>", 
"<span class=\"comment\"> * the Free Software Foundation; either version 2 of the License, or</span>", 
"<span class=\"comment\"> * (at your option) any later version.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * This program is distributed in the hope that it will be useful,</span>", 
"<span class=\"comment\"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>", 
"<span class=\"comment\"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>", 
"<span class=\"comment\"> * GNU General Public License for more details.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * You should have received a copy of the GNU General Public License</span>", 
"<span class=\"comment\"> * along with this program; if not, write to the Free Software</span>", 
"<span class=\"comment\"> * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Copyright (C) IBM Corporation, 2006</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Author: Paul McKenney &lt;paulmck@us.ibm.com&gt;</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * For detailed explanation of Read-Copy Update mechanism see -</span>", 
"<span class=\"comment\"> * <span class=\"ts\"/><span class=\"ts\"/>Documentation/RCU/ *.txt</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> */</span>", 
"", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#module\">module</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#mutex\">mutex</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#percpu\">percpu</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#preempt\">preempt</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#rcupdate\">rcupdate</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#sched\">sched</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#smp\">smp</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#srcu\">srcu</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"", 
"static int <a class=\"id\" href=\"#init_srcu_struct_fields\">init_srcu_struct_fields</a>(struct <a class=\"id\" href=\"#srcu_struct\">srcu_struct</a> *<a class=\"id\" href=\"#sp\">sp</a>)", 
"{", 
"<span class=\"ts\"/><a class=\"id\" href=\"#sp\">sp</a>-><a class=\"id\" href=\"#completed\">completed</a> = 0;", 
"<span class=\"ts\"/><a class=\"id\" href=\"#mutex_init\">mutex_init</a>(&amp;<a class=\"id\" href=\"#sp\">sp</a>-><a class=\"id\" href=\"#mutex\">mutex</a>);", 
"<span class=\"ts\"/><a class=\"id\" href=\"#sp\">sp</a>-><a class=\"id\" href=\"#per_cpu_ref\">per_cpu_ref</a> = <a class=\"id\" href=\"#alloc_percpu\">alloc_percpu</a>(struct <a class=\"id\" href=\"#srcu_struct_array\">srcu_struct_array</a>);", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#sp\">sp</a>-><a class=\"id\" href=\"#per_cpu_ref\">per_cpu_ref</a> ? 0 : -<a class=\"id\" href=\"#ENOMEM\">ENOMEM</a>;", 
"}", 
"", 
"#<a class=\"id\" href=\"#ifdef\">ifdef</a> <a class=\"id\" href=\"#CONFIG_DEBUG_LOCK_ALLOC\">CONFIG_DEBUG_LOCK_ALLOC</a>", 
"", 
"int <a class=\"id\" href=\"#__init_srcu_struct\">__init_srcu_struct</a>(struct <a class=\"id\" href=\"#srcu_struct\">srcu_struct</a> *<a class=\"id\" href=\"#sp\">sp</a>, const char *<a class=\"id\" href=\"#name\">name</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/>       struct <a class=\"id\" href=\"#lock_class_key\">lock_class_key</a> *<a class=\"id\" href=\"#key\">key</a>)", 
"{", 
"#<a class=\"id\" href=\"#ifdef\">ifdef</a> <a class=\"id\" href=\"#CONFIG_DEBUG_LOCK_ALLOC\">CONFIG_DEBUG_LOCK_ALLOC</a>", 
"<span class=\"ts\"/><span class=\"comment\">/* Don't re-initialize a lock while it is held. */</span>", 
"<span class=\"ts\"/><a class=\"id\" href=\"#debug_check_no_locks_freed\">debug_check_no_locks_freed</a>((void *)<a class=\"id\" href=\"#sp\">sp</a>, sizeof(*<a class=\"id\" href=\"#sp\">sp</a>));", 
"<span class=\"ts\"/><a class=\"id\" href=\"#lockdep_init_map\">lockdep_init_map</a>(&amp;<a class=\"id\" href=\"#sp\">sp</a>-><a class=\"id\" href=\"#dep_map\">dep_map</a>, <a class=\"id\" href=\"#name\">name</a>, <a class=\"id\" href=\"#key\">key</a>, 0);", 
"#<a class=\"id\" href=\"#endif\">endif</a> <span class=\"comment\">/* #ifdef CONFIG_DEBUG_LOCK_ALLOC */</span>", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#init_srcu_struct_fields\">init_srcu_struct_fields</a>(<a class=\"id\" href=\"#sp\">sp</a>);", 
"}", 
"<a class=\"id\" href=\"#EXPORT_SYMBOL_GPL\">EXPORT_SYMBOL_GPL</a>(<a class=\"id\" href=\"#__init_srcu_struct\">__init_srcu_struct</a>);", 
"", 
"#else <span class=\"comment\">/* #ifdef CONFIG_DEBUG_LOCK_ALLOC */</span>", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * init_srcu_struct - initialize a sleep-RCU structure</span>", 
"<span class=\"comment\"> * @sp: structure to initialize.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Must invoke this on a given srcu_struct before passing that srcu_struct</span>", 
"<span class=\"comment\"> * to any other function.  Each srcu_struct represents a separate domain</span>", 
"<span class=\"comment\"> * of SRCU protection.</span>", 
"<span class=\"comment\"> */</span>", 
"int <a class=\"id\" href=\"#init_srcu_struct\">init_srcu_struct</a>(struct <a class=\"id\" href=\"#srcu_struct\">srcu_struct</a> *<a class=\"id\" href=\"#sp\">sp</a>)", 
"{", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#init_srcu_struct_fields\">init_srcu_struct_fields</a>(<a class=\"id\" href=\"#sp\">sp</a>);", 
"}", 
"<a class=\"id\" href=\"#EXPORT_SYMBOL_GPL\">EXPORT_SYMBOL_GPL</a>(<a class=\"id\" href=\"#init_srcu_struct\">init_srcu_struct</a>);", 
"", 
"#<a class=\"id\" href=\"#endif\">endif</a> <span class=\"comment\">/* #else #ifdef CONFIG_DEBUG_LOCK_ALLOC */</span>", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * srcu_readers_active_idx -- returns approximate number of readers</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>active on the specified rank of per-CPU counters.</span>", 
"<span class=\"comment\"> */</span>", 
"", 
"static int <a class=\"id\" href=\"#srcu_readers_active_idx\">srcu_readers_active_idx</a>(struct <a class=\"id\" href=\"#srcu_struct\">srcu_struct</a> *<a class=\"id\" href=\"#sp\">sp</a>, int <a class=\"id\" href=\"#idx\">idx</a>)", 
"{", 
"<span class=\"ts\"/>int <a class=\"id\" href=\"#cpu\">cpu</a>;", 
"<span class=\"ts\"/>int <a class=\"id\" href=\"#sum\">sum</a>;", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#sum\">sum</a> = 0;", 
"<span class=\"ts\"/><a class=\"id\" href=\"#for_each_possible_cpu\">for_each_possible_cpu</a>(<a class=\"id\" href=\"#cpu\">cpu</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#sum\">sum</a> += <a class=\"id\" href=\"#per_cpu_ptr\">per_cpu_ptr</a>(<a class=\"id\" href=\"#sp\">sp</a>-><a class=\"id\" href=\"#per_cpu_ref\">per_cpu_ref</a>, <a class=\"id\" href=\"#cpu\">cpu</a>)-><a class=\"id\" href=\"#c\">c</a>[<a class=\"id\" href=\"#idx\">idx</a>];", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#sum\">sum</a>;", 
"}", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * srcu_readers_active - returns approximate number of readers.</span>", 
"<span class=\"comment\"> * @sp: which srcu_struct to count active readers (holding srcu_read_lock).</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Note that this is not an atomic primitive, and can therefore suffer</span>", 
"<span class=\"comment\"> * severe errors when invoked on an active srcu_struct.  That said, it</span>", 
"<span class=\"comment\"> * can be useful as an error check at cleanup time.</span>", 
"<span class=\"comment\"> */</span>", 
"static int <a class=\"id\" href=\"#srcu_readers_active\">srcu_readers_active</a>(struct <a class=\"id\" href=\"#srcu_struct\">srcu_struct</a> *<a class=\"id\" href=\"#sp\">sp</a>)", 
"{", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#srcu_readers_active_idx\">srcu_readers_active_idx</a>(<a class=\"id\" href=\"#sp\">sp</a>, 0) + <a class=\"id\" href=\"#srcu_readers_active_idx\">srcu_readers_active_idx</a>(<a class=\"id\" href=\"#sp\">sp</a>, 1);", 
"}", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * cleanup_srcu_struct - deconstruct a sleep-RCU structure</span>", 
"<span class=\"comment\"> * @sp: structure to clean up.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Must invoke this after you are finished using a given srcu_struct that</span>", 
"<span class=\"comment\"> * was initialized via init_srcu_struct(), else you leak memory.</span>", 
"<span class=\"comment\"> */</span>", 
"void <a class=\"id\" href=\"#cleanup_srcu_struct\">cleanup_srcu_struct</a>(struct <a class=\"id\" href=\"#srcu_struct\">srcu_struct</a> *<a class=\"id\" href=\"#sp\">sp</a>)", 
"{", 
"<span class=\"ts\"/>int <a class=\"id\" href=\"#sum\">sum</a>;", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#sum\">sum</a> = <a class=\"id\" href=\"#srcu_readers_active\">srcu_readers_active</a>(<a class=\"id\" href=\"#sp\">sp</a>);", 
"<span class=\"ts\"/><a class=\"id\" href=\"#WARN_ON\">WARN_ON</a>(<a class=\"id\" href=\"#sum\">sum</a>);  <span class=\"comment\">/* Leakage unless caller handles error. */</span>", 
"<span class=\"ts\"/>if (<a class=\"id\" href=\"#sum\">sum</a> != 0)", 
"<span class=\"ts\"/><span class=\"ts\"/>return;", 
"<span class=\"ts\"/><a class=\"id\" href=\"#free_percpu\">free_percpu</a>(<a class=\"id\" href=\"#sp\">sp</a>-><a class=\"id\" href=\"#per_cpu_ref\">per_cpu_ref</a>);", 
"<span class=\"ts\"/><a class=\"id\" href=\"#sp\">sp</a>-><a class=\"id\" href=\"#per_cpu_ref\">per_cpu_ref</a> = <a class=\"id\" href=\"#NULL\">NULL</a>;", 
"}", 
"<a class=\"id\" href=\"#EXPORT_SYMBOL_GPL\">EXPORT_SYMBOL_GPL</a>(<a class=\"id\" href=\"#cleanup_srcu_struct\">cleanup_srcu_struct</a>);", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * Counts the new reader in the appropriate per-CPU element of the</span>", 
"<span class=\"comment\"> * srcu_struct.  Must be called from process context.</span>", 
"<span class=\"comment\"> * Returns an index that must be passed to the matching srcu_read_unlock().</span>", 
"<span class=\"comment\"> */</span>", 
"int <a class=\"id\" href=\"#__srcu_read_lock\">__srcu_read_lock</a>(struct <a class=\"id\" href=\"#srcu_struct\">srcu_struct</a> *<a class=\"id\" href=\"#sp\">sp</a>)", 
"{", 
"<span class=\"ts\"/>int <a class=\"id\" href=\"#idx\">idx</a>;", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#preempt_disable\">preempt_disable</a>();", 
"<span class=\"ts\"/><a class=\"id\" href=\"#idx\">idx</a> = <a class=\"id\" href=\"#sp\">sp</a>-><a class=\"id\" href=\"#completed\">completed</a> &amp; 0x1;", 
"<span class=\"ts\"/><a class=\"id\" href=\"#barrier\">barrier</a>();  <span class=\"comment\">/* ensure compiler looks -once- at sp-&gt;completed. */</span>", 
"<span class=\"ts\"/><a class=\"id\" href=\"#per_cpu_ptr\">per_cpu_ptr</a>(<a class=\"id\" href=\"#sp\">sp</a>-><a class=\"id\" href=\"#per_cpu_ref\">per_cpu_ref</a>, <a class=\"id\" href=\"#smp_processor_id\">smp_processor_id</a>())-><a class=\"id\" href=\"#c\">c</a>[<a class=\"id\" href=\"#idx\">idx</a>]++;", 
"<span class=\"ts\"/><a class=\"id\" href=\"#srcu_barrier\">srcu_barrier</a>();  <span class=\"comment\">/* ensure compiler won't misorder critical section. */</span>", 
"<span class=\"ts\"/><a class=\"id\" href=\"#preempt_enable\">preempt_enable</a>();", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#idx\">idx</a>;", 
"}", 
"<a class=\"id\" href=\"#EXPORT_SYMBOL_GPL\">EXPORT_SYMBOL_GPL</a>(<a class=\"id\" href=\"#__srcu_read_lock\">__srcu_read_lock</a>);", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * Removes the count for the old reader from the appropriate per-CPU</span>", 
"<span class=\"comment\"> * element of the srcu_struct.  Note that this may well be a different</span>", 
"<span class=\"comment\"> * CPU than that which was incremented by the corresponding srcu_read_lock().</span>", 
"<span class=\"comment\"> * Must be called from process context.</span>", 
"<span class=\"comment\"> */</span>", 
"void <a class=\"id\" href=\"#__srcu_read_unlock\">__srcu_read_unlock</a>(struct <a class=\"id\" href=\"#srcu_struct\">srcu_struct</a> *<a class=\"id\" href=\"#sp\">sp</a>, int <a class=\"id\" href=\"#idx\">idx</a>)", 
"{", 
"<span class=\"ts\"/><a class=\"id\" href=\"#preempt_disable\">preempt_disable</a>();", 
"<span class=\"ts\"/><a class=\"id\" href=\"#srcu_barrier\">srcu_barrier</a>();  <span class=\"comment\">/* ensure compiler won't misorder critical section. */</span>", 
"<span class=\"ts\"/><a class=\"id\" href=\"#per_cpu_ptr\">per_cpu_ptr</a>(<a class=\"id\" href=\"#sp\">sp</a>-><a class=\"id\" href=\"#per_cpu_ref\">per_cpu_ref</a>, <a class=\"id\" href=\"#smp_processor_id\">smp_processor_id</a>())-><a class=\"id\" href=\"#c\">c</a>[<a class=\"id\" href=\"#idx\">idx</a>]--;", 
"<span class=\"ts\"/><a class=\"id\" href=\"#preempt_enable\">preempt_enable</a>();", 
"}", 
"<a class=\"id\" href=\"#EXPORT_SYMBOL_GPL\">EXPORT_SYMBOL_GPL</a>(<a class=\"id\" href=\"#__srcu_read_unlock\">__srcu_read_unlock</a>);", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * Helper function for synchronize_srcu() and synchronize_srcu_expedited().</span>", 
"<span class=\"comment\"> */</span>", 
"static void <a class=\"id\" href=\"#__synchronize_srcu\">__synchronize_srcu</a>(struct <a class=\"id\" href=\"#srcu_struct\">srcu_struct</a> *<a class=\"id\" href=\"#sp\">sp</a>, void (*<a class=\"id\" href=\"#sync_func\">sync_func</a>)(void))", 
"{", 
"<span class=\"ts\"/>int <a class=\"id\" href=\"#idx\">idx</a>;", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#idx\">idx</a> = <a class=\"id\" href=\"#sp\">sp</a>-><a class=\"id\" href=\"#completed\">completed</a>;", 
"<span class=\"ts\"/><a class=\"id\" href=\"#mutex_lock\">mutex_lock</a>(&amp;<a class=\"id\" href=\"#sp\">sp</a>-><a class=\"id\" href=\"#mutex\">mutex</a>);", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Check to see if someone else did the work for us while we were</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * waiting to acquire the lock.  We need -two- advances of</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * the counter, not just one.  If there was but one, we might have</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * shown up -after- our helper's first synchronize_sched(), thus</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * having failed to prevent CPU-reordering races with concurrent</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * srcu_read_unlock()s on other CPUs (see comment below).  So we</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * either (1) wait for two or (2) supply the second ourselves.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"", 
"<span class=\"ts\"/>if ((<a class=\"id\" href=\"#sp\">sp</a>-><a class=\"id\" href=\"#completed\">completed</a> - <a class=\"id\" href=\"#idx\">idx</a>) >= 2) {", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#mutex_unlock\">mutex_unlock</a>(&amp;<a class=\"id\" href=\"#sp\">sp</a>-><a class=\"id\" href=\"#mutex\">mutex</a>);", 
"<span class=\"ts\"/><span class=\"ts\"/>return;", 
"<span class=\"ts\"/>}", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#sync_func\">sync_func</a>();  <span class=\"comment\">/* Force memory barrier on all CPUs. */</span>", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * The preceding synchronize_sched() ensures that any CPU that</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * sees the new value of sp-&gt;completed will also see any preceding</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * changes to data structures made by this CPU.  This prevents</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * some other CPU from reordering the accesses in its SRCU</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * read-side critical section to precede the corresponding</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * srcu_read_lock() -- ensuring that such references will in</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * fact be protected.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * So it is now safe to do the flip.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#idx\">idx</a> = <a class=\"id\" href=\"#sp\">sp</a>-><a class=\"id\" href=\"#completed\">completed</a> &amp; 0x1;", 
"<span class=\"ts\"/><a class=\"id\" href=\"#sp\">sp</a>-><a class=\"id\" href=\"#completed\">completed</a>++;", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#sync_func\">sync_func</a>();  <span class=\"comment\">/* Force memory barrier on all CPUs. */</span>", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * At this point, because of the preceding synchronize_sched(),</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * all srcu_read_lock() calls using the old counters have completed.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Their corresponding critical sections might well be still</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * executing, but the srcu_read_lock() primitives themselves</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * will have finished executing.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"", 
"<span class=\"ts\"/>while (<a class=\"id\" href=\"#srcu_readers_active_idx\">srcu_readers_active_idx</a>(<a class=\"id\" href=\"#sp\">sp</a>, <a class=\"id\" href=\"#idx\">idx</a>))", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#schedule_timeout_interruptible\">schedule_timeout_interruptible</a>(1);", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#sync_func\">sync_func</a>();  <span class=\"comment\">/* Force memory barrier on all CPUs. */</span>", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * The preceding synchronize_sched() forces all srcu_read_unlock()</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * primitives that were executing concurrently with the preceding</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * for_each_possible_cpu() loop to have completed by this point.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * More importantly, it also forces the corresponding SRCU read-side</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * critical sections to have also completed, and the corresponding</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * references to SRCU-protected data items to be dropped.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Note:</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *<span class=\"ts\"/>Despite what you might think at first glance, the</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *<span class=\"ts\"/>preceding synchronize_sched() -must- be within the</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *<span class=\"ts\"/>critical section ended by the following mutex_unlock().</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *<span class=\"ts\"/>Otherwise, a task taking the early exit can race</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *<span class=\"ts\"/>with a srcu_read_unlock(), which might have executed</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *<span class=\"ts\"/>just before the preceding srcu_readers_active() check,</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *<span class=\"ts\"/>and whose CPU might have reordered the srcu_read_unlock()</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *<span class=\"ts\"/>with the preceding critical section.  In this case, there</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *<span class=\"ts\"/>is nothing preventing the synchronize_sched() task that is</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *<span class=\"ts\"/>taking the early exit from freeing a data structure that</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *<span class=\"ts\"/>is still being referenced (out of order) by the task</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *<span class=\"ts\"/>doing the srcu_read_unlock().</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *<span class=\"ts\"/>Alternatively, the comparison with \"2\" on the early exit</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *<span class=\"ts\"/>could be changed to \"3\", but this increases synchronize_srcu()</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *<span class=\"ts\"/>latency for bulk loads.  So the current code is preferred.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#mutex_unlock\">mutex_unlock</a>(&amp;<a class=\"id\" href=\"#sp\">sp</a>-><a class=\"id\" href=\"#mutex\">mutex</a>);", 
"}", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * synchronize_srcu - wait for prior SRCU read-side critical-section completion</span>", 
"<span class=\"comment\"> * @sp: srcu_struct with which to synchronize.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Flip the completed counter, and wait for the old count to drain to zero.</span>", 
"<span class=\"comment\"> * As with classic RCU, the updater must use some separate means of</span>", 
"<span class=\"comment\"> * synchronizing concurrent updates.  Can block; must be called from</span>", 
"<span class=\"comment\"> * process context.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Note that it is illegal to call synchronize_srcu() from the corresponding</span>", 
"<span class=\"comment\"> * SRCU read-side critical section; doing so will result in deadlock.</span>", 
"<span class=\"comment\"> * However, it is perfectly legal to call synchronize_srcu() on one</span>", 
"<span class=\"comment\"> * srcu_struct from some other srcu_struct's read-side critical section.</span>", 
"<span class=\"comment\"> */</span>", 
"void <a class=\"id\" href=\"#synchronize_srcu\">synchronize_srcu</a>(struct <a class=\"id\" href=\"#srcu_struct\">srcu_struct</a> *<a class=\"id\" href=\"#sp\">sp</a>)", 
"{", 
"<span class=\"ts\"/><a class=\"id\" href=\"#__synchronize_srcu\">__synchronize_srcu</a>(<a class=\"id\" href=\"#sp\">sp</a>, <a class=\"id\" href=\"#synchronize_sched\">synchronize_sched</a>);", 
"}", 
"<a class=\"id\" href=\"#EXPORT_SYMBOL_GPL\">EXPORT_SYMBOL_GPL</a>(<a class=\"id\" href=\"#synchronize_srcu\">synchronize_srcu</a>);", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * synchronize_srcu_expedited - like synchronize_srcu, but less patient</span>", 
"<span class=\"comment\"> * @sp: srcu_struct with which to synchronize.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Flip the completed counter, and wait for the old count to drain to zero.</span>", 
"<span class=\"comment\"> * As with classic RCU, the updater must use some separate means of</span>", 
"<span class=\"comment\"> * synchronizing concurrent updates.  Can block; must be called from</span>", 
"<span class=\"comment\"> * process context.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Note that it is illegal to call synchronize_srcu_expedited()</span>", 
"<span class=\"comment\"> * from the corresponding SRCU read-side critical section; doing so</span>", 
"<span class=\"comment\"> * will result in deadlock.  However, it is perfectly legal to call</span>", 
"<span class=\"comment\"> * synchronize_srcu_expedited() on one srcu_struct from some other</span>", 
"<span class=\"comment\"> * srcu_struct's read-side critical section.</span>", 
"<span class=\"comment\"> */</span>", 
"void <a class=\"id\" href=\"#synchronize_srcu_expedited\">synchronize_srcu_expedited</a>(struct <a class=\"id\" href=\"#srcu_struct\">srcu_struct</a> *<a class=\"id\" href=\"#sp\">sp</a>)", 
"{", 
"<span class=\"ts\"/><a class=\"id\" href=\"#__synchronize_srcu\">__synchronize_srcu</a>(<a class=\"id\" href=\"#sp\">sp</a>, <a class=\"id\" href=\"#synchronize_sched_expedited\">synchronize_sched_expedited</a>);", 
"}", 
"<a class=\"id\" href=\"#EXPORT_SYMBOL_GPL\">EXPORT_SYMBOL_GPL</a>(<a class=\"id\" href=\"#synchronize_srcu_expedited\">synchronize_srcu_expedited</a>);", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * srcu_batches_completed - return batches completed.</span>", 
"<span class=\"comment\"> * @sp: srcu_struct on which to report batch completion.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Report the number of batches, correlated with, but not necessarily</span>", 
"<span class=\"comment\"> * precisely the same as, the number of grace periods that have elapsed.</span>", 
"<span class=\"comment\"> */</span>", 
"", 
"long <a class=\"id\" href=\"#srcu_batches_completed\">srcu_batches_completed</a>(struct <a class=\"id\" href=\"#srcu_struct\">srcu_struct</a> *<a class=\"id\" href=\"#sp\">sp</a>)", 
"{", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#sp\">sp</a>-><a class=\"id\" href=\"#completed\">completed</a>;", 
"}", 
"<a class=\"id\" href=\"#EXPORT_SYMBOL_GPL\">EXPORT_SYMBOL_GPL</a>(<a class=\"id\" href=\"#srcu_batches_completed\">srcu_batches_completed</a>);", 
];
xr_frag_insert('l/88/9de61da6635a00639fb2c185e86101998bcd04.xr', __xr_tmp);
