var __xr_tmp = [
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * struct spi_driver - Host side \"protocol\" driver</span>", 
"<span class=\"comment\"> * @id_table: List of SPI devices supported by this driver</span>", 
"<span class=\"comment\"> * @probe: Binds this driver to the spi device.  Drivers can verify</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>that the device is actually present, and may need to configure</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>characteristics (such as bits_per_word) which weren't needed for</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>the initial configuration done during system setup.</span>", 
"<span class=\"comment\"> * @remove: Unbinds this driver from the spi device</span>", 
"<span class=\"comment\"> * @shutdown: Standard shutdown callback used during system state</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>transitions such as powerdown/halt and kexec</span>", 
"<span class=\"comment\"> * @suspend: Standard suspend callback used during system state transitions</span>", 
"<span class=\"comment\"> * @resume: Standard resume callback used during system state transitions</span>", 
"<span class=\"comment\"> * @driver: SPI device drivers should initialize the name and owner</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>field of this structure.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * This represents the kind of device driver that uses SPI messages to</span>", 
"<span class=\"comment\"> * interact with the hardware at the other end of a SPI link.  It's called</span>", 
"<span class=\"comment\"> * a \"protocol\" driver because it works through messages rather than talking</span>", 
"<span class=\"comment\"> * directly to SPI hardware (which is what the underlying SPI controller</span>", 
"<span class=\"comment\"> * driver does to pass those messages).  These protocols are defined in the</span>", 
"<span class=\"comment\"> * specification for the device(s) supported by the driver.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * As a rule, those device protocols represent the lowest level interface</span>", 
"<span class=\"comment\"> * supported by a driver, and it will support upper level interfaces too.</span>", 
"<span class=\"comment\"> * Examples of such upper levels include frameworks like MTD, networking,</span>", 
"<span class=\"comment\"> * MMC, RTC, filesystem character device nodes, and hardware monitoring.</span>", 
"<span class=\"comment\"> */</span>", 
"struct <a class=\"id\" href=\"#spi_driver\">spi_driver</a> {", 
"<span class=\"ts\"/>const struct <a class=\"id\" href=\"#spi_device_id\">spi_device_id</a> *<a class=\"id\" href=\"#id_table\">id_table</a>;", 
"<span class=\"ts\"/>int<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>(*<a class=\"id\" href=\"#probe\">probe</a>)(struct <a class=\"id\" href=\"#spi_device\">spi_device</a> *<a class=\"id\" href=\"#spi\">spi</a>);", 
"<span class=\"ts\"/>int<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>(*<a class=\"id\" href=\"#remove\">remove</a>)(struct <a class=\"id\" href=\"#spi_device\">spi_device</a> *<a class=\"id\" href=\"#spi\">spi</a>);", 
"<span class=\"ts\"/>void<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>(*<a class=\"id\" href=\"#shutdown\">shutdown</a>)(struct <a class=\"id\" href=\"#spi_device\">spi_device</a> *<a class=\"id\" href=\"#spi\">spi</a>);", 
"<span class=\"ts\"/>int<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>(*<a class=\"id\" href=\"#suspend\">suspend</a>)(struct <a class=\"id\" href=\"#spi_device\">spi_device</a> *<a class=\"id\" href=\"#spi\">spi</a>, <a class=\"id\" href=\"#pm_message_t\">pm_message_t</a> <a class=\"id\" href=\"#mesg\">mesg</a>);", 
"<span class=\"ts\"/>int<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>(*<a class=\"id\" href=\"#resume\">resume</a>)(struct <a class=\"id\" href=\"#spi_device\">spi_device</a> *<a class=\"id\" href=\"#spi\">spi</a>);", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#device_driver\">device_driver</a><span class=\"ts\"/><a class=\"id\" href=\"#driver\">driver</a>;", 
"};", 
"", 
"static <a class=\"id\" href=\"#inline\">inline</a> struct <a class=\"id\" href=\"#spi_driver\">spi_driver</a> *<a class=\"id\" href=\"#to_spi_driver\">to_spi_driver</a>(struct <a class=\"id\" href=\"#device_driver\">device_driver</a> *<a class=\"id\" href=\"#drv\">drv</a>)", 
"{", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#drv\">drv</a> ? <a class=\"id\" href=\"#container_of\">container_of</a>(<a class=\"id\" href=\"#drv\">drv</a>, struct <a class=\"id\" href=\"#spi_driver\">spi_driver</a>, <a class=\"id\" href=\"#driver\">driver</a>) : <a class=\"id\" href=\"#NULL\">NULL</a>;", 
"}", 
"", 
"extern int <a class=\"id\" href=\"#spi_register_driver\">spi_register_driver</a>(struct <a class=\"id\" href=\"#spi_driver\">spi_driver</a> *<a class=\"id\" href=\"#sdrv\">sdrv</a>);", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * spi_unregister_driver - reverse effect of spi_register_driver</span>", 
"<span class=\"comment\"> * @sdrv: the driver to unregister</span>", 
"<span class=\"comment\"> * Context: can sleep</span>", 
"<span class=\"comment\"> */</span>", 
"static <a class=\"id\" href=\"#inline\">inline</a> void <a class=\"id\" href=\"#spi_unregister_driver\">spi_unregister_driver</a>(struct <a class=\"id\" href=\"#spi_driver\">spi_driver</a> *<a class=\"id\" href=\"#sdrv\">sdrv</a>)", 
"{", 
"<span class=\"ts\"/>if (<a class=\"id\" href=\"#sdrv\">sdrv</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#driver_unregister\">driver_unregister</a>(&amp;<a class=\"id\" href=\"#sdrv\">sdrv</a>-><a class=\"id\" href=\"#driver\">driver</a>);", 
"}", 
"", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * struct spi_master - interface to SPI master controller</span>", 
"<span class=\"comment\"> * @dev: device interface to this driver</span>", 
"<span class=\"comment\"> * @bus_num: board-specific (and often SOC-specific) identifier for a</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>given SPI controller.</span>", 
"<span class=\"comment\"> * @num_chipselect: chipselects are used to distinguish individual</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>SPI slaves, and are numbered from zero to num_chipselects.</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>each slave has a chipselect signal, but it's common that not</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>every chipselect is connected to a slave.</span>", 
"<span class=\"comment\"> * @dma_alignment: SPI controller constraint on DMA buffers alignment.</span>", 
"<span class=\"comment\"> * @mode_bits: flags understood by this controller driver</span>", 
"<span class=\"comment\"> * @flags: other constraints relevant to this driver</span>", 
"<span class=\"comment\"> * @bus_lock_spinlock: spinlock for SPI bus locking</span>", 
"<span class=\"comment\"> * @bus_lock_mutex: mutex for SPI bus locking</span>", 
"<span class=\"comment\"> * @bus_lock_flag: indicates that the SPI bus is locked for exclusive use</span>", 
"<span class=\"comment\"> * @setup: updates the device mode and clocking records used by a</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>device's SPI controller; protocol code may call this.  This</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>must fail if an unrecognized or unsupported mode is requested.</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>It's always safe to call this unless transfers are pending on</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>the device whose settings are being modified.</span>", 
"<span class=\"comment\"> * @transfer: adds a message to the controller's transfer queue.</span>", 
"<span class=\"comment\"> * @cleanup: frees controller-specific state</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Each SPI master controller can communicate with one or more @spi_device</span>", 
"<span class=\"comment\"> * children.  These make a small bus, sharing MOSI, MISO and SCK signals</span>", 
"<span class=\"comment\"> * but not chip select signals.  Each device may be configured to use a</span>", 
"<span class=\"comment\"> * different clock rate, since those shared signals are ignored unless</span>", 
"<span class=\"comment\"> * the chip is selected.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * The driver for an SPI controller manages access to those devices through</span>", 
"<span class=\"comment\"> * a queue of spi_message transactions, copying data between CPU memory and</span>", 
"<span class=\"comment\"> * an SPI slave device.  For each such message it queues, it calls the</span>", 
"<span class=\"comment\"> * message's completion function when the transaction completes.</span>", 
"<span class=\"comment\"> */</span>", 
"struct <a class=\"id\" href=\"#spi_master\">spi_master</a> {", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#device\">device</a><span class=\"ts\"/><a class=\"id\" href=\"#dev\">dev</a>;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/* other than negative (== assign one dynamically), bus_num is fully</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * board-specific.  usually that simplifies to being SOC-specific.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * example:  one SOC has three SPI controllers, numbered 0..2,</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * and one board's schematics might show it using SPI-2.  software</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * would normally use bus_num=2 for that controller.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/><a class=\"id\" href=\"#s16\">s16</a><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#bus_num\">bus_num</a>;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/* chipselects will be integral to many controllers; some others</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * might use board-specific GPIOs.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/><a class=\"id\" href=\"#u16\">u16</a><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#num_chipselect\">num_chipselect</a>;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/* some SPI controllers pose alignment requirements on DMAable</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * buffers; let protocol drivers know about these requirements.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/><a class=\"id\" href=\"#u16\">u16</a><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#dma_alignment\">dma_alignment</a>;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/* spi_device.mode flags understood by this controller driver */</span>", 
"<span class=\"ts\"/><a class=\"id\" href=\"#u16\">u16</a><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#mode_bits\">mode_bits</a>;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/* other constraints relevant to this driver */</span>", 
"<span class=\"ts\"/><a class=\"id\" href=\"#u16\">u16</a><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#flags\">flags</a>;", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#SPI_MASTER_HALF_DUPLEX\">SPI_MASTER_HALF_DUPLEX</a><span class=\"ts\"/><a class=\"id\" href=\"#BIT\">BIT</a>(0)<span class=\"ts\"/><span class=\"ts\"/><span class=\"comment\">/* can't do full duplex */</span>", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#SPI_MASTER_NO_RX\">SPI_MASTER_NO_RX</a><span class=\"ts\"/><a class=\"id\" href=\"#BIT\">BIT</a>(1)<span class=\"ts\"/><span class=\"ts\"/><span class=\"comment\">/* can't do buffer read */</span>", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#SPI_MASTER_NO_TX\">SPI_MASTER_NO_TX</a><span class=\"ts\"/><a class=\"id\" href=\"#BIT\">BIT</a>(2)<span class=\"ts\"/><span class=\"ts\"/><span class=\"comment\">/* can't do buffer write */</span>", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/* lock and mutex for SPI bus locking */</span>", 
"<span class=\"ts\"/><a class=\"id\" href=\"#spinlock_t\">spinlock_t</a><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#bus_lock_spinlock\">bus_lock_spinlock</a>;", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#mutex\">mutex</a><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#bus_lock_mutex\">bus_lock_mutex</a>;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/* flag indicating that the SPI bus is locked for exclusive use */</span>", 
"<span class=\"ts\"/><a class=\"id\" href=\"#bool\">bool</a><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#bus_lock_flag\">bus_lock_flag</a>;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/* Setup mode and clock, etc (spi driver may call many times).</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * IMPORTANT:  this may be called when transfers to another</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * device are active.  DO NOT UPDATE SHARED REGISTERS in ways</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * which could break those transfers.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>int<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>(*<a class=\"id\" href=\"#setup\">setup</a>)(struct <a class=\"id\" href=\"#spi_device\">spi_device</a> *<a class=\"id\" href=\"#spi\">spi</a>);", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/* bidirectional bulk transfers</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * + The transfer() method may not sleep; its main role is</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *   just to add the message to the queue.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * + For now there's no remove-from-queue operation, or</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *   any other request management</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * + To a given spi_device, message queueing is pure fifo</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * + The master's main job is to process its message queue,</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *   selecting a chip then transferring data</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * + If there are multiple spi_device children, the i/o queue</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *   arbitration algorithm is unspecified (round robin, fifo,</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *   priority, reservations, preemption, etc)</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * + Chipselect stays active during the entire message</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *   (unless modified by spi_transfer.cs_change != 0).</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * + The message transfers use clock and SPI mode parameters</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *   previously established by setup() for this device</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>int<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>(*<a class=\"id\" href=\"#transfer\">transfer</a>)(struct <a class=\"id\" href=\"#spi_device\">spi_device</a> *<a class=\"id\" href=\"#spi\">spi</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>struct <a class=\"id\" href=\"#spi_message\">spi_message</a> *<a class=\"id\" href=\"#mesg\">mesg</a>);", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/* called on release() to free memory provided by spi_master */</span>", 
"<span class=\"ts\"/>void<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>(*<a class=\"id\" href=\"#cleanup\">cleanup</a>)(struct <a class=\"id\" href=\"#spi_device\">spi_device</a> *<a class=\"id\" href=\"#spi\">spi</a>);", 
"};", 
"", 
"static <a class=\"id\" href=\"#inline\">inline</a> void *<a class=\"id\" href=\"#spi_master_get_devdata\">spi_master_get_devdata</a>(struct <a class=\"id\" href=\"#spi_master\">spi_master</a> *<a class=\"id\" href=\"#master\">master</a>)", 
"{", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#dev_get_drvdata\">dev_get_drvdata</a>(&amp;<a class=\"id\" href=\"#master\">master</a>-><a class=\"id\" href=\"#dev\">dev</a>);", 
"}", 
"", 
"static <a class=\"id\" href=\"#inline\">inline</a> void <a class=\"id\" href=\"#spi_master_set_devdata\">spi_master_set_devdata</a>(struct <a class=\"id\" href=\"#spi_master\">spi_master</a> *<a class=\"id\" href=\"#master\">master</a>, void *<a class=\"id\" href=\"#data\">data</a>)", 
"{", 
"<span class=\"ts\"/><a class=\"id\" href=\"#dev_set_drvdata\">dev_set_drvdata</a>(&amp;<a class=\"id\" href=\"#master\">master</a>-><a class=\"id\" href=\"#dev\">dev</a>, <a class=\"id\" href=\"#data\">data</a>);", 
"}", 
"", 
"static <a class=\"id\" href=\"#inline\">inline</a> struct <a class=\"id\" href=\"#spi_master\">spi_master</a> *<a class=\"id\" href=\"#spi_master_get\">spi_master_get</a>(struct <a class=\"id\" href=\"#spi_master\">spi_master</a> *<a class=\"id\" href=\"#master\">master</a>)", 
"{", 
"<span class=\"ts\"/>if (!<a class=\"id\" href=\"#master\">master</a> || !<a class=\"id\" href=\"#get_device\">get_device</a>(&amp;<a class=\"id\" href=\"#master\">master</a>-><a class=\"id\" href=\"#dev\">dev</a>))", 
"<span class=\"ts\"/><span class=\"ts\"/>return <a class=\"id\" href=\"#NULL\">NULL</a>;", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#master\">master</a>;", 
"}", 
"", 
"static <a class=\"id\" href=\"#inline\">inline</a> void <a class=\"id\" href=\"#spi_master_put\">spi_master_put</a>(struct <a class=\"id\" href=\"#spi_master\">spi_master</a> *<a class=\"id\" href=\"#master\">master</a>)", 
"{", 
"<span class=\"ts\"/>if (<a class=\"id\" href=\"#master\">master</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#put_device\">put_device</a>(&amp;<a class=\"id\" href=\"#master\">master</a>-><a class=\"id\" href=\"#dev\">dev</a>);", 
"}", 
"", 
"", 
"<span class=\"comment\">/* the spi driver core manages memory for the spi_master classdev */</span>", 
"extern struct <a class=\"id\" href=\"#spi_master\">spi_master</a> *", 
"<a class=\"id\" href=\"#spi_alloc_master\">spi_alloc_master</a>(struct <a class=\"id\" href=\"#device\">device</a> *<a class=\"id\" href=\"#host\">host</a>, unsigned <a class=\"id\" href=\"#size\">size</a>);", 
"", 
"extern int <a class=\"id\" href=\"#spi_register_master\">spi_register_master</a>(struct <a class=\"id\" href=\"#spi_master\">spi_master</a> *<a class=\"id\" href=\"#master\">master</a>);", 
"extern void <a class=\"id\" href=\"#spi_unregister_master\">spi_unregister_master</a>(struct <a class=\"id\" href=\"#spi_master\">spi_master</a> *<a class=\"id\" href=\"#master\">master</a>);", 
"", 
"extern struct <a class=\"id\" href=\"#spi_master\">spi_master</a> *<a class=\"id\" href=\"#spi_busnum_to_master\">spi_busnum_to_master</a>(<a class=\"id\" href=\"#u16\">u16</a> <a class=\"id\" href=\"#busnum\">busnum</a>);", 
"", 
"<span class=\"comment\">/*---------------------------------------------------------------------------*/</span>", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * I/O INTERFACE between SPI controller and protocol drivers</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Protocol drivers use a queue of spi_messages, each transferring data</span>", 
"<span class=\"comment\"> * between the controller and memory buffers.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * The spi_messages themselves consist of a series of read+write transfer</span>", 
"<span class=\"comment\"> * segments.  Those segments always read the same number of bits as they</span>", 
"<span class=\"comment\"> * write; but one or the other is easily ignored by passing a null buffer</span>", 
"<span class=\"comment\"> * pointer.  (This is unlike most types of I/O API, because SPI hardware</span>", 
"<span class=\"comment\"> * is full duplex.)</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * NOTE:  Allocation of spi_transfer and spi_message memory is entirely</span>", 
"<span class=\"comment\"> * up to the protocol driver, which guarantees the integrity of both (as</span>", 
"<span class=\"comment\"> * well as the data buffers) for as long as the message is queued.</span>", 
"<span class=\"comment\"> */</span>", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * struct spi_transfer - a read/write buffer pair</span>", 
"<span class=\"comment\"> * @tx_buf: data to be written (dma-safe memory), or NULL</span>", 
"<span class=\"comment\"> * @rx_buf: data to be read (dma-safe memory), or NULL</span>", 
"<span class=\"comment\"> * @tx_dma: DMA address of tx_buf, if @spi_message.is_dma_mapped</span>", 
"<span class=\"comment\"> * @rx_dma: DMA address of rx_buf, if @spi_message.is_dma_mapped</span>", 
"<span class=\"comment\"> * @len: size of rx and tx buffers (in bytes)</span>", 
"<span class=\"comment\"> * @speed_hz: Select a speed other than the device default for this</span>", 
"<span class=\"comment\"> *      transfer. If 0 the default (from @spi_device) is used.</span>", 
"<span class=\"comment\"> * @bits_per_word: select a bits_per_word other than the device default</span>", 
"<span class=\"comment\"> *      for this transfer. If 0 the default (from @spi_device) is used.</span>", 
"<span class=\"comment\"> * @cs_change: affects chipselect after this transfer completes</span>", 
"<span class=\"comment\"> * @delay_usecs: microseconds to delay after this transfer before</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>(optionally) changing the chipselect status, then starting</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>the next transfer or completing this @spi_message.</span>", 
"<span class=\"comment\"> * @transfer_list: transfers are sequenced through @spi_message.transfers</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * SPI transfers always write the same number of bytes as they read.</span>", 
"<span class=\"comment\"> * Protocol drivers should always provide @rx_buf and/or @tx_buf.</span>", 
"<span class=\"comment\"> * In some cases, they may also want to provide DMA addresses for</span>", 
"<span class=\"comment\"> * the data being transferred; that may reduce overhead, when the</span>", 
"<span class=\"comment\"> * underlying driver uses dma.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * If the transmit buffer is null, zeroes will be shifted out</span>", 
"<span class=\"comment\"> * while filling @rx_buf.  If the receive buffer is null, the data</span>", 
"<span class=\"comment\"> * shifted in will be discarded.  Only \"len\" bytes shift out (or in).</span>", 
"<span class=\"comment\"> * It's an error to try to shift out a partial word.  (For example, by</span>", 
"<span class=\"comment\"> * shifting out three bytes with word size of sixteen or twenty bits;</span>", 
"<span class=\"comment\"> * the former uses two bytes per word, the latter uses four bytes.)</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * In-memory data values are always in native CPU byte order, translated</span>", 
"<span class=\"comment\"> * from the wire byte order (big-endian except with SPI_LSB_FIRST).  So</span>", 
"<span class=\"comment\"> * for example when bits_per_word is sixteen, buffers are 2N bytes long</span>", 
"<span class=\"comment\"> * (@len = 2N) and hold N sixteen bit words in CPU byte order.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * When the word size of the SPI transfer is not a power-of-two multiple</span>", 
"<span class=\"comment\"> * of eight bits, those in-memory words include extra bits.  In-memory</span>", 
"<span class=\"comment\"> * words are always seen by protocol drivers as right-justified, so the</span>", 
"<span class=\"comment\"> * undefined (rx) or unused (tx) bits are always the most significant bits.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * All SPI transfers start with the relevant chipselect active.  Normally</span>", 
"<span class=\"comment\"> * it stays selected until after the last transfer in a message.  Drivers</span>", 
"<span class=\"comment\"> * can affect the chipselect signal using cs_change.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * (i) If the transfer isn't the last one in the message, this flag is</span>", 
"<span class=\"comment\"> * used to make the chipselect briefly go inactive in the middle of the</span>", 
"<span class=\"comment\"> * message.  Toggling chipselect in this way may be needed to terminate</span>", 
"<span class=\"comment\"> * a chip command, letting a single spi_message perform all of group of</span>", 
"<span class=\"comment\"> * chip transactions together.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * (ii) When the transfer is the last one in the message, the chip may</span>", 
"<span class=\"comment\"> * stay selected until the next transfer.  On multi-device SPI busses</span>", 
"<span class=\"comment\"> * with nothing blocking messages going to other devices, this is just</span>", 
"<span class=\"comment\"> * a performance hint; starting a message to another device deselects</span>", 
"<span class=\"comment\"> * this one.  But in other cases, this can be used to ensure correctness.</span>", 
"<span class=\"comment\"> * Some devices need protocol transactions to be built from a series of</span>", 
"<span class=\"comment\"> * spi_message submissions, where the content of one message is determined</span>", 
"<span class=\"comment\"> * by the results of previous messages and where the whole transaction</span>", 
"<span class=\"comment\"> * ends when the chipselect goes intactive.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * The code that submits an spi_message (and its spi_transfers)</span>", 
"<span class=\"comment\"> * to the lower layers is responsible for managing its memory.</span>", 
"<span class=\"comment\"> * Zero-initialize every field you don't set up explicitly, to</span>", 
"<span class=\"comment\"> * insulate against future API updates.  After you submit a message</span>", 
"<span class=\"comment\"> * and its transfers, ignore them until its completion callback.</span>", 
"<span class=\"comment\"> */</span>", 
"struct <a class=\"id\" href=\"#spi_transfer\">spi_transfer</a> {", 
"<span class=\"ts\"/><span class=\"comment\">/* it's ok if tx_buf == rx_buf (right?)</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * for MicroWire, one buffer must be null</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * buffers must work with dma_*map_single() calls, unless</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *   spi_message.is_dma_mapped reports a pre-existing mapping</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>const void<span class=\"ts\"/>*<a class=\"id\" href=\"#tx_buf\">tx_buf</a>;", 
"<span class=\"ts\"/>void<span class=\"ts\"/><span class=\"ts\"/>*<a class=\"id\" href=\"#rx_buf\">rx_buf</a>;", 
"<span class=\"ts\"/>unsigned<span class=\"ts\"/><a class=\"id\" href=\"#len\">len</a>;", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#dma_addr_t\">dma_addr_t</a><span class=\"ts\"/><a class=\"id\" href=\"#tx_dma\">tx_dma</a>;", 
"<span class=\"ts\"/><a class=\"id\" href=\"#dma_addr_t\">dma_addr_t</a><span class=\"ts\"/><a class=\"id\" href=\"#rx_dma\">rx_dma</a>;", 
"", 
"<span class=\"ts\"/>unsigned<span class=\"ts\"/><a class=\"id\" href=\"#cs_change\">cs_change</a>:1;", 
"<span class=\"ts\"/><a class=\"id\" href=\"#u8\">u8</a><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#bits_per_word\">bits_per_word</a>;", 
"<span class=\"ts\"/><a class=\"id\" href=\"#u16\">u16</a><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#delay_usecs\">delay_usecs</a>;", 
"<span class=\"ts\"/><a class=\"id\" href=\"#u32\">u32</a><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#speed_hz\">speed_hz</a>;", 
"", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#list_head\">list_head</a> <a class=\"id\" href=\"#transfer_list\">transfer_list</a>;", 
"};", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * struct spi_message - one multi-segment SPI transaction</span>", 
"<span class=\"comment\"> * @transfers: list of transfer segments in this transaction</span>", 
"<span class=\"comment\"> * @spi: SPI device to which the transaction is queued</span>", 
"<span class=\"comment\"> * @is_dma_mapped: if true, the caller provided both dma and cpu virtual</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>addresses for each transfer buffer</span>", 
"<span class=\"comment\"> * @complete: called to report transaction completions</span>", 
"<span class=\"comment\"> * @context: the argument to complete() when it's called</span>", 
"<span class=\"comment\"> * @actual_length: the total number of bytes that were transferred in all</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>successful segments</span>", 
"<span class=\"comment\"> * @status: zero for success, else negative errno</span>", 
"<span class=\"comment\"> * @queue: for use by whichever driver currently owns the message</span>", 
"<span class=\"comment\"> * @state: for use by whichever driver currently owns the message</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * A @spi_message is used to execute an atomic sequence of data transfers,</span>", 
"<span class=\"comment\"> * each represented by a struct spi_transfer.  The sequence is \"atomic\"</span>", 
"<span class=\"comment\"> * in the sense that no other spi_message may use that SPI bus until that</span>", 
"<span class=\"comment\"> * sequence completes.  On some systems, many such sequences can execute as</span>", 
"<span class=\"comment\"> * as single programmed DMA transfer.  On all systems, these messages are</span>", 
"<span class=\"comment\"> * queued, and might complete after transactions to other devices.  Messages</span>", 
"<span class=\"comment\"> * sent to a given spi_device are alway executed in FIFO order.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * The code that submits an spi_message (and its spi_transfers)</span>", 
"<span class=\"comment\"> * to the lower layers is responsible for managing its memory.</span>", 
"<span class=\"comment\"> * Zero-initialize every field you don't set up explicitly, to</span>", 
"<span class=\"comment\"> * insulate against future API updates.  After you submit a message</span>", 
"<span class=\"comment\"> * and its transfers, ignore them until its completion callback.</span>", 
"<span class=\"comment\"> */</span>", 
"struct <a class=\"id\" href=\"#spi_message\">spi_message</a> {", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#list_head\">list_head</a><span class=\"ts\"/><a class=\"id\" href=\"#transfers\">transfers</a>;", 
"", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#spi_device\">spi_device</a><span class=\"ts\"/>*<a class=\"id\" href=\"#spi\">spi</a>;", 
"", 
"<span class=\"ts\"/>unsigned<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#is_dma_mapped\">is_dma_mapped</a>:1;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/* REVISIT:  we might want a flag affecting the behavior of the</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * last transfer ... allowing things like \"read 16 bit length L\"</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * immediately followed by \"read L bytes\".  Basically imposing</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * a specific message scheduling algorithm.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Some controller drivers (message-at-a-time queue processing)</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * could provide that as their default scheduling algorithm.  But</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * others (with multi-message pipelines) could need a flag to</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * tell them about such special cases.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/* completion is reported through a callback */</span>", 
"<span class=\"ts\"/>void<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>(*<a class=\"id\" href=\"#complete\">complete</a>)(void *<a class=\"id\" href=\"#context\">context</a>);", 
"<span class=\"ts\"/>void<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>*<a class=\"id\" href=\"#context\">context</a>;", 
"<span class=\"ts\"/>unsigned<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#actual_length\">actual_length</a>;", 
"<span class=\"ts\"/>int<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#status\">status</a>;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/* for optional use by whatever driver currently owns the</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * spi_message ...  between calls to spi_async and then later</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * complete(), that's the spi_master controller driver.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#list_head\">list_head</a><span class=\"ts\"/><a class=\"id\" href=\"#queue\">queue</a>;", 
"<span class=\"ts\"/>void<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>*<a class=\"id\" href=\"#state\">state</a>;", 
"};", 
"", 
"static <a class=\"id\" href=\"#inline\">inline</a> void <a class=\"id\" href=\"#spi_message_init\">spi_message_init</a>(struct <a class=\"id\" href=\"#spi_message\">spi_message</a> *<a class=\"id\" href=\"#m\">m</a>)", 
"{", 
"<span class=\"ts\"/><a class=\"id\" href=\"#memset\">memset</a>(<a class=\"id\" href=\"#m\">m</a>, 0, sizeof *<a class=\"id\" href=\"#m\">m</a>);", 
"<span class=\"ts\"/><a class=\"id\" href=\"#INIT_LIST_HEAD\">INIT_LIST_HEAD</a>(&amp;<a class=\"id\" href=\"#m\">m</a>-><a class=\"id\" href=\"#transfers\">transfers</a>);", 
"}", 
"", 
"static <a class=\"id\" href=\"#inline\">inline</a> void", 
"<a class=\"id\" href=\"#spi_message_add_tail\">spi_message_add_tail</a>(struct <a class=\"id\" href=\"#spi_transfer\">spi_transfer</a> *<a class=\"id\" href=\"#t\">t</a>, struct <a class=\"id\" href=\"#spi_message\">spi_message</a> *<a class=\"id\" href=\"#m\">m</a>)", 
"{", 
"<span class=\"ts\"/><a class=\"id\" href=\"#list_add_tail\">list_add_tail</a>(&amp;<a class=\"id\" href=\"#t\">t</a>-><a class=\"id\" href=\"#transfer_list\">transfer_list</a>, &amp;<a class=\"id\" href=\"#m\">m</a>-><a class=\"id\" href=\"#transfers\">transfers</a>);", 
"}", 
"", 
"static <a class=\"id\" href=\"#inline\">inline</a> void", 
"<a class=\"id\" href=\"#spi_transfer_del\">spi_transfer_del</a>(struct <a class=\"id\" href=\"#spi_transfer\">spi_transfer</a> *<a class=\"id\" href=\"#t\">t</a>)", 
"{", 
"<span class=\"ts\"/><a class=\"id\" href=\"#list_del\">list_del</a>(&amp;<a class=\"id\" href=\"#t\">t</a>-><a class=\"id\" href=\"#transfer_list\">transfer_list</a>);", 
"}", 
"", 
"<span class=\"comment\">/* It's fine to embed message and transaction structures in other data</span>", 
"<span class=\"comment\"> * structures so long as you don't free them while they're in use.</span>", 
"<span class=\"comment\"> */</span>", 
"", 
"static <a class=\"id\" href=\"#inline\">inline</a> struct <a class=\"id\" href=\"#spi_message\">spi_message</a> *<a class=\"id\" href=\"#spi_message_alloc\">spi_message_alloc</a>(unsigned <a class=\"id\" href=\"#ntrans\">ntrans</a>, <a class=\"id\" href=\"#gfp_t\">gfp_t</a> <a class=\"id\" href=\"#flags\">flags</a>)", 
"{", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#spi_message\">spi_message</a> *<a class=\"id\" href=\"#m\">m</a>;", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#m\">m</a> = <a class=\"id\" href=\"#kzalloc\">kzalloc</a>(sizeof(struct <a class=\"id\" href=\"#spi_message\">spi_message</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>+ <a class=\"id\" href=\"#ntrans\">ntrans</a> * sizeof(struct <a class=\"id\" href=\"#spi_transfer\">spi_transfer</a>),", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#flags\">flags</a>);", 
"<span class=\"ts\"/>if (<a class=\"id\" href=\"#m\">m</a>) {", 
"<span class=\"ts\"/><span class=\"ts\"/>int <a class=\"id\" href=\"#i\">i</a>;", 
"<span class=\"ts\"/><span class=\"ts\"/>struct <a class=\"id\" href=\"#spi_transfer\">spi_transfer</a> *<a class=\"id\" href=\"#t\">t</a> = (struct <a class=\"id\" href=\"#spi_transfer\">spi_transfer</a> *)(<a class=\"id\" href=\"#m\">m</a> + 1);", 
"", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#INIT_LIST_HEAD\">INIT_LIST_HEAD</a>(&amp;<a class=\"id\" href=\"#m\">m</a>-><a class=\"id\" href=\"#transfers\">transfers</a>);", 
"<span class=\"ts\"/><span class=\"ts\"/>for (<a class=\"id\" href=\"#i\">i</a> = 0; <a class=\"id\" href=\"#i\">i</a> &lt; <a class=\"id\" href=\"#ntrans\">ntrans</a>; <a class=\"id\" href=\"#i\">i</a>++, <a class=\"id\" href=\"#t\">t</a>++)", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#spi_message_add_tail\">spi_message_add_tail</a>(<a class=\"id\" href=\"#t\">t</a>, <a class=\"id\" href=\"#m\">m</a>);", 
"<span class=\"ts\"/>}", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#m\">m</a>;", 
"}", 
"", 
"static <a class=\"id\" href=\"#inline\">inline</a> void <a class=\"id\" href=\"#spi_message_free\">spi_message_free</a>(struct <a class=\"id\" href=\"#spi_message\">spi_message</a> *<a class=\"id\" href=\"#m\">m</a>)", 
"{", 
"<span class=\"ts\"/><a class=\"id\" href=\"#kfree\">kfree</a>(<a class=\"id\" href=\"#m\">m</a>);", 
"}", 
"", 
"extern int <a class=\"id\" href=\"#spi_setup\">spi_setup</a>(struct <a class=\"id\" href=\"#spi_device\">spi_device</a> *<a class=\"id\" href=\"#spi\">spi</a>);", 
"extern int <a class=\"id\" href=\"#spi_async\">spi_async</a>(struct <a class=\"id\" href=\"#spi_device\">spi_device</a> *<a class=\"id\" href=\"#spi\">spi</a>, struct <a class=\"id\" href=\"#spi_message\">spi_message</a> *<a class=\"id\" href=\"#message\">message</a>);", 
"extern int <a class=\"id\" href=\"#spi_async_locked\">spi_async_locked</a>(struct <a class=\"id\" href=\"#spi_device\">spi_device</a> *<a class=\"id\" href=\"#spi\">spi</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>    struct <a class=\"id\" href=\"#spi_message\">spi_message</a> *<a class=\"id\" href=\"#message\">message</a>);", 
"", 
"<span class=\"comment\">/*---------------------------------------------------------------------------*/</span>", 
"", 
"<span class=\"comment\">/* All these synchronous SPI transfer routines are utilities layered</span>", 
"<span class=\"comment\"> * over the core async transfer primitive.  Here, \"synchronous\" means</span>", 
"<span class=\"comment\"> * they will sleep uninterruptibly until the async transfer completes.</span>", 
"<span class=\"comment\"> */</span>", 
"", 
"extern int <a class=\"id\" href=\"#spi_sync\">spi_sync</a>(struct <a class=\"id\" href=\"#spi_device\">spi_device</a> *<a class=\"id\" href=\"#spi\">spi</a>, struct <a class=\"id\" href=\"#spi_message\">spi_message</a> *<a class=\"id\" href=\"#message\">message</a>);", 
"extern int <a class=\"id\" href=\"#spi_sync_locked\">spi_sync_locked</a>(struct <a class=\"id\" href=\"#spi_device\">spi_device</a> *<a class=\"id\" href=\"#spi\">spi</a>, struct <a class=\"id\" href=\"#spi_message\">spi_message</a> *<a class=\"id\" href=\"#message\">message</a>);", 
"extern int <a class=\"id\" href=\"#spi_bus_lock\">spi_bus_lock</a>(struct <a class=\"id\" href=\"#spi_master\">spi_master</a> *<a class=\"id\" href=\"#master\">master</a>);", 
"extern int <a class=\"id\" href=\"#spi_bus_unlock\">spi_bus_unlock</a>(struct <a class=\"id\" href=\"#spi_master\">spi_master</a> *<a class=\"id\" href=\"#master\">master</a>);", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * spi_write - SPI synchronous write</span>", 
"<span class=\"comment\"> * @spi: device to which data will be written</span>", 
"<span class=\"comment\"> * @buf: data buffer</span>", 
"<span class=\"comment\"> * @len: data buffer size</span>", 
"<span class=\"comment\"> * Context: can sleep</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * This writes the buffer and returns zero or a negative error code.</span>", 
"<span class=\"comment\"> * Callable only from contexts that can sleep.</span>", 
"<span class=\"comment\"> */</span>", 
"static <a class=\"id\" href=\"#inline\">inline</a> int", 
"<a class=\"id\" href=\"#spi_write\">spi_write</a>(struct <a class=\"id\" href=\"#spi_device\">spi_device</a> *<a class=\"id\" href=\"#spi\">spi</a>, const <a class=\"id\" href=\"#u8\">u8</a> *<a class=\"id\" href=\"#buf\">buf</a>, <a class=\"id\" href=\"#size_t\">size_t</a> <a class=\"id\" href=\"#len\">len</a>)", 
"{", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#spi_transfer\">spi_transfer</a><span class=\"ts\"/><a class=\"id\" href=\"#t\">t</a> = {", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>.<a class=\"id\" href=\"#tx_buf\">tx_buf</a><span class=\"ts\"/><span class=\"ts\"/>= <a class=\"id\" href=\"#buf\">buf</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>.<a class=\"id\" href=\"#len\">len</a><span class=\"ts\"/><span class=\"ts\"/>= <a class=\"id\" href=\"#len\">len</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/>};", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#spi_message\">spi_message</a><span class=\"ts\"/><a class=\"id\" href=\"#m\">m</a>;", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#spi_message_init\">spi_message_init</a>(&amp;<a class=\"id\" href=\"#m\">m</a>);", 
"<span class=\"ts\"/><a class=\"id\" href=\"#spi_message_add_tail\">spi_message_add_tail</a>(&amp;<a class=\"id\" href=\"#t\">t</a>, &amp;<a class=\"id\" href=\"#m\">m</a>);", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#spi_sync\">spi_sync</a>(<a class=\"id\" href=\"#spi\">spi</a>, &amp;<a class=\"id\" href=\"#m\">m</a>);", 
"}", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * spi_read - SPI synchronous read</span>", 
"<span class=\"comment\"> * @spi: device from which data will be read</span>", 
"<span class=\"comment\"> * @buf: data buffer</span>", 
"<span class=\"comment\"> * @len: data buffer size</span>", 
"<span class=\"comment\"> * Context: can sleep</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * This reads the buffer and returns zero or a negative error code.</span>", 
"<span class=\"comment\"> * Callable only from contexts that can sleep.</span>", 
"<span class=\"comment\"> */</span>", 
"static <a class=\"id\" href=\"#inline\">inline</a> int", 
"<a class=\"id\" href=\"#spi_read\">spi_read</a>(struct <a class=\"id\" href=\"#spi_device\">spi_device</a> *<a class=\"id\" href=\"#spi\">spi</a>, <a class=\"id\" href=\"#u8\">u8</a> *<a class=\"id\" href=\"#buf\">buf</a>, <a class=\"id\" href=\"#size_t\">size_t</a> <a class=\"id\" href=\"#len\">len</a>)", 
"{", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#spi_transfer\">spi_transfer</a><span class=\"ts\"/><a class=\"id\" href=\"#t\">t</a> = {", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>.<a class=\"id\" href=\"#rx_buf\">rx_buf</a><span class=\"ts\"/><span class=\"ts\"/>= <a class=\"id\" href=\"#buf\">buf</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>.<a class=\"id\" href=\"#len\">len</a><span class=\"ts\"/><span class=\"ts\"/>= <a class=\"id\" href=\"#len\">len</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/>};", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#spi_message\">spi_message</a><span class=\"ts\"/><a class=\"id\" href=\"#m\">m</a>;", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#spi_message_init\">spi_message_init</a>(&amp;<a class=\"id\" href=\"#m\">m</a>);", 
"<span class=\"ts\"/><a class=\"id\" href=\"#spi_message_add_tail\">spi_message_add_tail</a>(&amp;<a class=\"id\" href=\"#t\">t</a>, &amp;<a class=\"id\" href=\"#m\">m</a>);", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#spi_sync\">spi_sync</a>(<a class=\"id\" href=\"#spi\">spi</a>, &amp;<a class=\"id\" href=\"#m\">m</a>);", 
"}", 
"", 
"<span class=\"comment\">/* this copies txbuf and rxbuf data; for small transfers only! */</span>", 
"extern int <a class=\"id\" href=\"#spi_write_then_read\">spi_write_then_read</a>(struct <a class=\"id\" href=\"#spi_device\">spi_device</a> *<a class=\"id\" href=\"#spi\">spi</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/>const <a class=\"id\" href=\"#u8\">u8</a> *<a class=\"id\" href=\"#txbuf\">txbuf</a>, unsigned <a class=\"id\" href=\"#n_tx\">n_tx</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#u8\">u8</a> *<a class=\"id\" href=\"#rxbuf\">rxbuf</a>, unsigned <a class=\"id\" href=\"#n_rx\">n_rx</a>);", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * spi_w8r8 - SPI synchronous 8 bit write followed by 8 bit read</span>", 
"<span class=\"comment\"> * @spi: device with which data will be exchanged</span>", 
"<span class=\"comment\"> * @cmd: command to be written before data is read back</span>", 
"<span class=\"comment\"> * Context: can sleep</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * This returns the (unsigned) eight bit number returned by the</span>", 
"<span class=\"comment\"> * device, or else a negative error code.  Callable only from</span>", 
"<span class=\"comment\"> * contexts that can sleep.</span>", 
"<span class=\"comment\"> */</span>", 
"static <a class=\"id\" href=\"#inline\">inline</a> <a class=\"id\" href=\"#ssize_t\">ssize_t</a> <a class=\"id\" href=\"#spi_w8r8\">spi_w8r8</a>(struct <a class=\"id\" href=\"#spi_device\">spi_device</a> *<a class=\"id\" href=\"#spi\">spi</a>, <a class=\"id\" href=\"#u8\">u8</a> <a class=\"id\" href=\"#cmd\">cmd</a>)", 
"{", 
"<span class=\"ts\"/><a class=\"id\" href=\"#ssize_t\">ssize_t</a><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#status\">status</a>;", 
"<span class=\"ts\"/><a class=\"id\" href=\"#u8\">u8</a><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#result\">result</a>;", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#status\">status</a> = <a class=\"id\" href=\"#spi_write_then_read\">spi_write_then_read</a>(<a class=\"id\" href=\"#spi\">spi</a>, &amp;<a class=\"id\" href=\"#cmd\">cmd</a>, 1, &amp;<a class=\"id\" href=\"#result\">result</a>, 1);", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/* return negative errno or unsigned value */</span>", 
"<span class=\"ts\"/>return (<a class=\"id\" href=\"#status\">status</a> &lt; 0) ? <a class=\"id\" href=\"#status\">status</a> : <a class=\"id\" href=\"#result\">result</a>;", 
"}", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * spi_w8r16 - SPI synchronous 8 bit write followed by 16 bit read</span>", 
"<span class=\"comment\"> * @spi: device with which data will be exchanged</span>", 
"<span class=\"comment\"> * @cmd: command to be written before data is read back</span>", 
"<span class=\"comment\"> * Context: can sleep</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * This returns the (unsigned) sixteen bit number returned by the</span>", 
"<span class=\"comment\"> * device, or else a negative error code.  Callable only from</span>", 
"<span class=\"comment\"> * contexts that can sleep.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * The number is returned in wire-order, which is at least sometimes</span>", 
"<span class=\"comment\"> * big-endian.</span>", 
"<span class=\"comment\"> */</span>", 
"static <a class=\"id\" href=\"#inline\">inline</a> <a class=\"id\" href=\"#ssize_t\">ssize_t</a> <a class=\"id\" href=\"#spi_w8r16\">spi_w8r16</a>(struct <a class=\"id\" href=\"#spi_device\">spi_device</a> *<a class=\"id\" href=\"#spi\">spi</a>, <a class=\"id\" href=\"#u8\">u8</a> <a class=\"id\" href=\"#cmd\">cmd</a>)", 
"{", 
"<span class=\"ts\"/><a class=\"id\" href=\"#ssize_t\">ssize_t</a><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#status\">status</a>;", 
"<span class=\"ts\"/><a class=\"id\" href=\"#u16\">u16</a><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#result\">result</a>;", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#status\">status</a> = <a class=\"id\" href=\"#spi_write_then_read\">spi_write_then_read</a>(<a class=\"id\" href=\"#spi\">spi</a>, &amp;<a class=\"id\" href=\"#cmd\">cmd</a>, 1, (<a class=\"id\" href=\"#u8\">u8</a> *) &amp;<a class=\"id\" href=\"#result\">result</a>, 2);", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/* return negative errno or unsigned value */</span>", 
"<span class=\"ts\"/>return (<a class=\"id\" href=\"#status\">status</a> &lt; 0) ? <a class=\"id\" href=\"#status\">status</a> : <a class=\"id\" href=\"#result\">result</a>;", 
"}", 
"", 
"<span class=\"comment\">/*---------------------------------------------------------------------------*/</span>", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * INTERFACE between board init code and SPI infrastructure.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * No SPI driver ever sees these SPI device table segments, but</span>", 
"<span class=\"comment\"> * it's how the SPI core (or adapters that get hotplugged) grows</span>", 
"<span class=\"comment\"> * the driver model tree.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * As a rule, SPI devices can't be probed.  Instead, board init code</span>", 
"<span class=\"comment\"> * provides a table listing the devices which are present, with enough</span>", 
"<span class=\"comment\"> * information to bind and set up the device's driver.  There's basic</span>", 
"<span class=\"comment\"> * support for nonstatic configurations too; enough to handle adding</span>", 
"<span class=\"comment\"> * parport adapters, or microcontrollers acting as USB-to-SPI bridges.</span>", 
"<span class=\"comment\"> */</span>", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * struct spi_board_info - board-specific template for a SPI device</span>", 
"<span class=\"comment\"> * @modalias: Initializes spi_device.modalias; identifies the driver.</span>", 
"<span class=\"comment\"> * @platform_data: Initializes spi_device.platform_data; the particular</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>data stored there is driver-specific.</span>", 
"<span class=\"comment\"> * @controller_data: Initializes spi_device.controller_data; some</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>controllers need hints about hardware setup, e.g. for DMA.</span>", 
"<span class=\"comment\"> * @irq: Initializes spi_device.irq; depends on how the board is wired.</span>", 
"<span class=\"comment\"> * @max_speed_hz: Initializes spi_device.max_speed_hz; based on limits</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>from the chip datasheet and board-specific signal quality issues.</span>", 
"<span class=\"comment\"> * @bus_num: Identifies which spi_master parents the spi_device; unused</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>by spi_new_device(), and otherwise depends on board wiring.</span>", 
"<span class=\"comment\"> * @chip_select: Initializes spi_device.chip_select; depends on how</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>the board is wired.</span>", 
"<span class=\"comment\"> * @mode: Initializes spi_device.mode; based on the chip datasheet, board</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>wiring (some devices support both 3WIRE and standard modes), and</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>possibly presence of an inverter in the chipselect path.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * When adding new SPI devices to the device tree, these structures serve</span>", 
"<span class=\"comment\"> * as a partial device template.  They hold information which can't always</span>", 
"<span class=\"comment\"> * be determined by drivers.  Information that probe() can establish (such</span>", 
"<span class=\"comment\"> * as the default transfer wordsize) is not included here.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * These structures are used in two places.  Their primary role is to</span>", 
"<span class=\"comment\"> * be stored in tables of board-specific device descriptors, which are</span>", 
"<span class=\"comment\"> * declared early in board initialization and then used (much later) to</span>", 
"<span class=\"comment\"> * populate a controller's device tree after the that controller's driver</span>", 
"<span class=\"comment\"> * initializes.  A secondary (and atypical) role is as a parameter to</span>", 
"<span class=\"comment\"> * spi_new_device() call, which happens after those controller drivers</span>", 
"<span class=\"comment\"> * are active in some dynamic board configuration models.</span>", 
"<span class=\"comment\"> */</span>", 
"struct <a class=\"id\" href=\"#spi_board_info\">spi_board_info</a> {", 
"<span class=\"ts\"/><span class=\"comment\">/* the device name and module name are coupled, like platform_bus;</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * \"modalias\" is normally the driver name.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * platform_data goes to spi_device.dev.platform_data,</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * controller_data goes to spi_device.controller_data,</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * irq is copied too</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>char<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#modalias\">modalias</a>[<a class=\"id\" href=\"#SPI_NAME_SIZE\">SPI_NAME_SIZE</a>];", 
"<span class=\"ts\"/>const void<span class=\"ts\"/>*<a class=\"id\" href=\"#platform_data\">platform_data</a>;", 
"<span class=\"ts\"/>void<span class=\"ts\"/><span class=\"ts\"/>*<a class=\"id\" href=\"#controller_data\">controller_data</a>;", 
"<span class=\"ts\"/>int<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#irq\">irq</a>;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/* slower signaling on noisy or low voltage boards */</span>", 
"<span class=\"ts\"/><a class=\"id\" href=\"#u32\">u32</a><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#max_speed_hz\">max_speed_hz</a>;", 
"", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/* bus_num is board specific and matches the bus_num of some</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * spi_master that will probably be registered later.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * chip_select reflects how this chip is wired to that master;</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * it's less than num_chipselect.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/><a class=\"id\" href=\"#u16\">u16</a><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#bus_num\">bus_num</a>;", 
"<span class=\"ts\"/><a class=\"id\" href=\"#u16\">u16</a><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#chip_select\">chip_select</a>;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/* mode becomes spi_device.mode, and is essential for chips</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * where the default of SPI_CS_HIGH = 0 is wrong.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/><a class=\"id\" href=\"#u8\">u8</a><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#mode\">mode</a>;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/* ... may need additional spi_device chip config data here.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * avoid stuff protocol drivers can set; but include stuff</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * needed to behave without being bound to a driver:</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *  - quirks like clock rate mattering when not selected</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"};", 
"", 
"#<a class=\"id\" href=\"#ifdef\">ifdef</a><span class=\"ts\"/><a class=\"id\" href=\"#CONFIG_SPI\">CONFIG_SPI</a>", 
"extern int", 
"<a class=\"id\" href=\"#spi_register_board_info\">spi_register_board_info</a>(struct <a class=\"id\" href=\"#spi_board_info\">spi_board_info</a> const *<a class=\"id\" href=\"#info\">info</a>, unsigned <a class=\"id\" href=\"#n\">n</a>);", 
"#else", 
"<span class=\"comment\">/* board init code may ignore whether SPI is configured or not */</span>", 
"static <a class=\"id\" href=\"#inline\">inline</a> int", 
"<a class=\"id\" href=\"#spi_register_board_info\">spi_register_board_info</a>(struct <a class=\"id\" href=\"#spi_board_info\">spi_board_info</a> const *<a class=\"id\" href=\"#info\">info</a>, unsigned <a class=\"id\" href=\"#n\">n</a>)", 
"<span class=\"ts\"/>{ return 0; }", 
"#<a class=\"id\" href=\"#endif\">endif</a>", 
"", 
"", 
"<span class=\"comment\">/* If you're hotplugging an adapter with devices (parport, usb, etc)</span>", 
"<span class=\"comment\"> * use spi_new_device() to describe each device.  You can also call</span>", 
"<span class=\"comment\"> * spi_unregister_device() to start making that device vanish, but</span>", 
"<span class=\"comment\"> * normally that would be handled by spi_unregister_master().</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * You can also use spi_alloc_device() and spi_add_device() to use a two</span>", 
"<span class=\"comment\"> * stage registration sequence for each spi_device.  This gives the caller</span>", 
"<span class=\"comment\"> * some more control over the spi_device structure before it is registered,</span>", 
"<span class=\"comment\"> * but requires that caller to initialize fields that would otherwise</span>", 
"<span class=\"comment\"> * be defined using the board info.</span>", 
"<span class=\"comment\"> */</span>", 
"extern struct <a class=\"id\" href=\"#spi_device\">spi_device</a> *", 
"<a class=\"id\" href=\"#spi_alloc_device\">spi_alloc_device</a>(struct <a class=\"id\" href=\"#spi_master\">spi_master</a> *<a class=\"id\" href=\"#master\">master</a>);", 
"", 
"extern int", 
"<a class=\"id\" href=\"#spi_add_device\">spi_add_device</a>(struct <a class=\"id\" href=\"#spi_device\">spi_device</a> *<a class=\"id\" href=\"#spi\">spi</a>);", 
"", 
"extern struct <a class=\"id\" href=\"#spi_device\">spi_device</a> *", 
"<a class=\"id\" href=\"#spi_new_device\">spi_new_device</a>(struct <a class=\"id\" href=\"#spi_master\">spi_master</a> *, struct <a class=\"id\" href=\"#spi_board_info\">spi_board_info</a> *);", 
"", 
"static <a class=\"id\" href=\"#inline\">inline</a> void", 
"<a class=\"id\" href=\"#spi_unregister_device\">spi_unregister_device</a>(struct <a class=\"id\" href=\"#spi_device\">spi_device</a> *<a class=\"id\" href=\"#spi\">spi</a>)", 
"{", 
"<span class=\"ts\"/>if (<a class=\"id\" href=\"#spi\">spi</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#device_unregister\">device_unregister</a>(&amp;<a class=\"id\" href=\"#spi\">spi</a>-><a class=\"id\" href=\"#dev\">dev</a>);", 
"}", 
"", 
"extern const struct <a class=\"id\" href=\"#spi_device_id\">spi_device_id</a> *", 
"<a class=\"id\" href=\"#spi_get_device_id\">spi_get_device_id</a>(const struct <a class=\"id\" href=\"#spi_device\">spi_device</a> *<a class=\"id\" href=\"#sdev\">sdev</a>);", 
"", 
"#<a class=\"id\" href=\"#endif\">endif</a> <span class=\"comment\">/* __LINUX_SPI_H */</span>", 
];
xr_frag_insert('l/92/9c610239a061a72e782b01876fd38b839863cc.xr', __xr_tmp);
