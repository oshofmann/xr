var __xr_tmp = [
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * Tracing hooks</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Copyright (C) 2008-2009 Red Hat, Inc.  All rights reserved.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * This copyrighted material is made available to anyone wishing to use,</span>", 
"<span class=\"comment\"> * modify, copy, or redistribute it subject to the terms and conditions</span>", 
"<span class=\"comment\"> * of the GNU General Public License v.2.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * This file defines hook entry points called by core code where</span>", 
"<span class=\"comment\"> * user tracing/debugging support might need to do something.  These</span>", 
"<span class=\"comment\"> * entry points are called tracehook_*().  Each hook declared below</span>", 
"<span class=\"comment\"> * has a detailed kerneldoc comment giving the context (locking et</span>", 
"<span class=\"comment\"> * al) from which it is called, and the meaning of its return value.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Each function here typically has only one call site, so it is ok</span>", 
"<span class=\"comment\"> * to have some nontrivial tracehook_*() inlines.  In all cases, the</span>", 
"<span class=\"comment\"> * fast path when no tracing is enabled should be very short.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * The purpose of this file and the tracehook_* layer is to consolidate</span>", 
"<span class=\"comment\"> * the interface that the kernel core and arch code uses to enable any</span>", 
"<span class=\"comment\"> * user debugging or tracing facility (such as ptrace).  The interfaces</span>", 
"<span class=\"comment\"> * here are carefully documented so that maintainers of core and arch</span>", 
"<span class=\"comment\"> * code do not need to think about the implementation details of the</span>", 
"<span class=\"comment\"> * tracing facilities.  Likewise, maintainers of the tracing code do not</span>", 
"<span class=\"comment\"> * need to understand all the calling core or arch code in detail, just</span>", 
"<span class=\"comment\"> * documented circumstances of each call, such as locking conditions.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * If the calling core code changes so that locking is different, then</span>", 
"<span class=\"comment\"> * it is ok to change the interface documented here.  The maintainer of</span>", 
"<span class=\"comment\"> * core code changing should notify the maintainers of the tracing code</span>", 
"<span class=\"comment\"> * that they need to work out the change.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Some tracehook_*() inlines take arguments that the current tracing</span>", 
"<span class=\"comment\"> * implementations might not necessarily use.  These function signatures</span>", 
"<span class=\"comment\"> * are chosen to pass in all the information that is on hand in the</span>", 
"<span class=\"comment\"> * caller and might conceivably be relevant to a tracer, so that the</span>", 
"<span class=\"comment\"> * core code won't have to be updated when tracing adds more features.</span>", 
"<span class=\"comment\"> * If a call site changes so that some of those parameters are no longer</span>", 
"<span class=\"comment\"> * already on hand without extra work, then the tracehook_* interface</span>", 
"<span class=\"comment\"> * can change so there is no make-work burden on the core code.  The</span>", 
"<span class=\"comment\"> * maintainer of core code changing should notify the maintainers of the</span>", 
"<span class=\"comment\"> * tracing code that they need to work out the change.</span>", 
"<span class=\"comment\"> */</span>", 
"", 
"#<a class=\"id\" href=\"#ifndef\">ifndef</a> <a class=\"id\" href=\"#_LINUX_TRACEHOOK_H\">_LINUX_TRACEHOOK_H</a>", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#_LINUX_TRACEHOOK_H\">_LINUX_TRACEHOOK_H</a><span class=\"ts\"/>1", 
"", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#sched\">sched</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#ptrace\">ptrace</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#security\">security</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"struct <a class=\"id\" href=\"#linux_binprm\">linux_binprm</a>;", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * tracehook_expect_breakpoints - guess if task memory might be touched</span>", 
"<span class=\"comment\"> * @task:<span class=\"ts\"/><span class=\"ts\"/>current task, making a new mapping</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Return nonzero if @task is expected to want breakpoint insertion in</span>", 
"<span class=\"comment\"> * its memory at some point.  A zero return is no guarantee it won't</span>", 
"<span class=\"comment\"> * be done, but this is a hint that it's known to be likely.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * May be called with @task-&gt;mm-&gt;mmap_sem held for writing.</span>", 
"<span class=\"comment\"> */</span>", 
"static <a class=\"id\" href=\"#inline\">inline</a> int <a class=\"id\" href=\"#tracehook_expect_breakpoints\">tracehook_expect_breakpoints</a>(struct <a class=\"id\" href=\"#task_struct\">task_struct</a> *<a class=\"id\" href=\"#task\">task</a>)", 
"{", 
"<span class=\"ts\"/>return (<a class=\"id\" href=\"#task_ptrace\">task_ptrace</a>(<a class=\"id\" href=\"#task\">task</a>) &amp; <a class=\"id\" href=\"#PT_PTRACED\">PT_PTRACED</a>) != 0;", 
"}", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * ptrace report for syscall entry and exit looks identical.</span>", 
"<span class=\"comment\"> */</span>", 
"static <a class=\"id\" href=\"#inline\">inline</a> void <a class=\"id\" href=\"#ptrace_report_syscall\">ptrace_report_syscall</a>(struct <a class=\"id\" href=\"#pt_regs\">pt_regs</a> *<a class=\"id\" href=\"#regs\">regs</a>)", 
"{", 
"<span class=\"ts\"/>int <a class=\"id\" href=\"#ptrace\">ptrace</a> = <a class=\"id\" href=\"#task_ptrace\">task_ptrace</a>(<a class=\"id\" href=\"#current\">current</a>);", 
"", 
"<span class=\"ts\"/>if (!(<a class=\"id\" href=\"#ptrace\">ptrace</a> &amp; <a class=\"id\" href=\"#PT_PTRACED\">PT_PTRACED</a>))", 
"<span class=\"ts\"/><span class=\"ts\"/>return;", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#ptrace_notify\">ptrace_notify</a>(<a class=\"id\" href=\"#SIGTRAP\">SIGTRAP</a> | ((<a class=\"id\" href=\"#ptrace\">ptrace</a> &amp; <a class=\"id\" href=\"#PT_TRACESYSGOOD\">PT_TRACESYSGOOD</a>) ? 0x80 : 0));", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * this isn't the same as continuing with a signal, but it will do</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * for normal use.  strace only continues with a signal if the</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * stopping signal is not SIGTRAP.  -brl</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>if (<a class=\"id\" href=\"#current\">current</a>-><a class=\"id\" href=\"#exit_code\">exit_code</a>) {", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#send_sig\">send_sig</a>(<a class=\"id\" href=\"#current\">current</a>-><a class=\"id\" href=\"#exit_code\">exit_code</a>, <a class=\"id\" href=\"#current\">current</a>, 1);", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#current\">current</a>-><a class=\"id\" href=\"#exit_code\">exit_code</a> = 0;", 
"<span class=\"ts\"/>}", 
"}", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * tracehook_report_syscall_entry - task is about to attempt a system call</span>", 
"<span class=\"comment\"> * @regs:<span class=\"ts\"/><span class=\"ts\"/>user register state of current task</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * This will be called if %TIF_SYSCALL_TRACE has been set, when the</span>", 
"<span class=\"comment\"> * current task has just entered the kernel for a system call.</span>", 
"<span class=\"comment\"> * Full user register state is available here.  Changing the values</span>", 
"<span class=\"comment\"> * in @regs can affect the system call number and arguments to be tried.</span>", 
"<span class=\"comment\"> * It is safe to block here, preventing the system call from beginning.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Returns zero normally, or nonzero if the calling arch code should abort</span>", 
"<span class=\"comment\"> * the system call.  That must prevent normal entry so no system call is</span>", 
"<span class=\"comment\"> * made.  If @task ever returns to user mode after this, its register state</span>", 
"<span class=\"comment\"> * is unspecified, but should be something harmless like an %ENOSYS error</span>", 
"<span class=\"comment\"> * return.  It should preserve enough information so that syscall_rollback()</span>", 
"<span class=\"comment\"> * can work (see asm-generic/syscall.h).</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Called without locks, just after entering kernel mode.</span>", 
"<span class=\"comment\"> */</span>", 
"static <a class=\"id\" href=\"#inline\">inline</a> <a class=\"id\" href=\"#__must_check\">__must_check</a> int <a class=\"id\" href=\"#tracehook_report_syscall_entry\">tracehook_report_syscall_entry</a>(", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#pt_regs\">pt_regs</a> *<a class=\"id\" href=\"#regs\">regs</a>)", 
"{", 
"<span class=\"ts\"/><a class=\"id\" href=\"#ptrace_report_syscall\">ptrace_report_syscall</a>(<a class=\"id\" href=\"#regs\">regs</a>);", 
"<span class=\"ts\"/>return 0;", 
"}", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * tracehook_report_syscall_exit - task has just finished a system call</span>", 
"<span class=\"comment\"> * @regs:<span class=\"ts\"/><span class=\"ts\"/>user register state of current task</span>", 
"<span class=\"comment\"> * @step:<span class=\"ts\"/><span class=\"ts\"/>nonzero if simulating single-step or block-step</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * This will be called if %TIF_SYSCALL_TRACE has been set, when the</span>", 
"<span class=\"comment\"> * current task has just finished an attempted system call.  Full</span>", 
"<span class=\"comment\"> * user register state is available here.  It is safe to block here,</span>", 
"<span class=\"comment\"> * preventing signals from being processed.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * If @step is nonzero, this report is also in lieu of the normal</span>", 
"<span class=\"comment\"> * trap that would follow the system call instruction because</span>", 
"<span class=\"comment\"> * user_enable_block_step() or user_enable_single_step() was used.</span>", 
"<span class=\"comment\"> * In this case, %TIF_SYSCALL_TRACE might not be set.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Called without locks, just before checking for pending signals.</span>", 
"<span class=\"comment\"> */</span>", 
"static <a class=\"id\" href=\"#inline\">inline</a> void <a class=\"id\" href=\"#tracehook_report_syscall_exit\">tracehook_report_syscall_exit</a>(struct <a class=\"id\" href=\"#pt_regs\">pt_regs</a> *<a class=\"id\" href=\"#regs\">regs</a>, int <a class=\"id\" href=\"#step\">step</a>)", 
"{", 
"<span class=\"ts\"/>if (<a class=\"id\" href=\"#step\">step</a>) {", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#siginfo_t\">siginfo_t</a> <a class=\"id\" href=\"#info\">info</a>;", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#user_single_step_siginfo\">user_single_step_siginfo</a>(<a class=\"id\" href=\"#current\">current</a>, <a class=\"id\" href=\"#regs\">regs</a>, &amp;<a class=\"id\" href=\"#info\">info</a>);", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#force_sig_info\">force_sig_info</a>(<a class=\"id\" href=\"#SIGTRAP\">SIGTRAP</a>, &amp;<a class=\"id\" href=\"#info\">info</a>, <a class=\"id\" href=\"#current\">current</a>);", 
"<span class=\"ts\"/><span class=\"ts\"/>return;", 
"<span class=\"ts\"/>}", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#ptrace_report_syscall\">ptrace_report_syscall</a>(<a class=\"id\" href=\"#regs\">regs</a>);", 
"}", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * tracehook_unsafe_exec - check for exec declared unsafe due to tracing</span>", 
"<span class=\"comment\"> * @task:<span class=\"ts\"/><span class=\"ts\"/>current task doing exec</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Return %LSM_UNSAFE_* bits applied to an exec because of tracing.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * @task-&gt;cred_guard_mutex is held by the caller through the do_execve().</span>", 
"<span class=\"comment\"> */</span>", 
"static <a class=\"id\" href=\"#inline\">inline</a> int <a class=\"id\" href=\"#tracehook_unsafe_exec\">tracehook_unsafe_exec</a>(struct <a class=\"id\" href=\"#task_struct\">task_struct</a> *<a class=\"id\" href=\"#task\">task</a>)", 
"{", 
"<span class=\"ts\"/>int <a class=\"id\" href=\"#unsafe\">unsafe</a> = 0;", 
"<span class=\"ts\"/>int <a class=\"id\" href=\"#ptrace\">ptrace</a> = <a class=\"id\" href=\"#task_ptrace\">task_ptrace</a>(<a class=\"id\" href=\"#task\">task</a>);", 
"<span class=\"ts\"/>if (<a class=\"id\" href=\"#ptrace\">ptrace</a> &amp; <a class=\"id\" href=\"#PT_PTRACED\">PT_PTRACED</a>) {", 
"<span class=\"ts\"/><span class=\"ts\"/>if (<a class=\"id\" href=\"#ptrace\">ptrace</a> &amp; <a class=\"id\" href=\"#PT_PTRACE_CAP\">PT_PTRACE_CAP</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#unsafe\">unsafe</a> |= <a class=\"id\" href=\"#LSM_UNSAFE_PTRACE_CAP\">LSM_UNSAFE_PTRACE_CAP</a>;", 
"<span class=\"ts\"/><span class=\"ts\"/>else", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#unsafe\">unsafe</a> |= <a class=\"id\" href=\"#LSM_UNSAFE_PTRACE\">LSM_UNSAFE_PTRACE</a>;", 
"<span class=\"ts\"/>}", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#unsafe\">unsafe</a>;", 
"}", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * tracehook_tracer_task - return the task that is tracing the given task</span>", 
"<span class=\"comment\"> * @tsk:<span class=\"ts\"/><span class=\"ts\"/>task to consider</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Returns NULL if noone is tracing @task, or the &amp;struct task_struct</span>", 
"<span class=\"comment\"> * pointer to its tracer.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Must called under rcu_read_lock().  The pointer returned might be kept</span>", 
"<span class=\"comment\"> * live only by RCU.  During exec, this may be called with task_lock()</span>", 
"<span class=\"comment\"> * held on @task, still held from when tracehook_unsafe_exec() was called.</span>", 
"<span class=\"comment\"> */</span>", 
"static <a class=\"id\" href=\"#inline\">inline</a> struct <a class=\"id\" href=\"#task_struct\">task_struct</a> *<a class=\"id\" href=\"#tracehook_tracer_task\">tracehook_tracer_task</a>(struct <a class=\"id\" href=\"#task_struct\">task_struct</a> *<a class=\"id\" href=\"#tsk\">tsk</a>)", 
"{", 
"<span class=\"ts\"/>if (<a class=\"id\" href=\"#task_ptrace\">task_ptrace</a>(<a class=\"id\" href=\"#tsk\">tsk</a>) &amp; <a class=\"id\" href=\"#PT_PTRACED\">PT_PTRACED</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/>return <a class=\"id\" href=\"#rcu_dereference\">rcu_dereference</a>(<a class=\"id\" href=\"#tsk\">tsk</a>-><a class=\"id\" href=\"#parent\">parent</a>);", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#NULL\">NULL</a>;", 
"}", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * tracehook_report_exec - a successful exec was completed</span>", 
"<span class=\"comment\"> * @fmt:<span class=\"ts\"/><span class=\"ts\"/>&amp;struct linux_binfmt that performed the exec</span>", 
"<span class=\"comment\"> * @bprm:<span class=\"ts\"/><span class=\"ts\"/>&amp;struct linux_binprm containing exec details</span>", 
"<span class=\"comment\"> * @regs:<span class=\"ts\"/><span class=\"ts\"/>user-mode register state</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * An exec just completed, we are shortly going to return to user mode.</span>", 
"<span class=\"comment\"> * The freshly initialized register state can be seen and changed in @regs.</span>", 
"<span class=\"comment\"> * The name, file and other pointers in @bprm are still on hand to be</span>", 
"<span class=\"comment\"> * inspected, but will be freed as soon as this returns.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Called with no locks, but with some kernel resources held live</span>", 
"<span class=\"comment\"> * and a reference on @fmt-&gt;module.</span>", 
"<span class=\"comment\"> */</span>", 
"static <a class=\"id\" href=\"#inline\">inline</a> void <a class=\"id\" href=\"#tracehook_report_exec\">tracehook_report_exec</a>(struct <a class=\"id\" href=\"#linux_binfmt\">linux_binfmt</a> *<a class=\"id\" href=\"#fmt\">fmt</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/> struct <a class=\"id\" href=\"#linux_binprm\">linux_binprm</a> *<a class=\"id\" href=\"#bprm\">bprm</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/> struct <a class=\"id\" href=\"#pt_regs\">pt_regs</a> *<a class=\"id\" href=\"#regs\">regs</a>)", 
"{", 
"<span class=\"ts\"/>if (!<a class=\"id\" href=\"#ptrace_event\">ptrace_event</a>(<a class=\"id\" href=\"#PT_TRACE_EXEC\">PT_TRACE_EXEC</a>, <a class=\"id\" href=\"#PTRACE_EVENT_EXEC\">PTRACE_EVENT_EXEC</a>, 0) &&", 
"<span class=\"ts\"/>    <a class=\"id\" href=\"#unlikely\">unlikely</a>(<a class=\"id\" href=\"#task_ptrace\">task_ptrace</a>(<a class=\"id\" href=\"#current\">current</a>) &amp; <a class=\"id\" href=\"#PT_PTRACED\">PT_PTRACED</a>))", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#send_sig\">send_sig</a>(<a class=\"id\" href=\"#SIGTRAP\">SIGTRAP</a>, <a class=\"id\" href=\"#current\">current</a>, 0);", 
"}", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * tracehook_report_exit - task has begun to exit</span>", 
"<span class=\"comment\"> * @exit_code:<span class=\"ts\"/><span class=\"ts\"/>pointer to value destined for @current-&gt;exit_code</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * @exit_code points to the value passed to do_exit(), which tracing</span>", 
"<span class=\"comment\"> * might change here.  This is almost the first thing in do_exit(),</span>", 
"<span class=\"comment\"> * before freeing any resources or setting the %PF_EXITING flag.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Called with no locks held.</span>", 
"<span class=\"comment\"> */</span>", 
"static <a class=\"id\" href=\"#inline\">inline</a> void <a class=\"id\" href=\"#tracehook_report_exit\">tracehook_report_exit</a>(long *<a class=\"id\" href=\"#exit_code\">exit_code</a>)", 
"{", 
"<span class=\"ts\"/><a class=\"id\" href=\"#ptrace_event\">ptrace_event</a>(<a class=\"id\" href=\"#PT_TRACE_EXIT\">PT_TRACE_EXIT</a>, <a class=\"id\" href=\"#PTRACE_EVENT_EXIT\">PTRACE_EVENT_EXIT</a>, *<a class=\"id\" href=\"#exit_code\">exit_code</a>);", 
"}", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * tracehook_prepare_clone - prepare for new child to be cloned</span>", 
"<span class=\"comment\"> * @clone_flags:<span class=\"ts\"/>%CLONE_* flags from clone/fork/vfork system call</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * This is called before a new user task is to be cloned.</span>", 
"<span class=\"comment\"> * Its return value will be passed to tracehook_finish_clone().</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Called with no locks held.</span>", 
"<span class=\"comment\"> */</span>", 
"static <a class=\"id\" href=\"#inline\">inline</a> int <a class=\"id\" href=\"#tracehook_prepare_clone\">tracehook_prepare_clone</a>(unsigned <a class=\"id\" href=\"#clone_flags\">clone_flags</a>)", 
"{", 
"<span class=\"ts\"/>if (<a class=\"id\" href=\"#clone_flags\">clone_flags</a> &amp; <a class=\"id\" href=\"#CLONE_UNTRACED\">CLONE_UNTRACED</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/>return 0;", 
"", 
"<span class=\"ts\"/>if (<a class=\"id\" href=\"#clone_flags\">clone_flags</a> &amp; <a class=\"id\" href=\"#CLONE_VFORK\">CLONE_VFORK</a>) {", 
"<span class=\"ts\"/><span class=\"ts\"/>if (<a class=\"id\" href=\"#current\">current</a>-><a class=\"id\" href=\"#ptrace\">ptrace</a> &amp; <a class=\"id\" href=\"#PT_TRACE_VFORK\">PT_TRACE_VFORK</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>return <a class=\"id\" href=\"#PTRACE_EVENT_VFORK\">PTRACE_EVENT_VFORK</a>;", 
"<span class=\"ts\"/>} else if ((<a class=\"id\" href=\"#clone_flags\">clone_flags</a> &amp; <a class=\"id\" href=\"#CSIGNAL\">CSIGNAL</a>) != <a class=\"id\" href=\"#SIGCHLD\">SIGCHLD</a>) {", 
"<span class=\"ts\"/><span class=\"ts\"/>if (<a class=\"id\" href=\"#current\">current</a>-><a class=\"id\" href=\"#ptrace\">ptrace</a> &amp; <a class=\"id\" href=\"#PT_TRACE_CLONE\">PT_TRACE_CLONE</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>return <a class=\"id\" href=\"#PTRACE_EVENT_CLONE\">PTRACE_EVENT_CLONE</a>;", 
"<span class=\"ts\"/>} else if (<a class=\"id\" href=\"#current\">current</a>-><a class=\"id\" href=\"#ptrace\">ptrace</a> &amp; <a class=\"id\" href=\"#PT_TRACE_FORK\">PT_TRACE_FORK</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/>return <a class=\"id\" href=\"#PTRACE_EVENT_FORK\">PTRACE_EVENT_FORK</a>;", 
"", 
"<span class=\"ts\"/>return 0;", 
"}", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * tracehook_finish_clone - new child created and being attached</span>", 
"<span class=\"comment\"> * @child:<span class=\"ts\"/><span class=\"ts\"/>new child task</span>", 
"<span class=\"comment\"> * @clone_flags:<span class=\"ts\"/>%CLONE_* flags from clone/fork/vfork system call</span>", 
"<span class=\"comment\"> * @trace:<span class=\"ts\"/><span class=\"ts\"/>return value from tracehook_prepare_clone()</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * This is called immediately after adding @child to its parent's children list.</span>", 
"<span class=\"comment\"> * The @trace value is that returned by tracehook_prepare_clone().</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Called with current's siglock and write_lock_irq(&amp;tasklist_lock) held.</span>", 
"<span class=\"comment\"> */</span>", 
"static <a class=\"id\" href=\"#inline\">inline</a> void <a class=\"id\" href=\"#tracehook_finish_clone\">tracehook_finish_clone</a>(struct <a class=\"id\" href=\"#task_struct\">task_struct</a> *<a class=\"id\" href=\"#child\">child</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>  unsigned long <a class=\"id\" href=\"#clone_flags\">clone_flags</a>, int <a class=\"id\" href=\"#trace\">trace</a>)", 
"{", 
"<span class=\"ts\"/><a class=\"id\" href=\"#ptrace_init_task\">ptrace_init_task</a>(<a class=\"id\" href=\"#child\">child</a>, (<a class=\"id\" href=\"#clone_flags\">clone_flags</a> &amp; <a class=\"id\" href=\"#CLONE_PTRACE\">CLONE_PTRACE</a>) || <a class=\"id\" href=\"#trace\">trace</a>);", 
"}", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * tracehook_report_clone - in parent, new child is about to start running</span>", 
"<span class=\"comment\"> * @regs:<span class=\"ts\"/><span class=\"ts\"/>parent's user register state</span>", 
"<span class=\"comment\"> * @clone_flags:<span class=\"ts\"/>flags from parent's system call</span>", 
"<span class=\"comment\"> * @pid:<span class=\"ts\"/><span class=\"ts\"/>new child's PID in the parent's namespace</span>", 
"<span class=\"comment\"> * @child:<span class=\"ts\"/><span class=\"ts\"/>new child task</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Called after a child is set up, but before it has been started running.</span>", 
"<span class=\"comment\"> * This is not a good place to block, because the child has not started</span>", 
"<span class=\"comment\"> * yet.  Suspend the child here if desired, and then block in</span>", 
"<span class=\"comment\"> * tracehook_report_clone_complete().  This must prevent the child from</span>", 
"<span class=\"comment\"> * self-reaping if tracehook_report_clone_complete() uses the @child</span>", 
"<span class=\"comment\"> * pointer; otherwise it might have died and been released by the time</span>", 
"<span class=\"comment\"> * tracehook_report_clone_complete() is called.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Called with no locks held, but the child cannot run until this returns.</span>", 
"<span class=\"comment\"> */</span>", 
"static <a class=\"id\" href=\"#inline\">inline</a> void <a class=\"id\" href=\"#tracehook_report_clone\">tracehook_report_clone</a>(struct <a class=\"id\" href=\"#pt_regs\">pt_regs</a> *<a class=\"id\" href=\"#regs\">regs</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>  unsigned long <a class=\"id\" href=\"#clone_flags\">clone_flags</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>  <a class=\"id\" href=\"#pid_t\">pid_t</a> <a class=\"id\" href=\"#pid\">pid</a>, struct <a class=\"id\" href=\"#task_struct\">task_struct</a> *<a class=\"id\" href=\"#child\">child</a>)", 
"{", 
"<span class=\"ts\"/>if (<a class=\"id\" href=\"#unlikely\">unlikely</a>(<a class=\"id\" href=\"#task_ptrace\">task_ptrace</a>(<a class=\"id\" href=\"#child\">child</a>))) {", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/><span class=\"ts\"/> * It doesn't matter who attached/attaching to this</span>", 
"<span class=\"comment\"><span class=\"ts\"/><span class=\"ts\"/> * task, the pending SIGSTOP is right in any case.</span>", 
"<span class=\"comment\"><span class=\"ts\"/><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#sigaddset\">sigaddset</a>(&amp;<a class=\"id\" href=\"#child\">child</a>-><a class=\"id\" href=\"#pending\">pending</a>.<a class=\"id\" href=\"#signal\">signal</a>, <a class=\"id\" href=\"#SIGSTOP\">SIGSTOP</a>);", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#set_tsk_thread_flag\">set_tsk_thread_flag</a>(<a class=\"id\" href=\"#child\">child</a>, <a class=\"id\" href=\"#TIF_SIGPENDING\">TIF_SIGPENDING</a>);", 
"<span class=\"ts\"/>}", 
"}", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * tracehook_report_clone_complete - new child is running</span>", 
"<span class=\"comment\"> * @trace:<span class=\"ts\"/><span class=\"ts\"/>return value from tracehook_prepare_clone()</span>", 
"<span class=\"comment\"> * @regs:<span class=\"ts\"/><span class=\"ts\"/>parent's user register state</span>", 
"<span class=\"comment\"> * @clone_flags:<span class=\"ts\"/>flags from parent's system call</span>", 
"<span class=\"comment\"> * @pid:<span class=\"ts\"/><span class=\"ts\"/>new child's PID in the parent's namespace</span>", 
"<span class=\"comment\"> * @child:<span class=\"ts\"/><span class=\"ts\"/>child task, already running</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * This is called just after the child has started running.  This is</span>", 
"<span class=\"comment\"> * just before the clone/fork syscall returns, or blocks for vfork</span>", 
"<span class=\"comment\"> * child completion if @clone_flags has the %CLONE_VFORK bit set.</span>", 
"<span class=\"comment\"> * The @child pointer may be invalid if a self-reaping child died and</span>", 
"<span class=\"comment\"> * tracehook_report_clone() took no action to prevent it from self-reaping.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Called with no locks held.</span>", 
"<span class=\"comment\"> */</span>", 
"static <a class=\"id\" href=\"#inline\">inline</a> void <a class=\"id\" href=\"#tracehook_report_clone_complete\">tracehook_report_clone_complete</a>(int <a class=\"id\" href=\"#trace\">trace</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>   struct <a class=\"id\" href=\"#pt_regs\">pt_regs</a> *<a class=\"id\" href=\"#regs\">regs</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>   unsigned long <a class=\"id\" href=\"#clone_flags\">clone_flags</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>   <a class=\"id\" href=\"#pid_t\">pid_t</a> <a class=\"id\" href=\"#pid\">pid</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>   struct <a class=\"id\" href=\"#task_struct\">task_struct</a> *<a class=\"id\" href=\"#child\">child</a>)", 
"{", 
"<span class=\"ts\"/>if (<a class=\"id\" href=\"#unlikely\">unlikely</a>(<a class=\"id\" href=\"#trace\">trace</a>))", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#ptrace_event\">ptrace_event</a>(0, <a class=\"id\" href=\"#trace\">trace</a>, <a class=\"id\" href=\"#pid\">pid</a>);", 
"}", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * tracehook_report_vfork_done - vfork parent's child has exited or exec'd</span>", 
"<span class=\"comment\"> * @child:<span class=\"ts\"/><span class=\"ts\"/>child task, already running</span>", 
"<span class=\"comment\"> * @pid:<span class=\"ts\"/><span class=\"ts\"/>new child's PID in the parent's namespace</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Called after a %CLONE_VFORK parent has waited for the child to complete.</span>", 
"<span class=\"comment\"> * The clone/vfork system call will return immediately after this.</span>", 
"<span class=\"comment\"> * The @child pointer may be invalid if a self-reaping child died and</span>", 
"<span class=\"comment\"> * tracehook_report_clone() took no action to prevent it from self-reaping.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Called with no locks held.</span>", 
"<span class=\"comment\"> */</span>", 
"static <a class=\"id\" href=\"#inline\">inline</a> void <a class=\"id\" href=\"#tracehook_report_vfork_done\">tracehook_report_vfork_done</a>(struct <a class=\"id\" href=\"#task_struct\">task_struct</a> *<a class=\"id\" href=\"#child\">child</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>       <a class=\"id\" href=\"#pid_t\">pid_t</a> <a class=\"id\" href=\"#pid\">pid</a>)", 
"{", 
"<span class=\"ts\"/><a class=\"id\" href=\"#ptrace_event\">ptrace_event</a>(<a class=\"id\" href=\"#PT_TRACE_VFORK_DONE\">PT_TRACE_VFORK_DONE</a>, <a class=\"id\" href=\"#PTRACE_EVENT_VFORK_DONE\">PTRACE_EVENT_VFORK_DONE</a>, <a class=\"id\" href=\"#pid\">pid</a>);", 
"}", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * tracehook_prepare_release_task - task is being reaped, clean up tracing</span>", 
"<span class=\"comment\"> * @task:<span class=\"ts\"/><span class=\"ts\"/>task in %EXIT_DEAD state</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * This is called in release_task() just before @task gets finally reaped</span>", 
"<span class=\"comment\"> * and freed.  This would be the ideal place to remove and clean up any</span>", 
"<span class=\"comment\"> * tracing-related state for @task.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Called with no locks held.</span>", 
"<span class=\"comment\"> */</span>", 
"static <a class=\"id\" href=\"#inline\">inline</a> void <a class=\"id\" href=\"#tracehook_prepare_release_task\">tracehook_prepare_release_task</a>(struct <a class=\"id\" href=\"#task_struct\">task_struct</a> *<a class=\"id\" href=\"#task\">task</a>)", 
"{", 
"}", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * tracehook_finish_release_task - final tracing clean-up</span>", 
"<span class=\"comment\"> * @task:<span class=\"ts\"/><span class=\"ts\"/>task in %EXIT_DEAD state</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * This is called in release_task() when @task is being in the middle of</span>", 
"<span class=\"comment\"> * being reaped.  After this, there must be no tracing entanglements.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Called with write_lock_irq(&amp;tasklist_lock) held.</span>", 
"<span class=\"comment\"> */</span>", 
"static <a class=\"id\" href=\"#inline\">inline</a> void <a class=\"id\" href=\"#tracehook_finish_release_task\">tracehook_finish_release_task</a>(struct <a class=\"id\" href=\"#task_struct\">task_struct</a> *<a class=\"id\" href=\"#task\">task</a>)", 
"{", 
"<span class=\"ts\"/><a class=\"id\" href=\"#ptrace_release_task\">ptrace_release_task</a>(<a class=\"id\" href=\"#task\">task</a>);", 
"}", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * tracehook_signal_handler - signal handler setup is complete</span>", 
"<span class=\"comment\"> * @sig:<span class=\"ts\"/><span class=\"ts\"/>number of signal being delivered</span>", 
"<span class=\"comment\"> * @info:<span class=\"ts\"/><span class=\"ts\"/>siginfo_t of signal being delivered</span>", 
"<span class=\"comment\"> * @ka:<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>sigaction setting that chose the handler</span>", 
"<span class=\"comment\"> * @regs:<span class=\"ts\"/><span class=\"ts\"/>user register state</span>", 
"<span class=\"comment\"> * @stepping:<span class=\"ts\"/><span class=\"ts\"/>nonzero if debugger single-step or block-step in use</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Called by the arch code after a signal handler has been set up.</span>", 
"<span class=\"comment\"> * Register and stack state reflects the user handler about to run.</span>", 
"<span class=\"comment\"> * Signal mask changes have already been made.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Called without locks, shortly before returning to user mode</span>", 
"<span class=\"comment\"> * (or handling more signals).</span>", 
"<span class=\"comment\"> */</span>", 
"static <a class=\"id\" href=\"#inline\">inline</a> void <a class=\"id\" href=\"#tracehook_signal_handler\">tracehook_signal_handler</a>(int <a class=\"id\" href=\"#sig\">sig</a>, <a class=\"id\" href=\"#siginfo_t\">siginfo_t</a> *<a class=\"id\" href=\"#info\">info</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>    const struct <a class=\"id\" href=\"#k_sigaction\">k_sigaction</a> *<a class=\"id\" href=\"#ka\">ka</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>    struct <a class=\"id\" href=\"#pt_regs\">pt_regs</a> *<a class=\"id\" href=\"#regs\">regs</a>, int <a class=\"id\" href=\"#stepping\">stepping</a>)", 
"{", 
"<span class=\"ts\"/>if (<a class=\"id\" href=\"#stepping\">stepping</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#ptrace_notify\">ptrace_notify</a>(<a class=\"id\" href=\"#SIGTRAP\">SIGTRAP</a>);", 
"}", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * tracehook_consider_ignored_signal - suppress short-circuit of ignored signal</span>", 
"<span class=\"comment\"> * @task:<span class=\"ts\"/><span class=\"ts\"/>task receiving the signal</span>", 
"<span class=\"comment\"> * @sig:<span class=\"ts\"/><span class=\"ts\"/>signal number being sent</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Return zero iff tracing doesn't care to examine this ignored signal,</span>", 
"<span class=\"comment\"> * so it can short-circuit normal delivery and never even get queued.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Called with @task-&gt;sighand-&gt;siglock held.</span>", 
"<span class=\"comment\"> */</span>", 
"static <a class=\"id\" href=\"#inline\">inline</a> int <a class=\"id\" href=\"#tracehook_consider_ignored_signal\">tracehook_consider_ignored_signal</a>(struct <a class=\"id\" href=\"#task_struct\">task_struct</a> *<a class=\"id\" href=\"#task\">task</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>    int <a class=\"id\" href=\"#sig\">sig</a>)", 
"{", 
"<span class=\"ts\"/>return (<a class=\"id\" href=\"#task_ptrace\">task_ptrace</a>(<a class=\"id\" href=\"#task\">task</a>) &amp; <a class=\"id\" href=\"#PT_PTRACED\">PT_PTRACED</a>) != 0;", 
"}", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * tracehook_consider_fatal_signal - suppress special handling of fatal signal</span>", 
"<span class=\"comment\"> * @task:<span class=\"ts\"/><span class=\"ts\"/>task receiving the signal</span>", 
"<span class=\"comment\"> * @sig:<span class=\"ts\"/><span class=\"ts\"/>signal number being sent</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Return nonzero to prevent special handling of this termination signal.</span>", 
"<span class=\"comment\"> * Normally handler for signal is %SIG_DFL.  It can be %SIG_IGN if @sig is</span>", 
"<span class=\"comment\"> * ignored, in which case force_sig() is about to reset it to %SIG_DFL.</span>", 
"<span class=\"comment\"> * When this returns zero, this signal might cause a quick termination</span>", 
"<span class=\"comment\"> * that does not give the debugger a chance to intercept the signal.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Called with or without @task-&gt;sighand-&gt;siglock held.</span>", 
"<span class=\"comment\"> */</span>", 
"static <a class=\"id\" href=\"#inline\">inline</a> int <a class=\"id\" href=\"#tracehook_consider_fatal_signal\">tracehook_consider_fatal_signal</a>(struct <a class=\"id\" href=\"#task_struct\">task_struct</a> *<a class=\"id\" href=\"#task\">task</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>  int <a class=\"id\" href=\"#sig\">sig</a>)", 
"{", 
"<span class=\"ts\"/>return (<a class=\"id\" href=\"#task_ptrace\">task_ptrace</a>(<a class=\"id\" href=\"#task\">task</a>) &amp; <a class=\"id\" href=\"#PT_PTRACED\">PT_PTRACED</a>) != 0;", 
"}", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * tracehook_force_sigpending - let tracing force signal_pending(current) on</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Called when recomputing our signal_pending() flag.  Return nonzero</span>", 
"<span class=\"comment\"> * to force the signal_pending() flag on, so that tracehook_get_signal()</span>", 
"<span class=\"comment\"> * will be called before the next return to user mode.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Called with @current-&gt;sighand-&gt;siglock held.</span>", 
"<span class=\"comment\"> */</span>", 
"static <a class=\"id\" href=\"#inline\">inline</a> int <a class=\"id\" href=\"#tracehook_force_sigpending\">tracehook_force_sigpending</a>(void)", 
"{", 
"<span class=\"ts\"/>return 0;", 
"}", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * tracehook_get_signal - deliver synthetic signal to traced task</span>", 
"<span class=\"comment\"> * @task:<span class=\"ts\"/><span class=\"ts\"/>@current</span>", 
"<span class=\"comment\"> * @regs:<span class=\"ts\"/><span class=\"ts\"/>task_pt_regs(@current)</span>", 
"<span class=\"comment\"> * @info:<span class=\"ts\"/><span class=\"ts\"/>details of synthetic signal</span>", 
"<span class=\"comment\"> * @return_ka:<span class=\"ts\"/><span class=\"ts\"/>sigaction for synthetic signal</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Return zero to check for a real pending signal normally.</span>", 
"<span class=\"comment\"> * Return -1 after releasing the siglock to repeat the check.</span>", 
"<span class=\"comment\"> * Return a signal number to induce an artifical signal delivery,</span>", 
"<span class=\"comment\"> * setting *@info and *@return_ka to specify its details and behavior.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * The @return_ka-&gt;sa_handler value controls the disposition of the</span>", 
"<span class=\"comment\"> * signal, no matter the signal number.  For %SIG_DFL, the return value</span>", 
"<span class=\"comment\"> * is a representative signal to indicate the behavior (e.g. %SIGTERM</span>", 
"<span class=\"comment\"> * for death, %SIGQUIT for core dump, %SIGSTOP for job control stop,</span>", 
"<span class=\"comment\"> * %SIGTSTP for stop unless in an orphaned pgrp), but the signal number</span>", 
"<span class=\"comment\"> * reported will be @info-&gt;si_signo instead.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Called with @task-&gt;sighand-&gt;siglock held, before dequeuing pending signals.</span>", 
"<span class=\"comment\"> */</span>", 
"static <a class=\"id\" href=\"#inline\">inline</a> int <a class=\"id\" href=\"#tracehook_get_signal\">tracehook_get_signal</a>(struct <a class=\"id\" href=\"#task_struct\">task_struct</a> *<a class=\"id\" href=\"#task\">task</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>       struct <a class=\"id\" href=\"#pt_regs\">pt_regs</a> *<a class=\"id\" href=\"#regs\">regs</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>       <a class=\"id\" href=\"#siginfo_t\">siginfo_t</a> *<a class=\"id\" href=\"#info\">info</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>       struct <a class=\"id\" href=\"#k_sigaction\">k_sigaction</a> *<a class=\"id\" href=\"#return_ka\">return_ka</a>)", 
"{", 
"<span class=\"ts\"/>return 0;", 
"}", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * tracehook_notify_jctl - report about job control stop/continue</span>", 
"<span class=\"comment\"> * @notify:<span class=\"ts\"/><span class=\"ts\"/>zero, %CLD_STOPPED or %CLD_CONTINUED</span>", 
"<span class=\"comment\"> * @why:<span class=\"ts\"/><span class=\"ts\"/>%CLD_STOPPED or %CLD_CONTINUED</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * This is called when we might call do_notify_parent_cldstop().</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * @notify is zero if we would not ordinarily send a %SIGCHLD,</span>", 
"<span class=\"comment\"> * or is the %CLD_STOPPED or %CLD_CONTINUED .si_code for %SIGCHLD.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * @why is %CLD_STOPPED when about to stop for job control;</span>", 
"<span class=\"comment\"> * we are already in %TASK_STOPPED state, about to call schedule().</span>", 
"<span class=\"comment\"> * It might also be that we have just exited (check %PF_EXITING),</span>", 
"<span class=\"comment\"> * but need to report that a group-wide stop is complete.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * @why is %CLD_CONTINUED when waking up after job control stop and</span>", 
"<span class=\"comment\"> * ready to make a delayed @notify report.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Return the %CLD_* value for %SIGCHLD, or zero to generate no signal.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Called with the siglock held.</span>", 
"<span class=\"comment\"> */</span>", 
"static <a class=\"id\" href=\"#inline\">inline</a> int <a class=\"id\" href=\"#tracehook_notify_jctl\">tracehook_notify_jctl</a>(int <a class=\"id\" href=\"#notify\">notify</a>, int <a class=\"id\" href=\"#why\">why</a>)", 
"{", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#notify\">notify</a> ?: (<a class=\"id\" href=\"#current\">current</a>-><a class=\"id\" href=\"#ptrace\">ptrace</a> &amp; <a class=\"id\" href=\"#PT_PTRACED\">PT_PTRACED</a>) ? <a class=\"id\" href=\"#why\">why</a> : 0;", 
"}", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * tracehook_finish_jctl - report about return from job control stop</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * This is called by do_signal_stop() after wakeup.</span>", 
"<span class=\"comment\"> */</span>", 
"static <a class=\"id\" href=\"#inline\">inline</a> void <a class=\"id\" href=\"#tracehook_finish_jctl\">tracehook_finish_jctl</a>(void)", 
"{", 
"}", 
"", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#DEATH_REAP\">DEATH_REAP</a><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>-1", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#DEATH_DELAYED_GROUP_LEADER\">DEATH_DELAYED_GROUP_LEADER</a><span class=\"ts\"/>-2", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * tracehook_notify_death - task is dead, ready to notify parent</span>", 
"<span class=\"comment\"> * @task:<span class=\"ts\"/><span class=\"ts\"/>@current task now exiting</span>", 
"<span class=\"comment\"> * @death_cookie:<span class=\"ts\"/>value to pass to tracehook_report_death()</span>", 
"<span class=\"comment\"> * @group_dead:<span class=\"ts\"/><span class=\"ts\"/>nonzero if this was the last thread in the group to die</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * A return value &gt;= 0 means call do_notify_parent() with that signal</span>", 
"<span class=\"comment\"> * number.  Negative return value can be %DEATH_REAP to self-reap right</span>", 
"<span class=\"comment\"> * now, or %DEATH_DELAYED_GROUP_LEADER to a zombie without notifying our</span>", 
"<span class=\"comment\"> * parent.  Note that a return value of 0 means a do_notify_parent() call</span>", 
"<span class=\"comment\"> * that sends no signal, but still wakes up a parent blocked in wait*().</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Called with write_lock_irq(&amp;tasklist_lock) held.</span>", 
"<span class=\"comment\"> */</span>", 
"static <a class=\"id\" href=\"#inline\">inline</a> int <a class=\"id\" href=\"#tracehook_notify_death\">tracehook_notify_death</a>(struct <a class=\"id\" href=\"#task_struct\">task_struct</a> *<a class=\"id\" href=\"#task\">task</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/> void **<a class=\"id\" href=\"#death_cookie\">death_cookie</a>, int <a class=\"id\" href=\"#group_dead\">group_dead</a>)", 
"{", 
"<span class=\"ts\"/>if (<a class=\"id\" href=\"#task_detached\">task_detached</a>(<a class=\"id\" href=\"#task\">task</a>))", 
"<span class=\"ts\"/><span class=\"ts\"/>return <a class=\"id\" href=\"#task\">task</a>-><a class=\"id\" href=\"#ptrace\">ptrace</a> ? <a class=\"id\" href=\"#SIGCHLD\">SIGCHLD</a> : <a class=\"id\" href=\"#DEATH_REAP\">DEATH_REAP</a>;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * If something other than our normal parent is ptracing us, then</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * send it a SIGCHLD instead of honoring exit_signal.  exit_signal</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * only has special meaning to our real parent.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>if (<a class=\"id\" href=\"#thread_group_empty\">thread_group_empty</a>(<a class=\"id\" href=\"#task\">task</a>) && !<a class=\"id\" href=\"#ptrace_reparented\">ptrace_reparented</a>(<a class=\"id\" href=\"#task\">task</a>))", 
"<span class=\"ts\"/><span class=\"ts\"/>return <a class=\"id\" href=\"#task\">task</a>-><a class=\"id\" href=\"#exit_signal\">exit_signal</a>;", 
"", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#task\">task</a>-><a class=\"id\" href=\"#ptrace\">ptrace</a> ? <a class=\"id\" href=\"#SIGCHLD\">SIGCHLD</a> : <a class=\"id\" href=\"#DEATH_DELAYED_GROUP_LEADER\">DEATH_DELAYED_GROUP_LEADER</a>;", 
"}", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * tracehook_report_death - task is dead and ready to be reaped</span>", 
"<span class=\"comment\"> * @task:<span class=\"ts\"/><span class=\"ts\"/>@current task now exiting</span>", 
"<span class=\"comment\"> * @signal:<span class=\"ts\"/><span class=\"ts\"/>return value from tracheook_notify_death()</span>", 
"<span class=\"comment\"> * @death_cookie:<span class=\"ts\"/>value passed back from tracehook_notify_death()</span>", 
"<span class=\"comment\"> * @group_dead:<span class=\"ts\"/><span class=\"ts\"/>nonzero if this was the last thread in the group to die</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Thread has just become a zombie or is about to self-reap.  If positive,</span>", 
"<span class=\"comment\"> * @signal is the signal number just sent to the parent (usually %SIGCHLD).</span>", 
"<span class=\"comment\"> * If @signal is %DEATH_REAP, this thread will self-reap.  If @signal is</span>", 
"<span class=\"comment\"> * %DEATH_DELAYED_GROUP_LEADER, this is a delayed_group_leader() zombie.</span>", 
"<span class=\"comment\"> * The @death_cookie was passed back by tracehook_notify_death().</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * If normal reaping is not inhibited, @task-&gt;exit_state might be changing</span>", 
"<span class=\"comment\"> * in parallel.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Called without locks.</span>", 
"<span class=\"comment\"> */</span>", 
"static <a class=\"id\" href=\"#inline\">inline</a> void <a class=\"id\" href=\"#tracehook_report_death\">tracehook_report_death</a>(struct <a class=\"id\" href=\"#task_struct\">task_struct</a> *<a class=\"id\" href=\"#task\">task</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>  int <a class=\"id\" href=\"#signal\">signal</a>, void *<a class=\"id\" href=\"#death_cookie\">death_cookie</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>  int <a class=\"id\" href=\"#group_dead\">group_dead</a>)", 
"{", 
"}", 
"", 
"#<a class=\"id\" href=\"#ifdef\">ifdef</a> <a class=\"id\" href=\"#TIF_NOTIFY_RESUME\">TIF_NOTIFY_RESUME</a>", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * set_notify_resume - cause tracehook_notify_resume() to be called</span>", 
"<span class=\"comment\"> * @task:<span class=\"ts\"/><span class=\"ts\"/>task that will call tracehook_notify_resume()</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Calling this arranges that @task will call tracehook_notify_resume()</span>", 
"<span class=\"comment\"> * before returning to user mode.  If it's already running in user mode,</span>", 
"<span class=\"comment\"> * it will enter the kernel and call tracehook_notify_resume() soon.</span>", 
"<span class=\"comment\"> * If it's blocked, it will not be woken.</span>", 
"<span class=\"comment\"> */</span>", 
"static <a class=\"id\" href=\"#inline\">inline</a> void <a class=\"id\" href=\"#set_notify_resume\">set_notify_resume</a>(struct <a class=\"id\" href=\"#task_struct\">task_struct</a> *<a class=\"id\" href=\"#task\">task</a>)", 
"{", 
"<span class=\"ts\"/>if (!<a class=\"id\" href=\"#test_and_set_tsk_thread_flag\">test_and_set_tsk_thread_flag</a>(<a class=\"id\" href=\"#task\">task</a>, <a class=\"id\" href=\"#TIF_NOTIFY_RESUME\">TIF_NOTIFY_RESUME</a>))", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#kick_process\">kick_process</a>(<a class=\"id\" href=\"#task\">task</a>);", 
"}", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * tracehook_notify_resume - report when about to return to user mode</span>", 
"<span class=\"comment\"> * @regs:<span class=\"ts\"/><span class=\"ts\"/>user-mode registers of @current task</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * This is called when %TIF_NOTIFY_RESUME has been set.  Now we are</span>", 
"<span class=\"comment\"> * about to return to user mode, and the user state in @regs can be</span>", 
"<span class=\"comment\"> * inspected or adjusted.  The caller in arch code has cleared</span>", 
"<span class=\"comment\"> * %TIF_NOTIFY_RESUME before the call.  If the flag gets set again</span>", 
"<span class=\"comment\"> * asynchronously, this will be called again before we return to</span>", 
"<span class=\"comment\"> * user mode.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Called without locks.</span>", 
"<span class=\"comment\"> */</span>", 
"static <a class=\"id\" href=\"#inline\">inline</a> void <a class=\"id\" href=\"#tracehook_notify_resume\">tracehook_notify_resume</a>(struct <a class=\"id\" href=\"#pt_regs\">pt_regs</a> *<a class=\"id\" href=\"#regs\">regs</a>)", 
"{", 
"}", 
"#<a class=\"id\" href=\"#endif\">endif</a><span class=\"ts\"/><span class=\"comment\">/* TIF_NOTIFY_RESUME */</span>", 
"", 
"#<a class=\"id\" href=\"#endif\">endif</a><span class=\"ts\"/><span class=\"comment\">/* &lt;linux/tracehook.h&gt; */</span>", 
];
xr_frag_insert('l/9e/4568c11442ef20f3cac2bfcffbbddb1f609fbd.xr', __xr_tmp);
