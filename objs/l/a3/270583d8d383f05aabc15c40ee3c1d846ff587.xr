var __xr_tmp = [
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * kernel/mutex.c</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Mutexes: blocking mutual exclusion locks</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Started by Ingo Molnar:</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> *  Copyright (C) 2004, 2005, 2006 Red Hat, Inc., Ingo Molnar &lt;mingo@redhat.com&gt;</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Many thanks to Arjan van de Ven, Thomas Gleixner, Steven Rostedt and</span>", 
"<span class=\"comment\"> * David Howells for suggestions and improvements.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> *  - Adaptive spinning for mutexes by Peter Zijlstra. (Ported to mainline</span>", 
"<span class=\"comment\"> *    from the -rt tree, where it was originally implemented for rtmutexes</span>", 
"<span class=\"comment\"> *    by Steven Rostedt, based on work by Gregory Haskins, Peter Morreale</span>", 
"<span class=\"comment\"> *    and Sven Dietrich.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Also see Documentation/mutex-design.txt.</span>", 
"<span class=\"comment\"> */</span>", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#mutex\">mutex</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#sched\">sched</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#module\">module</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#spinlock\">spinlock</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#interrupt\">interrupt</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#debug_locks\">debug_locks</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * In the DEBUG case we are using the \"NULL fastpath\" for mutexes,</span>", 
"<span class=\"comment\"> * which forces all calls into the slowpath:</span>", 
"<span class=\"comment\"> */</span>", 
"#<a class=\"id\" href=\"#ifdef\">ifdef</a> <a class=\"id\" href=\"#CONFIG_DEBUG_MUTEXES\">CONFIG_DEBUG_MUTEXES</a>", 
"# <a class=\"id\" href=\"#include\">include</a> \"mutex-debug.h\"", 
"# <a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#asm\">asm</a>-<a class=\"id\" href=\"#generic\">generic</a>/<a class=\"id\" href=\"#mutex\">mutex</a>-<a class=\"id\" href=\"#null\">null</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#else", 
"# <a class=\"id\" href=\"#include\">include</a> \"mutex.h\"", 
"# <a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#asm\">asm</a>/<a class=\"id\" href=\"#mutex\">mutex</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#endif\">endif</a>", 
"", 
"void", 
"<a class=\"id\" href=\"#__mutex_init\">__mutex_init</a>(struct <a class=\"id\" href=\"#mutex\">mutex</a> *<a class=\"id\" href=\"#lock\">lock</a>, const char *<a class=\"id\" href=\"#name\">name</a>, struct <a class=\"id\" href=\"#lock_class_key\">lock_class_key</a> *<a class=\"id\" href=\"#key\">key</a>)", 
"{", 
"<span class=\"ts\"/><a class=\"id\" href=\"#atomic_set\">atomic_set</a>(&amp;<a class=\"id\" href=\"#lock\">lock</a>-><a class=\"id\" href=\"#count\">count</a>, 1);", 
"<span class=\"ts\"/><a class=\"id\" href=\"#spin_lock_init\">spin_lock_init</a>(&amp;<a class=\"id\" href=\"#lock\">lock</a>-><a class=\"id\" href=\"#wait_lock\">wait_lock</a>);", 
"<span class=\"ts\"/><a class=\"id\" href=\"#INIT_LIST_HEAD\">INIT_LIST_HEAD</a>(&amp;<a class=\"id\" href=\"#lock\">lock</a>-><a class=\"id\" href=\"#wait_list\">wait_list</a>);", 
"<span class=\"ts\"/><a class=\"id\" href=\"#mutex_clear_owner\">mutex_clear_owner</a>(<a class=\"id\" href=\"#lock\">lock</a>);", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#debug_mutex_init\">debug_mutex_init</a>(<a class=\"id\" href=\"#lock\">lock</a>, <a class=\"id\" href=\"#name\">name</a>, <a class=\"id\" href=\"#key\">key</a>);", 
"}", 
"", 
"<a class=\"id\" href=\"#EXPORT_SYMBOL\">EXPORT_SYMBOL</a>(<a class=\"id\" href=\"#__mutex_init\">__mutex_init</a>);", 
"", 
"#<a class=\"id\" href=\"#ifndef\">ifndef</a> <a class=\"id\" href=\"#CONFIG_DEBUG_LOCK_ALLOC\">CONFIG_DEBUG_LOCK_ALLOC</a>", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * We split the mutex lock/unlock logic into separate fastpath and</span>", 
"<span class=\"comment\"> * slowpath functions, to reduce the register pressure on the fastpath.</span>", 
"<span class=\"comment\"> * We also put the fastpath first in the kernel image, to make sure the</span>", 
"<span class=\"comment\"> * branch is predicted by the CPU as default-untaken.</span>", 
"<span class=\"comment\"> */</span>", 
"static <a class=\"id\" href=\"#__used\">__used</a> <a class=\"id\" href=\"#noinline\">noinline</a> void <a class=\"id\" href=\"#__sched\">__sched</a>", 
"<a class=\"id\" href=\"#__mutex_lock_slowpath\">__mutex_lock_slowpath</a>(<a class=\"id\" href=\"#atomic_t\">atomic_t</a> *<a class=\"id\" href=\"#lock_count\">lock_count</a>);", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * mutex_lock - acquire the mutex</span>", 
"<span class=\"comment\"> * @lock: the mutex to be acquired</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Lock the mutex exclusively for this task. If the mutex is not</span>", 
"<span class=\"comment\"> * available right now, it will sleep until it can get it.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * The mutex must later on be released by the same task that</span>", 
"<span class=\"comment\"> * acquired it. Recursive locking is not allowed. The task</span>", 
"<span class=\"comment\"> * may not exit without first unlocking the mutex. Also, kernel</span>", 
"<span class=\"comment\"> * memory where the mutex resides mutex must not be freed with</span>", 
"<span class=\"comment\"> * the mutex still locked. The mutex must first be initialized</span>", 
"<span class=\"comment\"> * (or statically defined) before it can be locked. memset()-ing</span>", 
"<span class=\"comment\"> * the mutex to 0 is not allowed.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * ( The CONFIG_DEBUG_MUTEXES .config option turns on debugging</span>", 
"<span class=\"comment\"> *   checks that will enforce the restrictions and will also do</span>", 
"<span class=\"comment\"> *   deadlock debugging. )</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * This function is similar to (but not equivalent to) down().</span>", 
"<span class=\"comment\"> */</span>", 
"void <a class=\"id\" href=\"#__sched\">__sched</a> <a class=\"id\" href=\"#mutex_lock\">mutex_lock</a>(struct <a class=\"id\" href=\"#mutex\">mutex</a> *<a class=\"id\" href=\"#lock\">lock</a>)", 
"{", 
"<span class=\"ts\"/><a class=\"id\" href=\"#might_sleep\">might_sleep</a>();", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * The locking fastpath is the 1-&gt;0 transition from</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * 'unlocked' into 'locked' state.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/><a class=\"id\" href=\"#__mutex_fastpath_lock\">__mutex_fastpath_lock</a>(&amp;<a class=\"id\" href=\"#lock\">lock</a>-><a class=\"id\" href=\"#count\">count</a>, <a class=\"id\" href=\"#__mutex_lock_slowpath\">__mutex_lock_slowpath</a>);", 
"<span class=\"ts\"/><a class=\"id\" href=\"#mutex_set_owner\">mutex_set_owner</a>(<a class=\"id\" href=\"#lock\">lock</a>);", 
"}", 
"", 
"<a class=\"id\" href=\"#EXPORT_SYMBOL\">EXPORT_SYMBOL</a>(<a class=\"id\" href=\"#mutex_lock\">mutex_lock</a>);", 
"#<a class=\"id\" href=\"#endif\">endif</a>", 
"", 
"static <a class=\"id\" href=\"#__used\">__used</a> <a class=\"id\" href=\"#noinline\">noinline</a> void <a class=\"id\" href=\"#__sched\">__sched</a> <a class=\"id\" href=\"#__mutex_unlock_slowpath\">__mutex_unlock_slowpath</a>(<a class=\"id\" href=\"#atomic_t\">atomic_t</a> *<a class=\"id\" href=\"#lock_count\">lock_count</a>);", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * mutex_unlock - release the mutex</span>", 
"<span class=\"comment\"> * @lock: the mutex to be released</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Unlock a mutex that has been locked by this task previously.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * This function must not be used in interrupt context. Unlocking</span>", 
"<span class=\"comment\"> * of a not locked mutex is not allowed.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * This function is similar to (but not equivalent to) up().</span>", 
"<span class=\"comment\"> */</span>", 
"void <a class=\"id\" href=\"#__sched\">__sched</a> <a class=\"id\" href=\"#mutex_unlock\">mutex_unlock</a>(struct <a class=\"id\" href=\"#mutex\">mutex</a> *<a class=\"id\" href=\"#lock\">lock</a>)", 
"{", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * The unlocking fastpath is the 0-&gt;1 transition from 'locked'</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * into 'unlocked' state:</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"#<a class=\"id\" href=\"#ifndef\">ifndef</a> <a class=\"id\" href=\"#CONFIG_DEBUG_MUTEXES\">CONFIG_DEBUG_MUTEXES</a>", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * When debugging is enabled we must not clear the owner before time,</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * the slow path will always be taken, and that clears the owner field</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * after verifying that it was indeed current.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/><a class=\"id\" href=\"#mutex_clear_owner\">mutex_clear_owner</a>(<a class=\"id\" href=\"#lock\">lock</a>);", 
"#<a class=\"id\" href=\"#endif\">endif</a>", 
"<span class=\"ts\"/><a class=\"id\" href=\"#__mutex_fastpath_unlock\">__mutex_fastpath_unlock</a>(&amp;<a class=\"id\" href=\"#lock\">lock</a>-><a class=\"id\" href=\"#count\">count</a>, <a class=\"id\" href=\"#__mutex_unlock_slowpath\">__mutex_unlock_slowpath</a>);", 
"}", 
"", 
"<a class=\"id\" href=\"#EXPORT_SYMBOL\">EXPORT_SYMBOL</a>(<a class=\"id\" href=\"#mutex_unlock\">mutex_unlock</a>);", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * Lock a mutex (possibly interruptible), slowpath:</span>", 
"<span class=\"comment\"> */</span>", 
"static <a class=\"id\" href=\"#inline\">inline</a> int <a class=\"id\" href=\"#__sched\">__sched</a>", 
"<a class=\"id\" href=\"#__mutex_lock_common\">__mutex_lock_common</a>(struct <a class=\"id\" href=\"#mutex\">mutex</a> *<a class=\"id\" href=\"#lock\">lock</a>, long <a class=\"id\" href=\"#state\">state</a>, unsigned int <a class=\"id\" href=\"#subclass\">subclass</a>,", 
"<span class=\"ts\"/>       <span class=\"ts\"/>unsigned long <a class=\"id\" href=\"#ip\">ip</a>)", 
"{", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#task_struct\">task_struct</a> *<a class=\"id\" href=\"#task\">task</a> = <a class=\"id\" href=\"#current\">current</a>;", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#mutex_waiter\">mutex_waiter</a> <a class=\"id\" href=\"#waiter\">waiter</a>;", 
"<span class=\"ts\"/>unsigned long <a class=\"id\" href=\"#flags\">flags</a>;", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#preempt_disable\">preempt_disable</a>();", 
"<span class=\"ts\"/><a class=\"id\" href=\"#mutex_acquire\">mutex_acquire</a>(&amp;<a class=\"id\" href=\"#lock\">lock</a>-><a class=\"id\" href=\"#dep_map\">dep_map</a>, <a class=\"id\" href=\"#subclass\">subclass</a>, 0, <a class=\"id\" href=\"#ip\">ip</a>);", 
"", 
"#<a class=\"id\" href=\"#ifdef\">ifdef</a> <a class=\"id\" href=\"#CONFIG_MUTEX_SPIN_ON_OWNER\">CONFIG_MUTEX_SPIN_ON_OWNER</a>", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Optimistic spinning.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * We try to spin for acquisition when we find that there are no</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * pending waiters and the lock owner is currently running on a</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * (different) CPU.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * The rationale is that if the lock owner is running, it is likely to</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * release the lock soon.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Since this needs the lock owner, and this mutex implementation</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * doesn't track the owner atomically in the lock field, we need to</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * track it non-atomically.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * We can't do this for DEBUG_MUTEXES because that relies on wait_lock</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * to serialize everything.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"", 
"<span class=\"ts\"/>for (;;) {", 
"<span class=\"ts\"/><span class=\"ts\"/>struct <a class=\"id\" href=\"#thread_info\">thread_info</a> *<a class=\"id\" href=\"#owner\">owner</a>;", 
"", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/><span class=\"ts\"/> * If we own the BKL, then don't spin. The owner of</span>", 
"<span class=\"comment\"><span class=\"ts\"/><span class=\"ts\"/> * the mutex might be waiting on us to release the BKL.</span>", 
"<span class=\"comment\"><span class=\"ts\"/><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/><span class=\"ts\"/>if (<a class=\"id\" href=\"#unlikely\">unlikely</a>(<a class=\"id\" href=\"#current\">current</a>-><a class=\"id\" href=\"#lock_depth\">lock_depth</a> >= 0))", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>break;", 
"", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/><span class=\"ts\"/> * If there's an owner, wait for it to either</span>", 
"<span class=\"comment\"><span class=\"ts\"/><span class=\"ts\"/> * release the lock or go to sleep.</span>", 
"<span class=\"comment\"><span class=\"ts\"/><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#owner\">owner</a> = <a class=\"id\" href=\"#ACCESS_ONCE\">ACCESS_ONCE</a>(<a class=\"id\" href=\"#lock\">lock</a>-><a class=\"id\" href=\"#owner\">owner</a>);", 
"<span class=\"ts\"/><span class=\"ts\"/>if (<a class=\"id\" href=\"#owner\">owner</a> && !<a class=\"id\" href=\"#mutex_spin_on_owner\">mutex_spin_on_owner</a>(<a class=\"id\" href=\"#lock\">lock</a>, <a class=\"id\" href=\"#owner\">owner</a>))", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>break;", 
"", 
"<span class=\"ts\"/><span class=\"ts\"/>if (<a class=\"id\" href=\"#atomic_cmpxchg\">atomic_cmpxchg</a>(&amp;<a class=\"id\" href=\"#lock\">lock</a>-><a class=\"id\" href=\"#count\">count</a>, 1, 0) == 1) {", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#lock_acquired\">lock_acquired</a>(&amp;<a class=\"id\" href=\"#lock\">lock</a>-><a class=\"id\" href=\"#dep_map\">dep_map</a>, <a class=\"id\" href=\"#ip\">ip</a>);", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#mutex_set_owner\">mutex_set_owner</a>(<a class=\"id\" href=\"#lock\">lock</a>);", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#preempt_enable\">preempt_enable</a>();", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>return 0;", 
"<span class=\"ts\"/><span class=\"ts\"/>}", 
"", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/><span class=\"ts\"/> * When there's no owner, we might have preempted between the</span>", 
"<span class=\"comment\"><span class=\"ts\"/><span class=\"ts\"/> * owner acquiring the lock and setting the owner field. If</span>", 
"<span class=\"comment\"><span class=\"ts\"/><span class=\"ts\"/> * we're an RT task that will live-lock because we won't let</span>", 
"<span class=\"comment\"><span class=\"ts\"/><span class=\"ts\"/> * the owner complete.</span>", 
"<span class=\"comment\"><span class=\"ts\"/><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/><span class=\"ts\"/>if (!<a class=\"id\" href=\"#owner\">owner</a> && (<a class=\"id\" href=\"#need_resched\">need_resched</a>() || <a class=\"id\" href=\"#rt_task\">rt_task</a>(<a class=\"id\" href=\"#task\">task</a>)))", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>break;", 
"", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/><span class=\"ts\"/> * The cpu_relax() call is a compiler barrier which forces</span>", 
"<span class=\"comment\"><span class=\"ts\"/><span class=\"ts\"/> * everything in this loop to be re-loaded. We don't need</span>", 
"<span class=\"comment\"><span class=\"ts\"/><span class=\"ts\"/> * memory barriers as we'll eventually observe the right</span>", 
"<span class=\"comment\"><span class=\"ts\"/><span class=\"ts\"/> * values at the cost of a few extra spins.</span>", 
"<span class=\"comment\"><span class=\"ts\"/><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#cpu_relax\">cpu_relax</a>();", 
"<span class=\"ts\"/>}", 
"#<a class=\"id\" href=\"#endif\">endif</a>", 
"<span class=\"ts\"/><a class=\"id\" href=\"#spin_lock_mutex\">spin_lock_mutex</a>(&amp;<a class=\"id\" href=\"#lock\">lock</a>-><a class=\"id\" href=\"#wait_lock\">wait_lock</a>, <a class=\"id\" href=\"#flags\">flags</a>);", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#debug_mutex_lock_common\">debug_mutex_lock_common</a>(<a class=\"id\" href=\"#lock\">lock</a>, &amp;<a class=\"id\" href=\"#waiter\">waiter</a>);", 
"<span class=\"ts\"/><a class=\"id\" href=\"#debug_mutex_add_waiter\">debug_mutex_add_waiter</a>(<a class=\"id\" href=\"#lock\">lock</a>, &amp;<a class=\"id\" href=\"#waiter\">waiter</a>, <a class=\"id\" href=\"#task_thread_info\">task_thread_info</a>(<a class=\"id\" href=\"#task\">task</a>));", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/* add waiting tasks to the end of the waitqueue (FIFO): */</span>", 
"<span class=\"ts\"/><a class=\"id\" href=\"#list_add_tail\">list_add_tail</a>(&amp;<a class=\"id\" href=\"#waiter\">waiter</a>.<a class=\"id\" href=\"#list\">list</a>, &amp;<a class=\"id\" href=\"#lock\">lock</a>-><a class=\"id\" href=\"#wait_list\">wait_list</a>);", 
"<span class=\"ts\"/><a class=\"id\" href=\"#waiter\">waiter</a>.<a class=\"id\" href=\"#task\">task</a> = <a class=\"id\" href=\"#task\">task</a>;", 
"", 
"<span class=\"ts\"/>if (<a class=\"id\" href=\"#atomic_xchg\">atomic_xchg</a>(&amp;<a class=\"id\" href=\"#lock\">lock</a>-><a class=\"id\" href=\"#count\">count</a>, -1) == 1)", 
"<span class=\"ts\"/><span class=\"ts\"/>goto <a class=\"id\" href=\"#done\">done</a>;", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#lock_contended\">lock_contended</a>(&amp;<a class=\"id\" href=\"#lock\">lock</a>-><a class=\"id\" href=\"#dep_map\">dep_map</a>, <a class=\"id\" href=\"#ip\">ip</a>);", 
"", 
"<span class=\"ts\"/>for (;;) {", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/><span class=\"ts\"/> * Lets try to take the lock again - this is needed even if</span>", 
"<span class=\"comment\"><span class=\"ts\"/><span class=\"ts\"/> * we get here for the first time (shortly after failing to</span>", 
"<span class=\"comment\"><span class=\"ts\"/><span class=\"ts\"/> * acquire the lock), to make sure that we get a wakeup once</span>", 
"<span class=\"comment\"><span class=\"ts\"/><span class=\"ts\"/> * it's unlocked. Later on, if we sleep, this is the</span>", 
"<span class=\"comment\"><span class=\"ts\"/><span class=\"ts\"/> * operation that gives us the lock. We xchg it to -1, so</span>", 
"<span class=\"comment\"><span class=\"ts\"/><span class=\"ts\"/> * that when we release the lock, we properly wake up the</span>", 
"<span class=\"comment\"><span class=\"ts\"/><span class=\"ts\"/> * other waiters:</span>", 
"<span class=\"comment\"><span class=\"ts\"/><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/><span class=\"ts\"/>if (<a class=\"id\" href=\"#atomic_xchg\">atomic_xchg</a>(&amp;<a class=\"id\" href=\"#lock\">lock</a>-><a class=\"id\" href=\"#count\">count</a>, -1) == 1)", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>break;", 
"", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/><span class=\"ts\"/> * got a signal? (This code gets eliminated in the</span>", 
"<span class=\"comment\"><span class=\"ts\"/><span class=\"ts\"/> * TASK_UNINTERRUPTIBLE case.)</span>", 
"<span class=\"comment\"><span class=\"ts\"/><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/><span class=\"ts\"/>if (<a class=\"id\" href=\"#unlikely\">unlikely</a>(<a class=\"id\" href=\"#signal_pending_state\">signal_pending_state</a>(<a class=\"id\" href=\"#state\">state</a>, <a class=\"id\" href=\"#task\">task</a>))) {", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#mutex_remove_waiter\">mutex_remove_waiter</a>(<a class=\"id\" href=\"#lock\">lock</a>, &amp;<a class=\"id\" href=\"#waiter\">waiter</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>    <a class=\"id\" href=\"#task_thread_info\">task_thread_info</a>(<a class=\"id\" href=\"#task\">task</a>));", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#mutex_release\">mutex_release</a>(&amp;<a class=\"id\" href=\"#lock\">lock</a>-><a class=\"id\" href=\"#dep_map\">dep_map</a>, 1, <a class=\"id\" href=\"#ip\">ip</a>);", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#spin_unlock_mutex\">spin_unlock_mutex</a>(&amp;<a class=\"id\" href=\"#lock\">lock</a>-><a class=\"id\" href=\"#wait_lock\">wait_lock</a>, <a class=\"id\" href=\"#flags\">flags</a>);", 
"", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#debug_mutex_free_waiter\">debug_mutex_free_waiter</a>(&amp;<a class=\"id\" href=\"#waiter\">waiter</a>);", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#preempt_enable\">preempt_enable</a>();", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>return -<a class=\"id\" href=\"#EINTR\">EINTR</a>;", 
"<span class=\"ts\"/><span class=\"ts\"/>}", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#__set_task_state\">__set_task_state</a>(<a class=\"id\" href=\"#task\">task</a>, <a class=\"id\" href=\"#state\">state</a>);", 
"", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"comment\">/* didnt get the lock, go to sleep: */</span>", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#spin_unlock_mutex\">spin_unlock_mutex</a>(&amp;<a class=\"id\" href=\"#lock\">lock</a>-><a class=\"id\" href=\"#wait_lock\">wait_lock</a>, <a class=\"id\" href=\"#flags\">flags</a>);", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#preempt_enable_no_resched\">preempt_enable_no_resched</a>();", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#schedule\">schedule</a>();", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#preempt_disable\">preempt_disable</a>();", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#spin_lock_mutex\">spin_lock_mutex</a>(&amp;<a class=\"id\" href=\"#lock\">lock</a>-><a class=\"id\" href=\"#wait_lock\">wait_lock</a>, <a class=\"id\" href=\"#flags\">flags</a>);", 
"<span class=\"ts\"/>}", 
"", 
"<a class=\"id\" href=\"#done\">done</a>:", 
"<span class=\"ts\"/><a class=\"id\" href=\"#lock_acquired\">lock_acquired</a>(&amp;<a class=\"id\" href=\"#lock\">lock</a>-><a class=\"id\" href=\"#dep_map\">dep_map</a>, <a class=\"id\" href=\"#ip\">ip</a>);", 
"<span class=\"ts\"/><span class=\"comment\">/* got the lock - rejoice! */</span>", 
"<span class=\"ts\"/><a class=\"id\" href=\"#mutex_remove_waiter\">mutex_remove_waiter</a>(<a class=\"id\" href=\"#lock\">lock</a>, &amp;<a class=\"id\" href=\"#waiter\">waiter</a>, <a class=\"id\" href=\"#current_thread_info\">current_thread_info</a>());", 
"<span class=\"ts\"/><a class=\"id\" href=\"#mutex_set_owner\">mutex_set_owner</a>(<a class=\"id\" href=\"#lock\">lock</a>);", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/* set it to 0 if there are no waiters left: */</span>", 
"<span class=\"ts\"/>if (<a class=\"id\" href=\"#likely\">likely</a>(<a class=\"id\" href=\"#list_empty\">list_empty</a>(&amp;<a class=\"id\" href=\"#lock\">lock</a>-><a class=\"id\" href=\"#wait_list\">wait_list</a>)))", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#atomic_set\">atomic_set</a>(&amp;<a class=\"id\" href=\"#lock\">lock</a>-><a class=\"id\" href=\"#count\">count</a>, 0);", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#spin_unlock_mutex\">spin_unlock_mutex</a>(&amp;<a class=\"id\" href=\"#lock\">lock</a>-><a class=\"id\" href=\"#wait_lock\">wait_lock</a>, <a class=\"id\" href=\"#flags\">flags</a>);", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#debug_mutex_free_waiter\">debug_mutex_free_waiter</a>(&amp;<a class=\"id\" href=\"#waiter\">waiter</a>);", 
"<span class=\"ts\"/><a class=\"id\" href=\"#preempt_enable\">preempt_enable</a>();", 
"", 
"<span class=\"ts\"/>return 0;", 
"}", 
"", 
"#<a class=\"id\" href=\"#ifdef\">ifdef</a> <a class=\"id\" href=\"#CONFIG_DEBUG_LOCK_ALLOC\">CONFIG_DEBUG_LOCK_ALLOC</a>", 
"void <a class=\"id\" href=\"#__sched\">__sched</a>", 
"<a class=\"id\" href=\"#mutex_lock_nested\">mutex_lock_nested</a>(struct <a class=\"id\" href=\"#mutex\">mutex</a> *<a class=\"id\" href=\"#lock\">lock</a>, unsigned int <a class=\"id\" href=\"#subclass\">subclass</a>)", 
"{", 
"<span class=\"ts\"/><a class=\"id\" href=\"#might_sleep\">might_sleep</a>();", 
"<span class=\"ts\"/><a class=\"id\" href=\"#__mutex_lock_common\">__mutex_lock_common</a>(<a class=\"id\" href=\"#lock\">lock</a>, <a class=\"id\" href=\"#TASK_UNINTERRUPTIBLE\">TASK_UNINTERRUPTIBLE</a>, <a class=\"id\" href=\"#subclass\">subclass</a>, <a class=\"id\" href=\"#_RET_IP_\">_RET_IP_</a>);", 
"}", 
"", 
"<a class=\"id\" href=\"#EXPORT_SYMBOL_GPL\">EXPORT_SYMBOL_GPL</a>(<a class=\"id\" href=\"#mutex_lock_nested\">mutex_lock_nested</a>);", 
"", 
"int <a class=\"id\" href=\"#__sched\">__sched</a>", 
"<a class=\"id\" href=\"#mutex_lock_killable_nested\">mutex_lock_killable_nested</a>(struct <a class=\"id\" href=\"#mutex\">mutex</a> *<a class=\"id\" href=\"#lock\">lock</a>, unsigned int <a class=\"id\" href=\"#subclass\">subclass</a>)", 
"{", 
"<span class=\"ts\"/><a class=\"id\" href=\"#might_sleep\">might_sleep</a>();", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#__mutex_lock_common\">__mutex_lock_common</a>(<a class=\"id\" href=\"#lock\">lock</a>, <a class=\"id\" href=\"#TASK_KILLABLE\">TASK_KILLABLE</a>, <a class=\"id\" href=\"#subclass\">subclass</a>, <a class=\"id\" href=\"#_RET_IP_\">_RET_IP_</a>);", 
"}", 
"<a class=\"id\" href=\"#EXPORT_SYMBOL_GPL\">EXPORT_SYMBOL_GPL</a>(<a class=\"id\" href=\"#mutex_lock_killable_nested\">mutex_lock_killable_nested</a>);", 
"", 
"int <a class=\"id\" href=\"#__sched\">__sched</a>", 
"<a class=\"id\" href=\"#mutex_lock_interruptible_nested\">mutex_lock_interruptible_nested</a>(struct <a class=\"id\" href=\"#mutex\">mutex</a> *<a class=\"id\" href=\"#lock\">lock</a>, unsigned int <a class=\"id\" href=\"#subclass\">subclass</a>)", 
"{", 
"<span class=\"ts\"/><a class=\"id\" href=\"#might_sleep\">might_sleep</a>();", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#__mutex_lock_common\">__mutex_lock_common</a>(<a class=\"id\" href=\"#lock\">lock</a>, <a class=\"id\" href=\"#TASK_INTERRUPTIBLE\">TASK_INTERRUPTIBLE</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>   <a class=\"id\" href=\"#subclass\">subclass</a>, <a class=\"id\" href=\"#_RET_IP_\">_RET_IP_</a>);", 
"}", 
"", 
"<a class=\"id\" href=\"#EXPORT_SYMBOL_GPL\">EXPORT_SYMBOL_GPL</a>(<a class=\"id\" href=\"#mutex_lock_interruptible_nested\">mutex_lock_interruptible_nested</a>);", 
"#<a class=\"id\" href=\"#endif\">endif</a>", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * Release the lock, slowpath:</span>", 
"<span class=\"comment\"> */</span>", 
"static <a class=\"id\" href=\"#inline\">inline</a> void", 
"<a class=\"id\" href=\"#__mutex_unlock_common_slowpath\">__mutex_unlock_common_slowpath</a>(<a class=\"id\" href=\"#atomic_t\">atomic_t</a> *<a class=\"id\" href=\"#lock_count\">lock_count</a>, int <a class=\"id\" href=\"#nested\">nested</a>)", 
"{", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#mutex\">mutex</a> *<a class=\"id\" href=\"#lock\">lock</a> = <a class=\"id\" href=\"#container_of\">container_of</a>(<a class=\"id\" href=\"#lock_count\">lock_count</a>, struct <a class=\"id\" href=\"#mutex\">mutex</a>, <a class=\"id\" href=\"#count\">count</a>);", 
"<span class=\"ts\"/>unsigned long <a class=\"id\" href=\"#flags\">flags</a>;", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#spin_lock_mutex\">spin_lock_mutex</a>(&amp;<a class=\"id\" href=\"#lock\">lock</a>-><a class=\"id\" href=\"#wait_lock\">wait_lock</a>, <a class=\"id\" href=\"#flags\">flags</a>);", 
"<span class=\"ts\"/><a class=\"id\" href=\"#mutex_release\">mutex_release</a>(&amp;<a class=\"id\" href=\"#lock\">lock</a>-><a class=\"id\" href=\"#dep_map\">dep_map</a>, <a class=\"id\" href=\"#nested\">nested</a>, <a class=\"id\" href=\"#_RET_IP_\">_RET_IP_</a>);", 
"<span class=\"ts\"/><a class=\"id\" href=\"#debug_mutex_unlock\">debug_mutex_unlock</a>(<a class=\"id\" href=\"#lock\">lock</a>);", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * some architectures leave the lock unlocked in the fastpath failure</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * case, others need to leave it locked. In the later case we have to</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * unlock it here</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>if (<a class=\"id\" href=\"#__mutex_slowpath_needs_to_unlock\">__mutex_slowpath_needs_to_unlock</a>())", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#atomic_set\">atomic_set</a>(&amp;<a class=\"id\" href=\"#lock\">lock</a>-><a class=\"id\" href=\"#count\">count</a>, 1);", 
"", 
"<span class=\"ts\"/>if (!<a class=\"id\" href=\"#list_empty\">list_empty</a>(&amp;<a class=\"id\" href=\"#lock\">lock</a>-><a class=\"id\" href=\"#wait_list\">wait_list</a>)) {", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"comment\">/* get the first entry from the wait-list: */</span>", 
"<span class=\"ts\"/><span class=\"ts\"/>struct <a class=\"id\" href=\"#mutex_waiter\">mutex_waiter</a> *<a class=\"id\" href=\"#waiter\">waiter</a> =", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#list_entry\">list_entry</a>(<a class=\"id\" href=\"#lock\">lock</a>-><a class=\"id\" href=\"#wait_list\">wait_list</a>.<a class=\"id\" href=\"#next\">next</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>   struct <a class=\"id\" href=\"#mutex_waiter\">mutex_waiter</a>, <a class=\"id\" href=\"#list\">list</a>);", 
"", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#debug_mutex_wake_waiter\">debug_mutex_wake_waiter</a>(<a class=\"id\" href=\"#lock\">lock</a>, <a class=\"id\" href=\"#waiter\">waiter</a>);", 
"", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#wake_up_process\">wake_up_process</a>(<a class=\"id\" href=\"#waiter\">waiter</a>-><a class=\"id\" href=\"#task\">task</a>);", 
"<span class=\"ts\"/>}", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#spin_unlock_mutex\">spin_unlock_mutex</a>(&amp;<a class=\"id\" href=\"#lock\">lock</a>-><a class=\"id\" href=\"#wait_lock\">wait_lock</a>, <a class=\"id\" href=\"#flags\">flags</a>);", 
"}", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * Release the lock, slowpath:</span>", 
"<span class=\"comment\"> */</span>", 
"static <a class=\"id\" href=\"#__used\">__used</a> <a class=\"id\" href=\"#noinline\">noinline</a> void", 
"<a class=\"id\" href=\"#__mutex_unlock_slowpath\">__mutex_unlock_slowpath</a>(<a class=\"id\" href=\"#atomic_t\">atomic_t</a> *<a class=\"id\" href=\"#lock_count\">lock_count</a>)", 
"{", 
"<span class=\"ts\"/><a class=\"id\" href=\"#__mutex_unlock_common_slowpath\">__mutex_unlock_common_slowpath</a>(<a class=\"id\" href=\"#lock_count\">lock_count</a>, 1);", 
"}", 
"", 
"#<a class=\"id\" href=\"#ifndef\">ifndef</a> <a class=\"id\" href=\"#CONFIG_DEBUG_LOCK_ALLOC\">CONFIG_DEBUG_LOCK_ALLOC</a>", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * Here come the less common (and hence less performance-critical) APIs:</span>", 
"<span class=\"comment\"> * mutex_lock_interruptible() and mutex_trylock().</span>", 
"<span class=\"comment\"> */</span>", 
"static <a class=\"id\" href=\"#noinline\">noinline</a> int <a class=\"id\" href=\"#__sched\">__sched</a>", 
"<a class=\"id\" href=\"#__mutex_lock_killable_slowpath\">__mutex_lock_killable_slowpath</a>(<a class=\"id\" href=\"#atomic_t\">atomic_t</a> *<a class=\"id\" href=\"#lock_count\">lock_count</a>);", 
"", 
"static <a class=\"id\" href=\"#noinline\">noinline</a> int <a class=\"id\" href=\"#__sched\">__sched</a>", 
"<a class=\"id\" href=\"#__mutex_lock_interruptible_slowpath\">__mutex_lock_interruptible_slowpath</a>(<a class=\"id\" href=\"#atomic_t\">atomic_t</a> *<a class=\"id\" href=\"#lock_count\">lock_count</a>);", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * mutex_lock_interruptible - acquire the mutex, interruptible</span>", 
"<span class=\"comment\"> * @lock: the mutex to be acquired</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Lock the mutex like mutex_lock(), and return 0 if the mutex has</span>", 
"<span class=\"comment\"> * been acquired or sleep until the mutex becomes available. If a</span>", 
"<span class=\"comment\"> * signal arrives while waiting for the lock then this function</span>", 
"<span class=\"comment\"> * returns -EINTR.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * This function is similar to (but not equivalent to) down_interruptible().</span>", 
"<span class=\"comment\"> */</span>", 
"int <a class=\"id\" href=\"#__sched\">__sched</a> <a class=\"id\" href=\"#mutex_lock_interruptible\">mutex_lock_interruptible</a>(struct <a class=\"id\" href=\"#mutex\">mutex</a> *<a class=\"id\" href=\"#lock\">lock</a>)", 
"{", 
"<span class=\"ts\"/>int <a class=\"id\" href=\"#ret\">ret</a>;", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#might_sleep\">might_sleep</a>();", 
"<span class=\"ts\"/><a class=\"id\" href=\"#ret\">ret</a> =  <a class=\"id\" href=\"#__mutex_fastpath_lock_retval\">__mutex_fastpath_lock_retval</a>", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>(&amp;<a class=\"id\" href=\"#lock\">lock</a>-><a class=\"id\" href=\"#count\">count</a>, <a class=\"id\" href=\"#__mutex_lock_interruptible_slowpath\">__mutex_lock_interruptible_slowpath</a>);", 
"<span class=\"ts\"/>if (!<a class=\"id\" href=\"#ret\">ret</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#mutex_set_owner\">mutex_set_owner</a>(<a class=\"id\" href=\"#lock\">lock</a>);", 
"", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#ret\">ret</a>;", 
"}", 
"", 
"<a class=\"id\" href=\"#EXPORT_SYMBOL\">EXPORT_SYMBOL</a>(<a class=\"id\" href=\"#mutex_lock_interruptible\">mutex_lock_interruptible</a>);", 
"", 
"int <a class=\"id\" href=\"#__sched\">__sched</a> <a class=\"id\" href=\"#mutex_lock_killable\">mutex_lock_killable</a>(struct <a class=\"id\" href=\"#mutex\">mutex</a> *<a class=\"id\" href=\"#lock\">lock</a>)", 
"{", 
"<span class=\"ts\"/>int <a class=\"id\" href=\"#ret\">ret</a>;", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#might_sleep\">might_sleep</a>();", 
"<span class=\"ts\"/><a class=\"id\" href=\"#ret\">ret</a> = <a class=\"id\" href=\"#__mutex_fastpath_lock_retval\">__mutex_fastpath_lock_retval</a>", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>(&amp;<a class=\"id\" href=\"#lock\">lock</a>-><a class=\"id\" href=\"#count\">count</a>, <a class=\"id\" href=\"#__mutex_lock_killable_slowpath\">__mutex_lock_killable_slowpath</a>);", 
"<span class=\"ts\"/>if (!<a class=\"id\" href=\"#ret\">ret</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#mutex_set_owner\">mutex_set_owner</a>(<a class=\"id\" href=\"#lock\">lock</a>);", 
"", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#ret\">ret</a>;", 
"}", 
"<a class=\"id\" href=\"#EXPORT_SYMBOL\">EXPORT_SYMBOL</a>(<a class=\"id\" href=\"#mutex_lock_killable\">mutex_lock_killable</a>);", 
"", 
"static <a class=\"id\" href=\"#__used\">__used</a> <a class=\"id\" href=\"#noinline\">noinline</a> void <a class=\"id\" href=\"#__sched\">__sched</a>", 
"<a class=\"id\" href=\"#__mutex_lock_slowpath\">__mutex_lock_slowpath</a>(<a class=\"id\" href=\"#atomic_t\">atomic_t</a> *<a class=\"id\" href=\"#lock_count\">lock_count</a>)", 
"{", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#mutex\">mutex</a> *<a class=\"id\" href=\"#lock\">lock</a> = <a class=\"id\" href=\"#container_of\">container_of</a>(<a class=\"id\" href=\"#lock_count\">lock_count</a>, struct <a class=\"id\" href=\"#mutex\">mutex</a>, <a class=\"id\" href=\"#count\">count</a>);", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#__mutex_lock_common\">__mutex_lock_common</a>(<a class=\"id\" href=\"#lock\">lock</a>, <a class=\"id\" href=\"#TASK_UNINTERRUPTIBLE\">TASK_UNINTERRUPTIBLE</a>, 0, <a class=\"id\" href=\"#_RET_IP_\">_RET_IP_</a>);", 
"}", 
"", 
"static <a class=\"id\" href=\"#noinline\">noinline</a> int <a class=\"id\" href=\"#__sched\">__sched</a>", 
"<a class=\"id\" href=\"#__mutex_lock_killable_slowpath\">__mutex_lock_killable_slowpath</a>(<a class=\"id\" href=\"#atomic_t\">atomic_t</a> *<a class=\"id\" href=\"#lock_count\">lock_count</a>)", 
"{", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#mutex\">mutex</a> *<a class=\"id\" href=\"#lock\">lock</a> = <a class=\"id\" href=\"#container_of\">container_of</a>(<a class=\"id\" href=\"#lock_count\">lock_count</a>, struct <a class=\"id\" href=\"#mutex\">mutex</a>, <a class=\"id\" href=\"#count\">count</a>);", 
"", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#__mutex_lock_common\">__mutex_lock_common</a>(<a class=\"id\" href=\"#lock\">lock</a>, <a class=\"id\" href=\"#TASK_KILLABLE\">TASK_KILLABLE</a>, 0, <a class=\"id\" href=\"#_RET_IP_\">_RET_IP_</a>);", 
"}", 
"", 
"static <a class=\"id\" href=\"#noinline\">noinline</a> int <a class=\"id\" href=\"#__sched\">__sched</a>", 
"<a class=\"id\" href=\"#__mutex_lock_interruptible_slowpath\">__mutex_lock_interruptible_slowpath</a>(<a class=\"id\" href=\"#atomic_t\">atomic_t</a> *<a class=\"id\" href=\"#lock_count\">lock_count</a>)", 
"{", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#mutex\">mutex</a> *<a class=\"id\" href=\"#lock\">lock</a> = <a class=\"id\" href=\"#container_of\">container_of</a>(<a class=\"id\" href=\"#lock_count\">lock_count</a>, struct <a class=\"id\" href=\"#mutex\">mutex</a>, <a class=\"id\" href=\"#count\">count</a>);", 
"", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#__mutex_lock_common\">__mutex_lock_common</a>(<a class=\"id\" href=\"#lock\">lock</a>, <a class=\"id\" href=\"#TASK_INTERRUPTIBLE\">TASK_INTERRUPTIBLE</a>, 0, <a class=\"id\" href=\"#_RET_IP_\">_RET_IP_</a>);", 
"}", 
"#<a class=\"id\" href=\"#endif\">endif</a>", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * Spinlock based trylock, we take the spinlock and check whether we</span>", 
"<span class=\"comment\"> * can get the lock:</span>", 
"<span class=\"comment\"> */</span>", 
"static <a class=\"id\" href=\"#inline\">inline</a> int <a class=\"id\" href=\"#__mutex_trylock_slowpath\">__mutex_trylock_slowpath</a>(<a class=\"id\" href=\"#atomic_t\">atomic_t</a> *<a class=\"id\" href=\"#lock_count\">lock_count</a>)", 
"{", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#mutex\">mutex</a> *<a class=\"id\" href=\"#lock\">lock</a> = <a class=\"id\" href=\"#container_of\">container_of</a>(<a class=\"id\" href=\"#lock_count\">lock_count</a>, struct <a class=\"id\" href=\"#mutex\">mutex</a>, <a class=\"id\" href=\"#count\">count</a>);", 
"<span class=\"ts\"/>unsigned long <a class=\"id\" href=\"#flags\">flags</a>;", 
"<span class=\"ts\"/>int <a class=\"id\" href=\"#prev\">prev</a>;", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#spin_lock_mutex\">spin_lock_mutex</a>(&amp;<a class=\"id\" href=\"#lock\">lock</a>-><a class=\"id\" href=\"#wait_lock\">wait_lock</a>, <a class=\"id\" href=\"#flags\">flags</a>);", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#prev\">prev</a> = <a class=\"id\" href=\"#atomic_xchg\">atomic_xchg</a>(&amp;<a class=\"id\" href=\"#lock\">lock</a>-><a class=\"id\" href=\"#count\">count</a>, -1);", 
"<span class=\"ts\"/>if (<a class=\"id\" href=\"#likely\">likely</a>(<a class=\"id\" href=\"#prev\">prev</a> == 1)) {", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#mutex_set_owner\">mutex_set_owner</a>(<a class=\"id\" href=\"#lock\">lock</a>);", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#mutex_acquire\">mutex_acquire</a>(&amp;<a class=\"id\" href=\"#lock\">lock</a>-><a class=\"id\" href=\"#dep_map\">dep_map</a>, 0, 1, <a class=\"id\" href=\"#_RET_IP_\">_RET_IP_</a>);", 
"<span class=\"ts\"/>}", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/* Set it back to 0 if there are no waiters: */</span>", 
"<span class=\"ts\"/>if (<a class=\"id\" href=\"#likely\">likely</a>(<a class=\"id\" href=\"#list_empty\">list_empty</a>(&amp;<a class=\"id\" href=\"#lock\">lock</a>-><a class=\"id\" href=\"#wait_list\">wait_list</a>)))", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#atomic_set\">atomic_set</a>(&amp;<a class=\"id\" href=\"#lock\">lock</a>-><a class=\"id\" href=\"#count\">count</a>, 0);", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#spin_unlock_mutex\">spin_unlock_mutex</a>(&amp;<a class=\"id\" href=\"#lock\">lock</a>-><a class=\"id\" href=\"#wait_lock\">wait_lock</a>, <a class=\"id\" href=\"#flags\">flags</a>);", 
"", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#prev\">prev</a> == 1;", 
"}", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * mutex_trylock - try to acquire the mutex, without waiting</span>", 
"<span class=\"comment\"> * @lock: the mutex to be acquired</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Try to acquire the mutex atomically. Returns 1 if the mutex</span>", 
"<span class=\"comment\"> * has been acquired successfully, and 0 on contention.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * NOTE: this function follows the spin_trylock() convention, so</span>", 
"<span class=\"comment\"> * it is negated from the down_trylock() return values! Be careful</span>", 
"<span class=\"comment\"> * about this when converting semaphore users to mutexes.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * This function must not be used in interrupt context. The</span>", 
"<span class=\"comment\"> * mutex must be released by the same task that acquired it.</span>", 
"<span class=\"comment\"> */</span>", 
"int <a class=\"id\" href=\"#__sched\">__sched</a> <a class=\"id\" href=\"#mutex_trylock\">mutex_trylock</a>(struct <a class=\"id\" href=\"#mutex\">mutex</a> *<a class=\"id\" href=\"#lock\">lock</a>)", 
"{", 
"<span class=\"ts\"/>int <a class=\"id\" href=\"#ret\">ret</a>;", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#ret\">ret</a> = <a class=\"id\" href=\"#__mutex_fastpath_trylock\">__mutex_fastpath_trylock</a>(&amp;<a class=\"id\" href=\"#lock\">lock</a>-><a class=\"id\" href=\"#count\">count</a>, <a class=\"id\" href=\"#__mutex_trylock_slowpath\">__mutex_trylock_slowpath</a>);", 
"<span class=\"ts\"/>if (<a class=\"id\" href=\"#ret\">ret</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#mutex_set_owner\">mutex_set_owner</a>(<a class=\"id\" href=\"#lock\">lock</a>);", 
"", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#ret\">ret</a>;", 
"}", 
"<a class=\"id\" href=\"#EXPORT_SYMBOL\">EXPORT_SYMBOL</a>(<a class=\"id\" href=\"#mutex_trylock\">mutex_trylock</a>);", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * atomic_dec_and_mutex_lock - return holding mutex if we dec to 0</span>", 
"<span class=\"comment\"> * @cnt: the atomic which we are to dec</span>", 
"<span class=\"comment\"> * @lock: the mutex to return holding if we dec to 0</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * return true and hold lock if we dec to 0, return false otherwise</span>", 
"<span class=\"comment\"> */</span>", 
"int <a class=\"id\" href=\"#atomic_dec_and_mutex_lock\">atomic_dec_and_mutex_lock</a>(<a class=\"id\" href=\"#atomic_t\">atomic_t</a> *<a class=\"id\" href=\"#cnt\">cnt</a>, struct <a class=\"id\" href=\"#mutex\">mutex</a> *<a class=\"id\" href=\"#lock\">lock</a>)", 
"{", 
"<span class=\"ts\"/><span class=\"comment\">/* dec if we can't possibly hit 0 */</span>", 
"<span class=\"ts\"/>if (<a class=\"id\" href=\"#atomic_add_unless\">atomic_add_unless</a>(<a class=\"id\" href=\"#cnt\">cnt</a>, -1, 1))", 
"<span class=\"ts\"/><span class=\"ts\"/>return 0;", 
"<span class=\"ts\"/><span class=\"comment\">/* we might hit 0, so take the lock */</span>", 
"<span class=\"ts\"/><a class=\"id\" href=\"#mutex_lock\">mutex_lock</a>(<a class=\"id\" href=\"#lock\">lock</a>);", 
"<span class=\"ts\"/>if (!<a class=\"id\" href=\"#atomic_dec_and_test\">atomic_dec_and_test</a>(<a class=\"id\" href=\"#cnt\">cnt</a>)) {", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"comment\">/* when we actually did the dec, we didn't hit 0 */</span>", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#mutex_unlock\">mutex_unlock</a>(<a class=\"id\" href=\"#lock\">lock</a>);", 
"<span class=\"ts\"/><span class=\"ts\"/>return 0;", 
"<span class=\"ts\"/>}", 
"<span class=\"ts\"/><span class=\"comment\">/* we hit 0, and we hold the lock */</span>", 
"<span class=\"ts\"/>return 1;", 
"}", 
"<a class=\"id\" href=\"#EXPORT_SYMBOL\">EXPORT_SYMBOL</a>(<a class=\"id\" href=\"#atomic_dec_and_mutex_lock\">atomic_dec_and_mutex_lock</a>);", 
];
xr_frag_insert('l/a3/270583d8d383f05aabc15c40ee3c1d846ff587.xr', __xr_tmp);
