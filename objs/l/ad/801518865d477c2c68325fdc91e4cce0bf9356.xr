var __xr_tmp = [
"#<a class=\"id\" href=\"#ifndef\">ifndef</a> <a class=\"id\" href=\"#_SCSI_SCSI_HOST_H\">_SCSI_SCSI_HOST_H</a>", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#_SCSI_SCSI_HOST_H\">_SCSI_SCSI_HOST_H</a>", 
"", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#device\">device</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#list\">list</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#types\">types</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#workqueue\">workqueue</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#mutex\">mutex</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#scsi\">scsi</a>/<a class=\"id\" href=\"#scsi\">scsi</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"", 
"struct <a class=\"id\" href=\"#request_queue\">request_queue</a>;", 
"struct <a class=\"id\" href=\"#block_device\">block_device</a>;", 
"struct <a class=\"id\" href=\"#completion\">completion</a>;", 
"struct <a class=\"id\" href=\"#module\">module</a>;", 
"struct <a class=\"id\" href=\"#scsi_cmnd\">scsi_cmnd</a>;", 
"struct <a class=\"id\" href=\"#scsi_device\">scsi_device</a>;", 
"struct <a class=\"id\" href=\"#scsi_target\">scsi_target</a>;", 
"struct <a class=\"id\" href=\"#Scsi_Host\">Scsi_Host</a>;", 
"struct <a class=\"id\" href=\"#scsi_host_cmd_pool\">scsi_host_cmd_pool</a>;", 
"struct <a class=\"id\" href=\"#scsi_transport_template\">scsi_transport_template</a>;", 
"struct <a class=\"id\" href=\"#blk_queue_tags\">blk_queue_tags</a>;", 
"", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * The various choices mean:</span>", 
"<span class=\"comment\"> * NONE: Self evident.<span class=\"ts\"/>Host adapter is not capable of scatter-gather.</span>", 
"<span class=\"comment\"> * ALL:<span class=\"ts\"/> Means that the host adapter module can do scatter-gather,</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/> and that there is no limit to the size of the table to which</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/> we scatter/gather data.  The value we set here is the maximum</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/> single element sglist.  To use chained sglists, the adapter</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/> has to set a value beyond ALL (and correctly use the chain</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/> handling API.</span>", 
"<span class=\"comment\"> * Anything else:  Indicates the maximum number of chains that can be</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/> used in one scatter-gather request.</span>", 
"<span class=\"comment\"> */</span>", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#SG_NONE\">SG_NONE</a> 0", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#SG_ALL\">SG_ALL</a><span class=\"ts\"/><a class=\"id\" href=\"#SCSI_MAX_SG_SEGMENTS\">SCSI_MAX_SG_SEGMENTS</a>", 
"", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#MODE_UNKNOWN\">MODE_UNKNOWN</a> 0x00", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#MODE_INITIATOR\">MODE_INITIATOR</a> 0x01", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#MODE_TARGET\">MODE_TARGET</a> 0x02", 
"", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#DISABLE_CLUSTERING\">DISABLE_CLUSTERING</a> 0", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#ENABLE_CLUSTERING\">ENABLE_CLUSTERING</a> 1", 
"", 
"enum {", 
"<span class=\"ts\"/><a class=\"id\" href=\"#SCSI_QDEPTH_DEFAULT\">SCSI_QDEPTH_DEFAULT</a>,<span class=\"ts\"/><span class=\"comment\">/* default requested change, e.g. from sysfs */</span>", 
"<span class=\"ts\"/><a class=\"id\" href=\"#SCSI_QDEPTH_QFULL\">SCSI_QDEPTH_QFULL</a>,<span class=\"ts\"/><span class=\"comment\">/* scsi-ml requested due to queue full */</span>", 
"<span class=\"ts\"/><a class=\"id\" href=\"#SCSI_QDEPTH_RAMP_UP\">SCSI_QDEPTH_RAMP_UP</a>,<span class=\"ts\"/><span class=\"comment\">/* scsi-ml requested due to threshhold event */</span>", 
"};", 
"", 
"struct <a class=\"id\" href=\"#scsi_host_template\">scsi_host_template</a> {", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#module\">module</a> *<a class=\"id\" href=\"#module\">module</a>;", 
"<span class=\"ts\"/>const char *<a class=\"id\" href=\"#name\">name</a>;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Used to initialize old-style drivers.  For new-style drivers</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * just perform all work in your module initialization function.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Status:  OBSOLETE</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>int (* <a class=\"id\" href=\"#detect\">detect</a>)(struct <a class=\"id\" href=\"#scsi_host_template\">scsi_host_template</a> *);", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Used as unload callback for hosts with old-style drivers.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Status: OBSOLETE</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>int (* <a class=\"id\" href=\"#release\">release</a>)(struct <a class=\"id\" href=\"#Scsi_Host\">Scsi_Host</a> *);", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * The info function will return whatever useful information the</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * developer sees fit.  If not provided, then the name field will</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * be used instead.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Status: OPTIONAL</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>const char *(* <a class=\"id\" href=\"#info\">info</a>)(struct <a class=\"id\" href=\"#Scsi_Host\">Scsi_Host</a> *);", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Ioctl interface</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Status: OPTIONAL</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>int (* <a class=\"id\" href=\"#ioctl\">ioctl</a>)(struct <a class=\"id\" href=\"#scsi_device\">scsi_device</a> *<a class=\"id\" href=\"#dev\">dev</a>, int <a class=\"id\" href=\"#cmd\">cmd</a>, void <a class=\"id\" href=\"#__user\">__user</a> *<a class=\"id\" href=\"#arg\">arg</a>);", 
"", 
"", 
"#<a class=\"id\" href=\"#ifdef\">ifdef</a> <a class=\"id\" href=\"#CONFIG_COMPAT\">CONFIG_COMPAT</a>", 
"<span class=\"ts\"/><span class=\"comment\">/* </span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Compat handler. Handle 32bit ABI.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * When unknown ioctl is passed return -ENOIOCTLCMD.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Status: OPTIONAL</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>int (* <a class=\"id\" href=\"#compat_ioctl\">compat_ioctl</a>)(struct <a class=\"id\" href=\"#scsi_device\">scsi_device</a> *<a class=\"id\" href=\"#dev\">dev</a>, int <a class=\"id\" href=\"#cmd\">cmd</a>, void <a class=\"id\" href=\"#__user\">__user</a> *<a class=\"id\" href=\"#arg\">arg</a>);", 
"#<a class=\"id\" href=\"#endif\">endif</a>", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * The queuecommand function is used to queue up a scsi</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * command block to the LLDD.  When the driver finished</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * processing the command the done callback is invoked.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * If queuecommand returns 0, then the HBA has accepted the</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * command.  The done() function must be called on the command</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * when the driver has finished with it. (you may call done on the</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * command before queuecommand returns, but in this case you</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * *must* return 0 from queuecommand).</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Queuecommand may also reject the command, in which case it may</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * not touch the command and must not call done() for it.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * There are two possible rejection returns:</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *   SCSI_MLQUEUE_DEVICE_BUSY: Block this device temporarily, but</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *   allow commands to other devices serviced by this host.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *   SCSI_MLQUEUE_HOST_BUSY: Block all devices served by this</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *   host temporarily.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *</span>", 
"<span class=\"comment\">         * For compatibility, any other non-zero return is treated the</span>", 
"<span class=\"comment\">         * same as SCSI_MLQUEUE_HOST_BUSY.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * NOTE: \"temporarily\" means either until the next command for#</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * this device/host completes, or a period of time determined by</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * I/O pressure in the system if there are no other outstanding</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * commands.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * STATUS: REQUIRED</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>int (* <a class=\"id\" href=\"#queuecommand\">queuecommand</a>)(struct <a class=\"id\" href=\"#scsi_cmnd\">scsi_cmnd</a> *,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>     void (*<a class=\"id\" href=\"#done\">done</a>)(struct <a class=\"id\" href=\"#scsi_cmnd\">scsi_cmnd</a> *));", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * The transfer functions are used to queue a scsi command to</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * the LLD. When the driver is finished processing the command</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * the done callback is invoked.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * This is called to inform the LLD to transfer</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * scsi_bufflen(cmd) bytes. scsi_sg_count(cmd) speciefies the</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * number of scatterlist entried in the command and</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * scsi_sglist(cmd) returns the scatterlist.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * return values: see queuecommand</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * If the LLD accepts the cmd, it should set the result to an</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * appropriate value when completed before calling the done function.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * STATUS: REQUIRED FOR TARGET DRIVERS</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/><span class=\"comment\">/* TODO: rename */</span>", 
"<span class=\"ts\"/>int (* <a class=\"id\" href=\"#transfer_response\">transfer_response</a>)(struct <a class=\"id\" href=\"#scsi_cmnd\">scsi_cmnd</a> *,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>  void (*<a class=\"id\" href=\"#done\">done</a>)(struct <a class=\"id\" href=\"#scsi_cmnd\">scsi_cmnd</a> *));", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * This is an error handling strategy routine.  You don't need to</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * define one of these if you don't want to - there is a default</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * routine that is present that should work in most cases.  For those</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * driver authors that have the inclination and ability to write their</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * own strategy routine, this is where it is specified.  Note - the</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * strategy routine is *ALWAYS* run in the context of the kernel eh</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * thread.  Thus you are guaranteed to *NOT* be in an interrupt</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * handler when you execute this, and you are also guaranteed to</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * *NOT* have any other commands being queued while you are in the</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * strategy routine. When you return from this function, operations</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * return to normal.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * See scsi_error.c scsi_unjam_host for additional comments about</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * what this function should and should not be attempting to do.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Status: REQUIRED<span class=\"ts\"/>(at least one of them)</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>int (* <a class=\"id\" href=\"#eh_abort_handler\">eh_abort_handler</a>)(struct <a class=\"id\" href=\"#scsi_cmnd\">scsi_cmnd</a> *);", 
"<span class=\"ts\"/>int (* <a class=\"id\" href=\"#eh_device_reset_handler\">eh_device_reset_handler</a>)(struct <a class=\"id\" href=\"#scsi_cmnd\">scsi_cmnd</a> *);", 
"<span class=\"ts\"/>int (* <a class=\"id\" href=\"#eh_target_reset_handler\">eh_target_reset_handler</a>)(struct <a class=\"id\" href=\"#scsi_cmnd\">scsi_cmnd</a> *);", 
"<span class=\"ts\"/>int (* <a class=\"id\" href=\"#eh_bus_reset_handler\">eh_bus_reset_handler</a>)(struct <a class=\"id\" href=\"#scsi_cmnd\">scsi_cmnd</a> *);", 
"<span class=\"ts\"/>int (* <a class=\"id\" href=\"#eh_host_reset_handler\">eh_host_reset_handler</a>)(struct <a class=\"id\" href=\"#scsi_cmnd\">scsi_cmnd</a> *);", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Before the mid layer attempts to scan for a new device where none</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * currently exists, it will call this entry in your driver.  Should</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * your driver need to allocate any structs or perform any other init</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * items in order to send commands to a currently unused target/lun</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * combo, then this is where you can perform those allocations.  This</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * is specifically so that drivers won't have to perform any kind of</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * \"is this a new device\" checks in their queuecommand routine,</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * thereby making the hot path a bit quicker.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Return values: 0 on success, non-0 on failure</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Deallocation:  If we didn't find any devices at this ID, you will</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * get an immediate call to slave_destroy().  If we find something</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * here then you will get a call to slave_configure(), then the</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * device will be used for however long it is kept around, then when</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * the device is removed from the system (or * possibly at reboot</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * time), you will then get a call to slave_destroy().  This is</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * assuming you implement slave_configure and slave_destroy.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * However, if you allocate memory and hang it off the device struct,</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * then you must implement the slave_destroy() routine at a minimum</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * in order to avoid leaking memory</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * each time a device is tore down.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Status: OPTIONAL</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>int (* <a class=\"id\" href=\"#slave_alloc\">slave_alloc</a>)(struct <a class=\"id\" href=\"#scsi_device\">scsi_device</a> *);", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Once the device has responded to an INQUIRY and we know the</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * device is online, we call into the low level driver with the</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * struct scsi_device *.  If the low level device driver implements</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * this function, it *must* perform the task of setting the queue</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * depth on the device.  All other tasks are optional and depend</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * on what the driver supports and various implementation details.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * </span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Things currently recommended to be handled at this time include:</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * 1.  Setting the device queue depth.  Proper setting of this is</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *     described in the comments for scsi_adjust_queue_depth.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * 2.  Determining if the device supports the various synchronous</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *     negotiation protocols.  The device struct will already have</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *     responded to INQUIRY and the results of the standard items</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *     will have been shoved into the various device flag bits, eg.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *     device-&gt;sdtr will be true if the device supports SDTR messages.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * 3.  Allocating command structs that the device will need.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * 4.  Setting the default timeout on this device (if needed).</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * 5.  Anything else the low level driver might want to do on a device</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *     specific setup basis...</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * 6.  Return 0 on success, non-0 on error.  The device will be marked</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *     as offline on error so that no access will occur.  If you return</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *     non-0, your slave_destroy routine will never get called for this</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *     device, so don't leave any loose memory hanging around, clean</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *     up after yourself before returning non-0</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Status: OPTIONAL</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>int (* <a class=\"id\" href=\"#slave_configure\">slave_configure</a>)(struct <a class=\"id\" href=\"#scsi_device\">scsi_device</a> *);", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Immediately prior to deallocating the device and after all activity</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * has ceased the mid layer calls this point so that the low level</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * driver may completely detach itself from the scsi device and vice</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * versa.  The low level driver is responsible for freeing any memory</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * it allocated in the slave_alloc or slave_configure calls. </span>", 
"<span class=\"comment\"><span class=\"ts\"/> *</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Status: OPTIONAL</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>void (* <a class=\"id\" href=\"#slave_destroy\">slave_destroy</a>)(struct <a class=\"id\" href=\"#scsi_device\">scsi_device</a> *);", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Before the mid layer attempts to scan for a new device attached</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * to a target where no target currently exists, it will call this</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * entry in your driver.  Should your driver need to allocate any</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * structs or perform any other init items in order to send commands</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * to a currently unused target, then this is where you can perform</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * those allocations.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Return values: 0 on success, non-0 on failure</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Status: OPTIONAL</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>int (* <a class=\"id\" href=\"#target_alloc\">target_alloc</a>)(struct <a class=\"id\" href=\"#scsi_target\">scsi_target</a> *);", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Immediately prior to deallocating the target structure, and</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * after all activity to attached scsi devices has ceased, the</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * midlayer calls this point so that the driver may deallocate</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * and terminate any references to the target.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Status: OPTIONAL</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>void (* <a class=\"id\" href=\"#target_destroy\">target_destroy</a>)(struct <a class=\"id\" href=\"#scsi_target\">scsi_target</a> *);", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * If a host has the ability to discover targets on its own instead</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * of scanning the entire bus, it can fill in this function and</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * call scsi_scan_host().  This function will be called periodically</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * until it returns 1 with the scsi_host and the elapsed time of</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * the scan in jiffies.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Status: OPTIONAL</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>int (* <a class=\"id\" href=\"#scan_finished\">scan_finished</a>)(struct <a class=\"id\" href=\"#Scsi_Host\">Scsi_Host</a> *, unsigned long);", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * If the host wants to be called before the scan starts, but</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * after the midlayer has set up ready for the scan, it can fill</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * in this function.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Status: OPTIONAL</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>void (* <a class=\"id\" href=\"#scan_start\">scan_start</a>)(struct <a class=\"id\" href=\"#Scsi_Host\">Scsi_Host</a> *);", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Fill in this function to allow the queue depth of this host</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * to be changeable (on a per device basis).  Returns either</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * the current queue depth setting (may be different from what</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * was passed in) or an error.  An error should only be</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * returned if the requested depth is legal but the driver was</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * unable to set it.  If the requested depth is illegal, the</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * driver should set and return the closest legal queue depth.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Status: OPTIONAL</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>int (* <a class=\"id\" href=\"#change_queue_depth\">change_queue_depth</a>)(struct <a class=\"id\" href=\"#scsi_device\">scsi_device</a> *, int, int);", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Fill in this function to allow the changing of tag types</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * (this also allows the enabling/disabling of tag command</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * queueing).  An error should only be returned if something</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * went wrong in the driver while trying to set the tag type.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * If the driver doesn't support the requested tag type, then</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * it should set the closest type it does support without</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * returning an error.  Returns the actual tag type set.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Status: OPTIONAL</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>int (* <a class=\"id\" href=\"#change_queue_type\">change_queue_type</a>)(struct <a class=\"id\" href=\"#scsi_device\">scsi_device</a> *, int);", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * This function determines the BIOS parameters for a given</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * harddisk.  These tend to be numbers that are made up by</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * the host adapter.  Parameters:</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * size, device, list (heads, sectors, cylinders)</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Status: OPTIONAL</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>int (* <a class=\"id\" href=\"#bios_param\">bios_param</a>)(struct <a class=\"id\" href=\"#scsi_device\">scsi_device</a> *, struct <a class=\"id\" href=\"#block_device\">block_device</a> *,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#sector_t\">sector_t</a>, int []);", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * This function is called when one or more partitions on the</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * device reach beyond the end of the device.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Status: OPTIONAL</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>void (*<a class=\"id\" href=\"#unlock_native_capacity\">unlock_native_capacity</a>)(struct <a class=\"id\" href=\"#scsi_device\">scsi_device</a> *);", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Can be used to export driver statistics and other infos to the</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * world outside the kernel ie. userspace and it also provides an</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * interface to feed the driver with information.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Status: OBSOLETE</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>int (*<a class=\"id\" href=\"#proc_info\">proc_info</a>)(struct <a class=\"id\" href=\"#Scsi_Host\">Scsi_Host</a> *, char *, char **, <a class=\"id\" href=\"#off_t\">off_t</a>, int, int);", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * This is an optional routine that allows the transport to become</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * involved when a scsi io timer fires. The return value tells the</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * timer routine how to finish the io timeout handling:</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * EH_HANDLED:<span class=\"ts\"/><span class=\"ts\"/>I fixed the error, please complete the command</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * EH_RESET_TIMER:<span class=\"ts\"/>I need more time, reset the timer and</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>begin counting again</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * EH_NOT_HANDLED<span class=\"ts\"/>Begin normal error recovery</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Status: OPTIONAL</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>enum <a class=\"id\" href=\"#blk_eh_timer_return\">blk_eh_timer_return</a> (*<a class=\"id\" href=\"#eh_timed_out\">eh_timed_out</a>)(struct <a class=\"id\" href=\"#scsi_cmnd\">scsi_cmnd</a> *);", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Name of proc directory</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>const char *<a class=\"id\" href=\"#proc_name\">proc_name</a>;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Used to store the procfs directory if a driver implements the</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * proc_info method.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#proc_dir_entry\">proc_dir_entry</a> *<a class=\"id\" href=\"#proc_dir\">proc_dir</a>;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * This determines if we will use a non-interrupt driven</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * or an interrupt driven scheme.  It is set to the maximum number</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * of simultaneous commands a given host adapter will accept.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>int <a class=\"id\" href=\"#can_queue\">can_queue</a>;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * In many instances, especially where disconnect / reconnect are</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * supported, our host also has an ID on the SCSI bus.  If this is</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * the case, then it must be reserved.  Please set this_id to -1 if</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * your setup is in single initiator mode, and the host lacks an</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * ID.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>int <a class=\"id\" href=\"#this_id\">this_id</a>;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * This determines the degree to which the host adapter is capable</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * of scatter-gather.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>unsigned short <a class=\"id\" href=\"#sg_tablesize\">sg_tablesize</a>;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Set this if the host adapter has limitations beside segment count.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>unsigned short <a class=\"id\" href=\"#max_sectors\">max_sectors</a>;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * DMA scatter gather segment boundary limit. A segment crossing this</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * boundary will be split in two.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>unsigned long <a class=\"id\" href=\"#dma_boundary\">dma_boundary</a>;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * This specifies \"machine infinity\" for host templates which don't</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * limit the transfer size.  Note this limit represents an absolute</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * maximum, and may be over the transfer limits allowed for</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * individual devices (e.g. 256 for SCSI-1).</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#SCSI_DEFAULT_MAX_SECTORS\">SCSI_DEFAULT_MAX_SECTORS</a><span class=\"ts\"/>1024", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * True if this host adapter can make good use of linked commands.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * This will allow more than one command to be queued to a given</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * unit on a given host.  Set this to the maximum number of command</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * blocks to be provided for each device.  Set this to 1 for one</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * command block per lun, 2 for two, etc.  Do not set this to 0.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * You should make sure that the host adapter will do the right thing</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * before you try setting this above 1.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>short <a class=\"id\" href=\"#cmd_per_lun\">cmd_per_lun</a>;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * present contains counter indicating how many boards of this</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * type were found when we did the scan.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>unsigned char <a class=\"id\" href=\"#present\">present</a>;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * This specifies the mode that a LLD supports.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>unsigned <a class=\"id\" href=\"#supported_mode\">supported_mode</a>:2;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * True if this host adapter uses unchecked DMA onto an ISA bus.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>unsigned <a class=\"id\" href=\"#unchecked_isa_dma\">unchecked_isa_dma</a>:1;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * True if this host adapter can make good use of clustering.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * I originally thought that if the tablesize was large that it</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * was a waste of CPU cycles to prepare a cluster list, but</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * it works out that the Buslogic is faster if you use a smaller</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * number of segments (i.e. use clustering).  I guess it is</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * inefficient.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>unsigned <a class=\"id\" href=\"#use_clustering\">use_clustering</a>:1;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * True for emulated SCSI host adapters (e.g. ATAPI).</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>unsigned <a class=\"id\" href=\"#emulated\">emulated</a>:1;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * True if the low-level driver performs its own reset-settle delays.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>unsigned <a class=\"id\" href=\"#skip_settle_delay\">skip_settle_delay</a>:1;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * True if we are using ordered write support.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>unsigned <a class=\"id\" href=\"#ordered_tag\">ordered_tag</a>:1;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Countdown for host blocking with no commands outstanding.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>unsigned int <a class=\"id\" href=\"#max_host_blocked\">max_host_blocked</a>;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Default value for the blocking.  If the queue is empty,</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * host_blocked counts down in the request_fn until it restarts</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * host operations as zero is reached.  </span>", 
"<span class=\"comment\"><span class=\"ts\"/> *</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * FIXME: This should probably be a value in the template</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#SCSI_DEFAULT_HOST_BLOCKED\">SCSI_DEFAULT_HOST_BLOCKED</a><span class=\"ts\"/>7", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Pointer to the sysfs class properties for this host, NULL terminated.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#device_attribute\">device_attribute</a> **<a class=\"id\" href=\"#shost_attrs\">shost_attrs</a>;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Pointer to the SCSI device properties for this host, NULL terminated.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#device_attribute\">device_attribute</a> **<a class=\"id\" href=\"#sdev_attrs\">sdev_attrs</a>;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * List of hosts per template.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * This is only for use by scsi_module.c for legacy templates.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * For these access to it is synchronized implicitly by</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * module_init/module_exit.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#list_head\">list_head</a> <a class=\"id\" href=\"#legacy_hosts\">legacy_hosts</a>;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Vendor Identifier associated with the host</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Note: When specifying vendor_id, be sure to read the</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *   Vendor Type and ID formatting requirements specified in</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *   scsi_netlink.h</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/><a class=\"id\" href=\"#u64\">u64</a> <a class=\"id\" href=\"#vendor_id\">vendor_id</a>;", 
"};", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * shost state: If you alter this, you also need to alter scsi_sysfs.c</span>", 
"<span class=\"comment\"> * (for the ascii descriptions) and the state model enforcer:</span>", 
"<span class=\"comment\"> * scsi_host_set_state()</span>", 
"<span class=\"comment\"> */</span>", 
"enum <a class=\"id\" href=\"#scsi_host_state\">scsi_host_state</a> {", 
"<span class=\"ts\"/><a class=\"id\" href=\"#SHOST_CREATED\">SHOST_CREATED</a> = 1,", 
"<span class=\"ts\"/><a class=\"id\" href=\"#SHOST_RUNNING\">SHOST_RUNNING</a>,", 
"<span class=\"ts\"/><a class=\"id\" href=\"#SHOST_CANCEL\">SHOST_CANCEL</a>,", 
"<span class=\"ts\"/><a class=\"id\" href=\"#SHOST_DEL\">SHOST_DEL</a>,", 
"<span class=\"ts\"/><a class=\"id\" href=\"#SHOST_RECOVERY\">SHOST_RECOVERY</a>,", 
"<span class=\"ts\"/><a class=\"id\" href=\"#SHOST_CANCEL_RECOVERY\">SHOST_CANCEL_RECOVERY</a>,", 
"<span class=\"ts\"/><a class=\"id\" href=\"#SHOST_DEL_RECOVERY\">SHOST_DEL_RECOVERY</a>,", 
"};", 
"", 
"struct <a class=\"id\" href=\"#Scsi_Host\">Scsi_Host</a> {", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * __devices is protected by the host_lock, but you should</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * usually use scsi_device_lookup / shost_for_each_device</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * to access it and don't care about locking yourself.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * In the rare case of beeing in irq context you can use</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * their __ prefixed variants with the lock held. NEVER</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * access this list directly from a driver.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#list_head\">list_head</a><span class=\"ts\"/><a class=\"id\" href=\"#__devices\">__devices</a>;", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#list_head\">list_head</a><span class=\"ts\"/><a class=\"id\" href=\"#__targets\">__targets</a>;", 
"<span class=\"ts\"/>", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#scsi_host_cmd_pool\">scsi_host_cmd_pool</a> *<a class=\"id\" href=\"#cmd_pool\">cmd_pool</a>;", 
"<span class=\"ts\"/><a class=\"id\" href=\"#spinlock_t\">spinlock_t</a><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#free_list_lock\">free_list_lock</a>;", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#list_head\">list_head</a><span class=\"ts\"/><a class=\"id\" href=\"#free_list\">free_list</a>; <span class=\"comment\">/* backup store of cmd structs */</span>", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#list_head\">list_head</a><span class=\"ts\"/><a class=\"id\" href=\"#starved_list\">starved_list</a>;", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#spinlock_t\">spinlock_t</a><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#default_lock\">default_lock</a>;", 
"<span class=\"ts\"/><a class=\"id\" href=\"#spinlock_t\">spinlock_t</a><span class=\"ts\"/><span class=\"ts\"/>*<a class=\"id\" href=\"#host_lock\">host_lock</a>;", 
"", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#mutex\">mutex</a><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#scan_mutex\">scan_mutex</a>;<span class=\"comment\">/* serialize scanning activity */</span>", 
"", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#list_head\">list_head</a><span class=\"ts\"/><a class=\"id\" href=\"#eh_cmd_q\">eh_cmd_q</a>;", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#task_struct\">task_struct</a>    * <a class=\"id\" href=\"#ehandler\">ehandler</a>;  <span class=\"comment\">/* Error recovery thread. */</span>", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#completion\">completion</a>     * <a class=\"id\" href=\"#eh_action\">eh_action</a>; <span class=\"comment\">/* Wait for specific actions on the</span>", 
"<span class=\"comment\"><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>      host. */</span>", 
"<span class=\"ts\"/><a class=\"id\" href=\"#wait_queue_head_t\">wait_queue_head_t</a>       <a class=\"id\" href=\"#host_wait\">host_wait</a>;", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#scsi_host_template\">scsi_host_template</a> *<a class=\"id\" href=\"#hostt\">hostt</a>;", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#scsi_transport_template\">scsi_transport_template</a> *<a class=\"id\" href=\"#transportt\">transportt</a>;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Area to keep a shared tag map (if needed, will be</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * NULL if not).</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#blk_queue_tag\">blk_queue_tag</a><span class=\"ts\"/>*<a class=\"id\" href=\"#bqt\">bqt</a>;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * The following two fields are protected with host_lock;</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * however, eh routines can safely access during eh processing</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * without acquiring the lock.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>unsigned int <a class=\"id\" href=\"#host_busy\">host_busy</a>;<span class=\"ts\"/><span class=\"ts\"/>   <span class=\"comment\">/* commands actually active on low-level */</span>", 
"<span class=\"ts\"/>unsigned int <a class=\"id\" href=\"#host_failed\">host_failed</a>;<span class=\"ts\"/>   <span class=\"comment\">/* commands that failed. */</span>", 
"<span class=\"ts\"/>unsigned int <a class=\"id\" href=\"#host_eh_scheduled\">host_eh_scheduled</a>;    <span class=\"comment\">/* EH scheduled without command */</span>", 
"    ", 
"<span class=\"ts\"/>unsigned int <a class=\"id\" href=\"#host_no\">host_no</a>;  <span class=\"comment\">/* Used for IOCTL_GET_IDLUN, /proc/scsi et al. */</span>", 
"<span class=\"ts\"/>int <a class=\"id\" href=\"#resetting\">resetting</a>; <span class=\"comment\">/* if set, it means that last_reset is a valid value */</span>", 
"<span class=\"ts\"/>unsigned long <a class=\"id\" href=\"#last_reset\">last_reset</a>;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * These three parameters can be used to allow for wide scsi,</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * and for host adapters that support multiple busses</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * The first two should be set to 1 more than the actual max id</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * or lun (i.e. 8 for normal systems).</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>unsigned int <a class=\"id\" href=\"#max_id\">max_id</a>;", 
"<span class=\"ts\"/>unsigned int <a class=\"id\" href=\"#max_lun\">max_lun</a>;", 
"<span class=\"ts\"/>unsigned int <a class=\"id\" href=\"#max_channel\">max_channel</a>;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * This is a unique identifier that must be assigned so that we</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * have some way of identifying each detected host adapter properly</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * and uniquely.  For hosts that do not support more than one card</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * in the system at one time, this does not need to be set.  It is</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * initialized to 0 in scsi_register.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>unsigned int <a class=\"id\" href=\"#unique_id\">unique_id</a>;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * The maximum length of SCSI commands that this host can accept.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Probably 12 for most host adapters, but could be 16 for others.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * or 260 if the driver supports variable length cdbs.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * For drivers that don't set this field, a value of 12 is</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * assumed.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>unsigned short <a class=\"id\" href=\"#max_cmd_len\">max_cmd_len</a>;", 
"", 
"<span class=\"ts\"/>int <a class=\"id\" href=\"#this_id\">this_id</a>;", 
"<span class=\"ts\"/>int <a class=\"id\" href=\"#can_queue\">can_queue</a>;", 
"<span class=\"ts\"/>short <a class=\"id\" href=\"#cmd_per_lun\">cmd_per_lun</a>;", 
"<span class=\"ts\"/>short unsigned int <a class=\"id\" href=\"#sg_tablesize\">sg_tablesize</a>;", 
"<span class=\"ts\"/>short unsigned int <a class=\"id\" href=\"#max_sectors\">max_sectors</a>;", 
"<span class=\"ts\"/>unsigned long <a class=\"id\" href=\"#dma_boundary\">dma_boundary</a>;", 
"<span class=\"ts\"/><span class=\"comment\">/* </span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Used to assign serial numbers to the cmds.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Protected by the host lock.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>unsigned long <a class=\"id\" href=\"#cmd_serial_number\">cmd_serial_number</a>;", 
"<span class=\"ts\"/>", 
"<span class=\"ts\"/>unsigned <a class=\"id\" href=\"#active_mode\">active_mode</a>:2;", 
"<span class=\"ts\"/>unsigned <a class=\"id\" href=\"#unchecked_isa_dma\">unchecked_isa_dma</a>:1;", 
"<span class=\"ts\"/>unsigned <a class=\"id\" href=\"#use_clustering\">use_clustering</a>:1;", 
"<span class=\"ts\"/>unsigned <a class=\"id\" href=\"#use_blk_tcq\">use_blk_tcq</a>:1;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Host has requested that no further requests come through for the</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * time being.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>unsigned <a class=\"id\" href=\"#host_self_blocked\">host_self_blocked</a>:1;", 
"    ", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Host uses correct SCSI ordering not PC ordering. The bit is</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * set for the minority of drivers whose authors actually read</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * the spec ;).</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>unsigned <a class=\"id\" href=\"#reverse_ordering\">reverse_ordering</a>:1;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Ordered write support</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>unsigned <a class=\"id\" href=\"#ordered_tag\">ordered_tag</a>:1;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/* Task mgmt function in progress */</span>", 
"<span class=\"ts\"/>unsigned <a class=\"id\" href=\"#tmf_in_progress\">tmf_in_progress</a>:1;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/* Asynchronous scan in progress */</span>", 
"<span class=\"ts\"/>unsigned <a class=\"id\" href=\"#async_scan\">async_scan</a>:1;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Optional work queue to be utilized by the transport</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>char <a class=\"id\" href=\"#work_q_name\">work_q_name</a>[20];", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#workqueue_struct\">workqueue_struct</a> *<a class=\"id\" href=\"#work_q\">work_q</a>;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Host has rejected a command because it was busy.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>unsigned int <a class=\"id\" href=\"#host_blocked\">host_blocked</a>;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Value host_blocked counts down from</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>unsigned int <a class=\"id\" href=\"#max_host_blocked\">max_host_blocked</a>;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/* Protection Information */</span>", 
"<span class=\"ts\"/>unsigned int <a class=\"id\" href=\"#prot_capabilities\">prot_capabilities</a>;", 
"<span class=\"ts\"/>unsigned char <a class=\"id\" href=\"#prot_guard_type\">prot_guard_type</a>;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * q used for scsi_tgt msgs, async events or any other requests that</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * need to be processed in userspace</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#request_queue\">request_queue</a> *<a class=\"id\" href=\"#uspace_req_q\">uspace_req_q</a>;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/* legacy crap */</span>", 
"<span class=\"ts\"/>unsigned long <a class=\"id\" href=\"#base\">base</a>;", 
"<span class=\"ts\"/>unsigned long <a class=\"id\" href=\"#io_port\">io_port</a>;", 
"<span class=\"ts\"/>unsigned char <a class=\"id\" href=\"#n_io_port\">n_io_port</a>;", 
"<span class=\"ts\"/>unsigned char <a class=\"id\" href=\"#dma_channel\">dma_channel</a>;", 
"<span class=\"ts\"/>unsigned int  <a class=\"id\" href=\"#irq\">irq</a>;", 
"<span class=\"ts\"/>", 
"", 
"<span class=\"ts\"/>enum <a class=\"id\" href=\"#scsi_host_state\">scsi_host_state</a> <a class=\"id\" href=\"#shost_state\">shost_state</a>;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/* ldm bits */</span>", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#device\">device</a><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#shost_gendev\">shost_gendev</a>, <a class=\"id\" href=\"#shost_dev\">shost_dev</a>;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * List of hosts per template.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * This is only for use by scsi_module.c for legacy templates.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * For these access to it is synchronized implicitly by</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * module_init/module_exit.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#list_head\">list_head</a> <a class=\"id\" href=\"#sht_legacy_list\">sht_legacy_list</a>;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Points to the transport data (if any) which is allocated</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * separately</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>void *<a class=\"id\" href=\"#shost_data\">shost_data</a>;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Points to the physical bus device we'd use to do DMA</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Needed just in case we have virtual hosts.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#device\">device</a> *<a class=\"id\" href=\"#dma_dev\">dma_dev</a>;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * We should ensure that this is aligned, both for better performance</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * and also because some compilers (m68k) don't automatically force</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * alignment to a long boundary.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>unsigned long <a class=\"id\" href=\"#hostdata\">hostdata</a>[0]  <span class=\"comment\">/* Used for storage of host specific stuff */</span>", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#__attribute__\">__attribute__</a> ((<a class=\"id\" href=\"#aligned\">aligned</a> (sizeof(unsigned long))));", 
"};", 
"", 
"#<a class=\"id\" href=\"#define\">define</a><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#class_to_shost\">class_to_shost</a>(<a class=\"id\" href=\"#d\">d</a>)<span class=\"ts\"/>\\", 
"<span class=\"ts\"/><a class=\"id\" href=\"#container_of\">container_of</a>(<a class=\"id\" href=\"#d\">d</a>, struct <a class=\"id\" href=\"#Scsi_Host\">Scsi_Host</a>, <a class=\"id\" href=\"#shost_dev\">shost_dev</a>)", 
"", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#shost_printk\">shost_printk</a>(<a class=\"id\" href=\"#prefix\">prefix</a>, <a class=\"id\" href=\"#shost\">shost</a>, <a class=\"id\" href=\"#fmt\">fmt</a>, <a class=\"id\" href=\"#a\">a</a>...)<span class=\"ts\"/>\\", 
"<span class=\"ts\"/><a class=\"id\" href=\"#dev_printk\">dev_printk</a>(<a class=\"id\" href=\"#prefix\">prefix</a>, &amp;(<a class=\"id\" href=\"#shost\">shost</a>)-><a class=\"id\" href=\"#shost_gendev\">shost_gendev</a>, <a class=\"id\" href=\"#fmt\">fmt</a>, ##<a class=\"id\" href=\"#a\">a</a>)", 
"", 
"static <a class=\"id\" href=\"#inline\">inline</a> void *<a class=\"id\" href=\"#shost_priv\">shost_priv</a>(struct <a class=\"id\" href=\"#Scsi_Host\">Scsi_Host</a> *<a class=\"id\" href=\"#shost\">shost</a>)", 
"{", 
"<span class=\"ts\"/>return (void *)<a class=\"id\" href=\"#shost\">shost</a>-><a class=\"id\" href=\"#hostdata\">hostdata</a>;", 
"}", 
"", 
"int <a class=\"id\" href=\"#scsi_is_host_device\">scsi_is_host_device</a>(const struct <a class=\"id\" href=\"#device\">device</a> *);", 
"", 
"static <a class=\"id\" href=\"#inline\">inline</a> struct <a class=\"id\" href=\"#Scsi_Host\">Scsi_Host</a> *<a class=\"id\" href=\"#dev_to_shost\">dev_to_shost</a>(struct <a class=\"id\" href=\"#device\">device</a> *<a class=\"id\" href=\"#dev\">dev</a>)", 
"{", 
"<span class=\"ts\"/>while (!<a class=\"id\" href=\"#scsi_is_host_device\">scsi_is_host_device</a>(<a class=\"id\" href=\"#dev\">dev</a>)) {", 
"<span class=\"ts\"/><span class=\"ts\"/>if (!<a class=\"id\" href=\"#dev\">dev</a>-><a class=\"id\" href=\"#parent\">parent</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>return <a class=\"id\" href=\"#NULL\">NULL</a>;", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#dev\">dev</a> = <a class=\"id\" href=\"#dev\">dev</a>-><a class=\"id\" href=\"#parent\">parent</a>;", 
"<span class=\"ts\"/>}", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#container_of\">container_of</a>(<a class=\"id\" href=\"#dev\">dev</a>, struct <a class=\"id\" href=\"#Scsi_Host\">Scsi_Host</a>, <a class=\"id\" href=\"#shost_gendev\">shost_gendev</a>);", 
"}", 
"", 
"static <a class=\"id\" href=\"#inline\">inline</a> int <a class=\"id\" href=\"#scsi_host_in_recovery\">scsi_host_in_recovery</a>(struct <a class=\"id\" href=\"#Scsi_Host\">Scsi_Host</a> *<a class=\"id\" href=\"#shost\">shost</a>)", 
"{", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#shost\">shost</a>-><a class=\"id\" href=\"#shost_state\">shost_state</a> == <a class=\"id\" href=\"#SHOST_RECOVERY\">SHOST_RECOVERY</a> ||", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#shost\">shost</a>-><a class=\"id\" href=\"#shost_state\">shost_state</a> == <a class=\"id\" href=\"#SHOST_CANCEL_RECOVERY\">SHOST_CANCEL_RECOVERY</a> ||", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#shost\">shost</a>-><a class=\"id\" href=\"#shost_state\">shost_state</a> == <a class=\"id\" href=\"#SHOST_DEL_RECOVERY\">SHOST_DEL_RECOVERY</a> ||", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#shost\">shost</a>-><a class=\"id\" href=\"#tmf_in_progress\">tmf_in_progress</a>;", 
"}", 
"", 
"extern int <a class=\"id\" href=\"#scsi_queue_work\">scsi_queue_work</a>(struct <a class=\"id\" href=\"#Scsi_Host\">Scsi_Host</a> *, struct <a class=\"id\" href=\"#work_struct\">work_struct</a> *);", 
"extern void <a class=\"id\" href=\"#scsi_flush_work\">scsi_flush_work</a>(struct <a class=\"id\" href=\"#Scsi_Host\">Scsi_Host</a> *);", 
"", 
"extern struct <a class=\"id\" href=\"#Scsi_Host\">Scsi_Host</a> *<a class=\"id\" href=\"#scsi_host_alloc\">scsi_host_alloc</a>(struct <a class=\"id\" href=\"#scsi_host_template\">scsi_host_template</a> *, int);", 
"extern int <a class=\"id\" href=\"#__must_check\">__must_check</a> <a class=\"id\" href=\"#scsi_add_host_with_dma\">scsi_add_host_with_dma</a>(struct <a class=\"id\" href=\"#Scsi_Host\">Scsi_Host</a> *,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>       struct <a class=\"id\" href=\"#device\">device</a> *,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>       struct <a class=\"id\" href=\"#device\">device</a> *);", 
"extern void <a class=\"id\" href=\"#scsi_scan_host\">scsi_scan_host</a>(struct <a class=\"id\" href=\"#Scsi_Host\">Scsi_Host</a> *);", 
"extern void <a class=\"id\" href=\"#scsi_rescan_device\">scsi_rescan_device</a>(struct <a class=\"id\" href=\"#device\">device</a> *);", 
"extern void <a class=\"id\" href=\"#scsi_remove_host\">scsi_remove_host</a>(struct <a class=\"id\" href=\"#Scsi_Host\">Scsi_Host</a> *);", 
"extern struct <a class=\"id\" href=\"#Scsi_Host\">Scsi_Host</a> *<a class=\"id\" href=\"#scsi_host_get\">scsi_host_get</a>(struct <a class=\"id\" href=\"#Scsi_Host\">Scsi_Host</a> *);", 
"extern void <a class=\"id\" href=\"#scsi_host_put\">scsi_host_put</a>(struct <a class=\"id\" href=\"#Scsi_Host\">Scsi_Host</a> *<a class=\"id\" href=\"#t\">t</a>);", 
"extern struct <a class=\"id\" href=\"#Scsi_Host\">Scsi_Host</a> *<a class=\"id\" href=\"#scsi_host_lookup\">scsi_host_lookup</a>(unsigned short);", 
"extern const char *<a class=\"id\" href=\"#scsi_host_state_name\">scsi_host_state_name</a>(enum <a class=\"id\" href=\"#scsi_host_state\">scsi_host_state</a>);", 
"", 
"extern <a class=\"id\" href=\"#u64\">u64</a> <a class=\"id\" href=\"#scsi_calculate_bounce_limit\">scsi_calculate_bounce_limit</a>(struct <a class=\"id\" href=\"#Scsi_Host\">Scsi_Host</a> *);", 
"", 
"static <a class=\"id\" href=\"#inline\">inline</a> int <a class=\"id\" href=\"#__must_check\">__must_check</a> <a class=\"id\" href=\"#scsi_add_host\">scsi_add_host</a>(struct <a class=\"id\" href=\"#Scsi_Host\">Scsi_Host</a> *<a class=\"id\" href=\"#host\">host</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>     struct <a class=\"id\" href=\"#device\">device</a> *<a class=\"id\" href=\"#dev\">dev</a>)", 
"{", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#scsi_add_host_with_dma\">scsi_add_host_with_dma</a>(<a class=\"id\" href=\"#host\">host</a>, <a class=\"id\" href=\"#dev\">dev</a>, <a class=\"id\" href=\"#dev\">dev</a>);", 
"}", 
"", 
"static <a class=\"id\" href=\"#inline\">inline</a> struct <a class=\"id\" href=\"#device\">device</a> *<a class=\"id\" href=\"#scsi_get_device\">scsi_get_device</a>(struct <a class=\"id\" href=\"#Scsi_Host\">Scsi_Host</a> *<a class=\"id\" href=\"#shost\">shost</a>)", 
"{", 
"        return <a class=\"id\" href=\"#shost\">shost</a>-><a class=\"id\" href=\"#shost_gendev\">shost_gendev</a>.<a class=\"id\" href=\"#parent\">parent</a>;", 
"}", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * scsi_host_scan_allowed - Is scanning of this host allowed</span>", 
"<span class=\"comment\"> * @shost:<span class=\"ts\"/>Pointer to Scsi_Host.</span>", 
"<span class=\"comment\"> **/</span>", 
"static <a class=\"id\" href=\"#inline\">inline</a> int <a class=\"id\" href=\"#scsi_host_scan_allowed\">scsi_host_scan_allowed</a>(struct <a class=\"id\" href=\"#Scsi_Host\">Scsi_Host</a> *<a class=\"id\" href=\"#shost\">shost</a>)", 
"{", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#shost\">shost</a>-><a class=\"id\" href=\"#shost_state\">shost_state</a> == <a class=\"id\" href=\"#SHOST_RUNNING\">SHOST_RUNNING</a>;", 
"}", 
"", 
"extern void <a class=\"id\" href=\"#scsi_unblock_requests\">scsi_unblock_requests</a>(struct <a class=\"id\" href=\"#Scsi_Host\">Scsi_Host</a> *);", 
"extern void <a class=\"id\" href=\"#scsi_block_requests\">scsi_block_requests</a>(struct <a class=\"id\" href=\"#Scsi_Host\">Scsi_Host</a> *);", 
"", 
"struct <a class=\"id\" href=\"#class_container\">class_container</a>;", 
"", 
"extern struct <a class=\"id\" href=\"#request_queue\">request_queue</a> *<a class=\"id\" href=\"#__scsi_alloc_queue\">__scsi_alloc_queue</a>(struct <a class=\"id\" href=\"#Scsi_Host\">Scsi_Host</a> *<a class=\"id\" href=\"#shost\">shost</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>void (*) (struct <a class=\"id\" href=\"#request_queue\">request_queue</a> *));", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * These two functions are used to allocate and free a pseudo device</span>", 
"<span class=\"comment\"> * which will connect to the host adapter itself rather than any</span>", 
"<span class=\"comment\"> * physical device.  You must deallocate when you are done with the</span>", 
"<span class=\"comment\"> * thing.  This physical pseudo-device isn't real and won't be available</span>", 
"<span class=\"comment\"> * from any high-level drivers.</span>", 
"<span class=\"comment\"> */</span>", 
"extern void <a class=\"id\" href=\"#scsi_free_host_dev\">scsi_free_host_dev</a>(struct <a class=\"id\" href=\"#scsi_device\">scsi_device</a> *);", 
"extern struct <a class=\"id\" href=\"#scsi_device\">scsi_device</a> *<a class=\"id\" href=\"#scsi_get_host_dev\">scsi_get_host_dev</a>(struct <a class=\"id\" href=\"#Scsi_Host\">Scsi_Host</a> *);", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * DIF defines the exchange of protection information between</span>", 
"<span class=\"comment\"> * initiator and SBC block device.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * DIX defines the exchange of protection information between OS and</span>", 
"<span class=\"comment\"> * initiator.</span>", 
"<span class=\"comment\"> */</span>", 
"enum <a class=\"id\" href=\"#scsi_host_prot_capabilities\">scsi_host_prot_capabilities</a> {", 
"<span class=\"ts\"/><a class=\"id\" href=\"#SHOST_DIF_TYPE1_PROTECTION\">SHOST_DIF_TYPE1_PROTECTION</a> = 1 << 0, <span class=\"comment\">/* T10 DIF Type 1 */</span>", 
"<span class=\"ts\"/><a class=\"id\" href=\"#SHOST_DIF_TYPE2_PROTECTION\">SHOST_DIF_TYPE2_PROTECTION</a> = 1 << 1, <span class=\"comment\">/* T10 DIF Type 2 */</span>", 
"<span class=\"ts\"/><a class=\"id\" href=\"#SHOST_DIF_TYPE3_PROTECTION\">SHOST_DIF_TYPE3_PROTECTION</a> = 1 << 2, <span class=\"comment\">/* T10 DIF Type 3 */</span>", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#SHOST_DIX_TYPE0_PROTECTION\">SHOST_DIX_TYPE0_PROTECTION</a> = 1 << 3, <span class=\"comment\">/* DIX between OS and HBA only */</span>", 
"<span class=\"ts\"/><a class=\"id\" href=\"#SHOST_DIX_TYPE1_PROTECTION\">SHOST_DIX_TYPE1_PROTECTION</a> = 1 << 4, <span class=\"comment\">/* DIX with DIF Type 1 */</span>", 
"<span class=\"ts\"/><a class=\"id\" href=\"#SHOST_DIX_TYPE2_PROTECTION\">SHOST_DIX_TYPE2_PROTECTION</a> = 1 << 5, <span class=\"comment\">/* DIX with DIF Type 2 */</span>", 
"<span class=\"ts\"/><a class=\"id\" href=\"#SHOST_DIX_TYPE3_PROTECTION\">SHOST_DIX_TYPE3_PROTECTION</a> = 1 << 6, <span class=\"comment\">/* DIX with DIF Type 3 */</span>", 
"};", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * SCSI hosts which support the Data Integrity Extensions must</span>", 
"<span class=\"comment\"> * indicate their capabilities by setting the prot_capabilities using</span>", 
"<span class=\"comment\"> * this call.</span>", 
"<span class=\"comment\"> */</span>", 
"static <a class=\"id\" href=\"#inline\">inline</a> void <a class=\"id\" href=\"#scsi_host_set_prot\">scsi_host_set_prot</a>(struct <a class=\"id\" href=\"#Scsi_Host\">Scsi_Host</a> *<a class=\"id\" href=\"#shost\">shost</a>, unsigned int <a class=\"id\" href=\"#mask\">mask</a>)", 
"{", 
"<span class=\"ts\"/><a class=\"id\" href=\"#shost\">shost</a>-><a class=\"id\" href=\"#prot_capabilities\">prot_capabilities</a> = <a class=\"id\" href=\"#mask\">mask</a>;", 
"}", 
"", 
"static <a class=\"id\" href=\"#inline\">inline</a> unsigned int <a class=\"id\" href=\"#scsi_host_get_prot\">scsi_host_get_prot</a>(struct <a class=\"id\" href=\"#Scsi_Host\">Scsi_Host</a> *<a class=\"id\" href=\"#shost\">shost</a>)", 
"{", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#shost\">shost</a>-><a class=\"id\" href=\"#prot_capabilities\">prot_capabilities</a>;", 
"}", 
"", 
"static <a class=\"id\" href=\"#inline\">inline</a> unsigned int <a class=\"id\" href=\"#scsi_host_dif_capable\">scsi_host_dif_capable</a>(struct <a class=\"id\" href=\"#Scsi_Host\">Scsi_Host</a> *<a class=\"id\" href=\"#shost\">shost</a>, unsigned int <a class=\"id\" href=\"#target_type\">target_type</a>)", 
"{", 
"<span class=\"ts\"/>static unsigned char <a class=\"id\" href=\"#cap\">cap</a>[] = { 0,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>       <a class=\"id\" href=\"#SHOST_DIF_TYPE1_PROTECTION\">SHOST_DIF_TYPE1_PROTECTION</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>       <a class=\"id\" href=\"#SHOST_DIF_TYPE2_PROTECTION\">SHOST_DIF_TYPE2_PROTECTION</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>       <a class=\"id\" href=\"#SHOST_DIF_TYPE3_PROTECTION\">SHOST_DIF_TYPE3_PROTECTION</a> };", 
"", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#shost\">shost</a>-><a class=\"id\" href=\"#prot_capabilities\">prot_capabilities</a> &amp; <a class=\"id\" href=\"#cap\">cap</a>[<a class=\"id\" href=\"#target_type\">target_type</a>] ? <a class=\"id\" href=\"#target_type\">target_type</a> : 0;", 
"}", 
"", 
"static <a class=\"id\" href=\"#inline\">inline</a> unsigned int <a class=\"id\" href=\"#scsi_host_dix_capable\">scsi_host_dix_capable</a>(struct <a class=\"id\" href=\"#Scsi_Host\">Scsi_Host</a> *<a class=\"id\" href=\"#shost\">shost</a>, unsigned int <a class=\"id\" href=\"#target_type\">target_type</a>)", 
"{", 
"#if <a class=\"id\" href=\"#defined\">defined</a>(<a class=\"id\" href=\"#CONFIG_BLK_DEV_INTEGRITY\">CONFIG_BLK_DEV_INTEGRITY</a>)", 
"<span class=\"ts\"/>static unsigned char <a class=\"id\" href=\"#cap\">cap</a>[] = { <a class=\"id\" href=\"#SHOST_DIX_TYPE0_PROTECTION\">SHOST_DIX_TYPE0_PROTECTION</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>       <a class=\"id\" href=\"#SHOST_DIX_TYPE1_PROTECTION\">SHOST_DIX_TYPE1_PROTECTION</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>       <a class=\"id\" href=\"#SHOST_DIX_TYPE2_PROTECTION\">SHOST_DIX_TYPE2_PROTECTION</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>       <a class=\"id\" href=\"#SHOST_DIX_TYPE3_PROTECTION\">SHOST_DIX_TYPE3_PROTECTION</a> };", 
"", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#shost\">shost</a>-><a class=\"id\" href=\"#prot_capabilities\">prot_capabilities</a> &amp; <a class=\"id\" href=\"#cap\">cap</a>[<a class=\"id\" href=\"#target_type\">target_type</a>];", 
"#<a class=\"id\" href=\"#endif\">endif</a>", 
"<span class=\"ts\"/>return 0;", 
"}", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * All DIX-capable initiators must support the T10-mandated CRC</span>", 
"<span class=\"comment\"> * checksum.  Controllers can optionally implement the IP checksum</span>", 
"<span class=\"comment\"> * scheme which has much lower impact on system performance.  Note</span>", 
"<span class=\"comment\"> * that the main rationale for the checksum is to match integrity</span>", 
"<span class=\"comment\"> * metadata with data.  Detecting bit errors are a job for ECC memory</span>", 
"<span class=\"comment\"> * and buses.</span>", 
"<span class=\"comment\"> */</span>", 
"", 
"enum <a class=\"id\" href=\"#scsi_host_guard_type\">scsi_host_guard_type</a> {", 
"<span class=\"ts\"/><a class=\"id\" href=\"#SHOST_DIX_GUARD_CRC\">SHOST_DIX_GUARD_CRC</a> = 1 << 0,", 
"<span class=\"ts\"/><a class=\"id\" href=\"#SHOST_DIX_GUARD_IP\">SHOST_DIX_GUARD_IP</a>  = 1 << 1,", 
"};", 
"", 
"static <a class=\"id\" href=\"#inline\">inline</a> void <a class=\"id\" href=\"#scsi_host_set_guard\">scsi_host_set_guard</a>(struct <a class=\"id\" href=\"#Scsi_Host\">Scsi_Host</a> *<a class=\"id\" href=\"#shost\">shost</a>, unsigned char <a class=\"id\" href=\"#type\">type</a>)", 
"{", 
"<span class=\"ts\"/><a class=\"id\" href=\"#shost\">shost</a>-><a class=\"id\" href=\"#prot_guard_type\">prot_guard_type</a> = <a class=\"id\" href=\"#type\">type</a>;", 
"}", 
"", 
"static <a class=\"id\" href=\"#inline\">inline</a> unsigned char <a class=\"id\" href=\"#scsi_host_get_guard\">scsi_host_get_guard</a>(struct <a class=\"id\" href=\"#Scsi_Host\">Scsi_Host</a> *<a class=\"id\" href=\"#shost\">shost</a>)", 
"{", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#shost\">shost</a>-><a class=\"id\" href=\"#prot_guard_type\">prot_guard_type</a>;", 
"}", 
"", 
"<span class=\"comment\">/* legacy interfaces */</span>", 
"extern struct <a class=\"id\" href=\"#Scsi_Host\">Scsi_Host</a> *<a class=\"id\" href=\"#scsi_register\">scsi_register</a>(struct <a class=\"id\" href=\"#scsi_host_template\">scsi_host_template</a> *, int);", 
"extern void <a class=\"id\" href=\"#scsi_unregister\">scsi_unregister</a>(struct <a class=\"id\" href=\"#Scsi_Host\">Scsi_Host</a> *);", 
"extern int <a class=\"id\" href=\"#scsi_host_set_state\">scsi_host_set_state</a>(struct <a class=\"id\" href=\"#Scsi_Host\">Scsi_Host</a> *, enum <a class=\"id\" href=\"#scsi_host_state\">scsi_host_state</a>);", 
"", 
"#<a class=\"id\" href=\"#endif\">endif</a> <span class=\"comment\">/* _SCSI_SCSI_HOST_H */</span>", 
];
xr_frag_insert('l/ad/801518865d477c2c68325fdc91e4cce0bf9356.xr', __xr_tmp);
