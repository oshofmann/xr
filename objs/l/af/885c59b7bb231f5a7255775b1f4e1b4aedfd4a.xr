var __xr_tmp = [
"#<a class=\"id\" href=\"#ifndef\">ifndef</a> <a class=\"id\" href=\"#_ASM_X86_BITOPS_H\">_ASM_X86_BITOPS_H</a>", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#_ASM_X86_BITOPS_H\">_ASM_X86_BITOPS_H</a>", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * Copyright 1992, Linus Torvalds.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Note: inlines with more than a single statement should be marked</span>", 
"<span class=\"comment\"> * __always_inline to avoid problems with older gcc's inlining heuristics.</span>", 
"<span class=\"comment\"> */</span>", 
"", 
"#<a class=\"id\" href=\"#ifndef\">ifndef</a> <a class=\"id\" href=\"#_LINUX_BITOPS_H\">_LINUX_BITOPS_H</a>", 
"#<a class=\"id\" href=\"#error\">error</a> <a class=\"id\" href=\"#only\">only</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#bitops\">bitops</a>.<a class=\"id\" href=\"#h\">h</a>&gt; <a class=\"id\" href=\"#can\">can</a> <a class=\"id\" href=\"#be\">be</a> <a class=\"id\" href=\"#included\">included</a> <a class=\"id\" href=\"#directly\">directly</a>", 
"#<a class=\"id\" href=\"#endif\">endif</a>", 
"", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#compiler\">compiler</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#asm\">asm</a>/<a class=\"id\" href=\"#alternative\">alternative</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * These have to be done with inline assembly: that way the bit-setting</span>", 
"<span class=\"comment\"> * is guaranteed to be atomic. All bit operations return 0 if the bit</span>", 
"<span class=\"comment\"> * was cleared before the operation and != 0 if it was not.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * bit 0 is the LSB of addr; bit 32 is the LSB of (addr+1).</span>", 
"<span class=\"comment\"> */</span>", 
"", 
"#if <a class=\"id\" href=\"#__GNUC__\">__GNUC__</a> &lt; 4 || (<a class=\"id\" href=\"#__GNUC__\">__GNUC__</a> == 4 && <a class=\"id\" href=\"#__GNUC_MINOR__\">__GNUC_MINOR__</a> &lt; 1)", 
"<span class=\"comment\">/* Technically wrong, but this avoids compilation errors on some gcc</span>", 
"<span class=\"comment\">   versions. */</span>", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#BITOP_ADDR\">BITOP_ADDR</a>(<a class=\"id\" href=\"#x\">x</a>) \"=m\" (*(volatile long *) (<a class=\"id\" href=\"#x\">x</a>))", 
"#else", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#BITOP_ADDR\">BITOP_ADDR</a>(<a class=\"id\" href=\"#x\">x</a>) \"+m\" (*(volatile long *) (<a class=\"id\" href=\"#x\">x</a>))", 
"#<a class=\"id\" href=\"#endif\">endif</a>", 
"", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#ADDR\">ADDR</a><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#BITOP_ADDR\">BITOP_ADDR</a>(<a class=\"id\" href=\"#addr\">addr</a>)", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * We do the locked ops that don't return the old value as</span>", 
"<span class=\"comment\"> * a mask operation on a byte.</span>", 
"<span class=\"comment\"> */</span>", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#IS_IMMEDIATE\">IS_IMMEDIATE</a>(<a class=\"id\" href=\"#nr\">nr</a>)<span class=\"ts\"/><span class=\"ts\"/>(<a class=\"id\" href=\"#__builtin_constant_p\">__builtin_constant_p</a>(<a class=\"id\" href=\"#nr\">nr</a>))", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#CONST_MASK_ADDR\">CONST_MASK_ADDR</a>(<a class=\"id\" href=\"#nr\">nr</a>, <a class=\"id\" href=\"#addr\">addr</a>)<span class=\"ts\"/><a class=\"id\" href=\"#BITOP_ADDR\">BITOP_ADDR</a>((void *)(<a class=\"id\" href=\"#addr\">addr</a>) + ((<a class=\"id\" href=\"#nr\">nr</a>)>>3))", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#CONST_MASK\">CONST_MASK</a>(<a class=\"id\" href=\"#nr\">nr</a>)<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>(1 << ((<a class=\"id\" href=\"#nr\">nr</a>) &amp; 7))", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * set_bit - Atomically set a bit in memory</span>", 
"<span class=\"comment\"> * @nr: the bit to set</span>", 
"<span class=\"comment\"> * @addr: the address to start counting from</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * This function is atomic and may not be reordered.  See __set_bit()</span>", 
"<span class=\"comment\"> * if you do not require the atomic guarantees.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Note: there are no guarantees that this function will not be reordered</span>", 
"<span class=\"comment\"> * on non x86 architectures, so if you are writing portable code,</span>", 
"<span class=\"comment\"> * make sure not to rely on its reordering guarantees.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Note that @nr may be almost arbitrarily large; this function is not</span>", 
"<span class=\"comment\"> * restricted to acting on a single-word quantity.</span>", 
"<span class=\"comment\"> */</span>", 
"static <a class=\"id\" href=\"#__always_inline\">__always_inline</a> void", 
"<a class=\"id\" href=\"#set_bit\">set_bit</a>(unsigned int <a class=\"id\" href=\"#nr\">nr</a>, volatile unsigned long *<a class=\"id\" href=\"#addr\">addr</a>)", 
"{", 
"<span class=\"ts\"/>if (<a class=\"id\" href=\"#IS_IMMEDIATE\">IS_IMMEDIATE</a>(<a class=\"id\" href=\"#nr\">nr</a>)) {", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#asm\">asm</a> volatile(<a class=\"id\" href=\"#LOCK_PREFIX\">LOCK_PREFIX</a> \"orb %1,%0\"", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>: <a class=\"id\" href=\"#CONST_MASK_ADDR\">CONST_MASK_ADDR</a>(<a class=\"id\" href=\"#nr\">nr</a>, <a class=\"id\" href=\"#addr\">addr</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>: \"iq\" ((<a class=\"id\" href=\"#u8\">u8</a>)<a class=\"id\" href=\"#CONST_MASK\">CONST_MASK</a>(<a class=\"id\" href=\"#nr\">nr</a>))", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>: \"memory\");", 
"<span class=\"ts\"/>} else {", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#asm\">asm</a> volatile(<a class=\"id\" href=\"#LOCK_PREFIX\">LOCK_PREFIX</a> \"bts %1,%0\"", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>: <a class=\"id\" href=\"#BITOP_ADDR\">BITOP_ADDR</a>(<a class=\"id\" href=\"#addr\">addr</a>) : \"Ir\" (<a class=\"id\" href=\"#nr\">nr</a>) : \"memory\");", 
"<span class=\"ts\"/>}", 
"}", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * __set_bit - Set a bit in memory</span>", 
"<span class=\"comment\"> * @nr: the bit to set</span>", 
"<span class=\"comment\"> * @addr: the address to start counting from</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Unlike set_bit(), this function is non-atomic and may be reordered.</span>", 
"<span class=\"comment\"> * If it's called on the same region of memory simultaneously, the effect</span>", 
"<span class=\"comment\"> * may be that only one operation succeeds.</span>", 
"<span class=\"comment\"> */</span>", 
"static <a class=\"id\" href=\"#inline\">inline</a> void <a class=\"id\" href=\"#__set_bit\">__set_bit</a>(int <a class=\"id\" href=\"#nr\">nr</a>, volatile unsigned long *<a class=\"id\" href=\"#addr\">addr</a>)", 
"{", 
"<span class=\"ts\"/><a class=\"id\" href=\"#asm\">asm</a> volatile(\"bts %1,%0\" : <a class=\"id\" href=\"#ADDR\">ADDR</a> : \"Ir\" (<a class=\"id\" href=\"#nr\">nr</a>) : \"memory\");", 
"}", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * clear_bit - Clears a bit in memory</span>", 
"<span class=\"comment\"> * @nr: Bit to clear</span>", 
"<span class=\"comment\"> * @addr: Address to start counting from</span>", 
];
xr_frag_insert('l/af/885c59b7bb231f5a7255775b1f4e1b4aedfd4a.xr', __xr_tmp);
