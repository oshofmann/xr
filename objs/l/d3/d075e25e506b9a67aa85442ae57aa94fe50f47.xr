var __xr_tmp = [
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * Utility code which helps transforming between two different time</span>", 
"<span class=\"comment\"> * bases, called \"source\" and \"target\" time in this code.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Source time has to be provided via the timecounter API while target</span>", 
"<span class=\"comment\"> * time is accessed via a function callback whose prototype</span>", 
"<span class=\"comment\"> * intentionally matches ktime_get() and ktime_get_real(). These</span>", 
"<span class=\"comment\"> * interfaces where chosen like this so that the code serves its</span>", 
"<span class=\"comment\"> * initial purpose without additional glue code.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * This purpose is synchronizing a hardware clock in a NIC with system</span>", 
"<span class=\"comment\"> * time, in order to implement the Precision Time Protocol (PTP,</span>", 
"<span class=\"comment\"> * IEEE1588) with more accurate hardware assisted time stamping.  In</span>", 
"<span class=\"comment\"> * that context only synchronization against system time (=</span>", 
"<span class=\"comment\"> * ktime_get_real()) is currently needed. But this utility code might</span>", 
"<span class=\"comment\"> * become useful in other situations, which is why it was written as</span>", 
"<span class=\"comment\"> * general purpose utility code.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * The source timecounter is assumed to return monotonically</span>", 
"<span class=\"comment\"> * increasing time (but this code does its best to compensate if that</span>", 
"<span class=\"comment\"> * is not the case) whereas target time may jump.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * The target time corresponding to a source time is determined by</span>", 
"<span class=\"comment\"> * reading target time, reading source time, reading target time</span>", 
"<span class=\"comment\"> * again, then assuming that average target time corresponds to source</span>", 
"<span class=\"comment\"> * time. In other words, the assumption is that reading the source</span>", 
"<span class=\"comment\"> * time is slow and involves equal time for sending the request and</span>", 
"<span class=\"comment\"> * receiving the reply, whereas reading target time is assumed to be</span>", 
"<span class=\"comment\"> * fast.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Copyright (C) 2009 Intel Corporation.</span>", 
"<span class=\"comment\"> * Author: Patrick Ohly &lt;patrick.ohly@intel.com&gt;</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * This program is free software; you can redistribute it and/or modify it</span>", 
"<span class=\"comment\"> * under the terms and conditions of the GNU General Public License,</span>", 
"<span class=\"comment\"> * version 2, as published by the Free Software Foundation.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * This program is distributed in the hope it will be useful, but WITHOUT</span>", 
"<span class=\"comment\"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>", 
"<span class=\"comment\"> * FITNESS FOR A PARTICULAR PURPOSE. * See the GNU General Public License for</span>", 
"<span class=\"comment\"> * more details.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * You should have received a copy of the GNU General Public License along with</span>", 
"<span class=\"comment\"> * this program; if not, write to the Free Software Foundation, Inc.,</span>", 
"<span class=\"comment\"> * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.</span>", 
"<span class=\"comment\"> */</span>", 
"#<a class=\"id\" href=\"#ifndef\">ifndef</a> <a class=\"id\" href=\"#_LINUX_TIMECOMPARE_H\">_LINUX_TIMECOMPARE_H</a>", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#_LINUX_TIMECOMPARE_H\">_LINUX_TIMECOMPARE_H</a>", 
"", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#clocksource\">clocksource</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#ktime\">ktime</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * struct timecompare - stores state and configuration for the two clocks</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Initialize to zero, then set source/target/num_samples.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Transformation between source time and target time is done with:</span>", 
"<span class=\"comment\"> * target_time = source_time + offset +</span>", 
"<span class=\"comment\"> *               (source_time - last_update) * skew /</span>", 
"<span class=\"comment\"> *               TIMECOMPARE_SKEW_RESOLUTION</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * @source:          used to get source time stamps via timecounter_read()</span>", 
"<span class=\"comment\"> * @target:          function returning target time (for example, ktime_get</span>", 
"<span class=\"comment\"> *                   for monotonic time, or ktime_get_real for wall clock)</span>", 
"<span class=\"comment\"> * @num_samples:     number of times that source time and target time are to</span>", 
"<span class=\"comment\"> *                   be compared when determining their offset</span>", 
"<span class=\"comment\"> * @offset:          (target time - source time) at the time of the last update</span>", 
"<span class=\"comment\"> * @skew:            average (target time - source time) / delta source time *</span>", 
"<span class=\"comment\"> *                   TIMECOMPARE_SKEW_RESOLUTION</span>", 
"<span class=\"comment\"> * @last_update:     last source time stamp when time offset was measured</span>", 
"<span class=\"comment\"> */</span>", 
"struct <a class=\"id\" href=\"#timecompare\">timecompare</a> {", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#timecounter\">timecounter</a> *<a class=\"id\" href=\"#source\">source</a>;", 
"<span class=\"ts\"/><a class=\"id\" href=\"#ktime_t\">ktime_t</a> (*<a class=\"id\" href=\"#target\">target</a>)(void);", 
"<span class=\"ts\"/>int <a class=\"id\" href=\"#num_samples\">num_samples</a>;", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#s64\">s64</a> <a class=\"id\" href=\"#offset\">offset</a>;", 
"<span class=\"ts\"/><a class=\"id\" href=\"#s64\">s64</a> <a class=\"id\" href=\"#skew\">skew</a>;", 
"<span class=\"ts\"/><a class=\"id\" href=\"#u64\">u64</a> <a class=\"id\" href=\"#last_update\">last_update</a>;", 
"};", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * timecompare_transform - transform source time stamp into target time base</span>", 
"<span class=\"comment\"> * @sync:            context for time sync</span>", 
"<span class=\"comment\"> * @source_tstamp:   the result of timecounter_read() or</span>", 
"<span class=\"comment\"> *                   timecounter_cyc2time()</span>", 
"<span class=\"comment\"> */</span>", 
"extern <a class=\"id\" href=\"#ktime_t\">ktime_t</a> <a class=\"id\" href=\"#timecompare_transform\">timecompare_transform</a>(struct <a class=\"id\" href=\"#timecompare\">timecompare</a> *<a class=\"id\" href=\"#sync\">sync</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>     <a class=\"id\" href=\"#u64\">u64</a> <a class=\"id\" href=\"#source_tstamp\">source_tstamp</a>);", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * timecompare_offset - measure current (target time - source time) offset</span>", 
"<span class=\"comment\"> * @sync:            context for time sync</span>", 
"<span class=\"comment\"> * @offset:          average offset during sample period returned here</span>", 
"<span class=\"comment\"> * @source_tstamp:   average source time during sample period returned here</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Returns number of samples used. Might be zero (= no result) in the</span>", 
"<span class=\"comment\"> * unlikely case that target time was monotonically decreasing for all</span>", 
"<span class=\"comment\"> * samples (= broken).</span>", 
"<span class=\"comment\"> */</span>", 
"extern int <a class=\"id\" href=\"#timecompare_offset\">timecompare_offset</a>(struct <a class=\"id\" href=\"#timecompare\">timecompare</a> *<a class=\"id\" href=\"#sync\">sync</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>      <a class=\"id\" href=\"#s64\">s64</a> *<a class=\"id\" href=\"#offset\">offset</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>      <a class=\"id\" href=\"#u64\">u64</a> *<a class=\"id\" href=\"#source_tstamp\">source_tstamp</a>);", 
"", 
"extern void <a class=\"id\" href=\"#__timecompare_update\">__timecompare_update</a>(struct <a class=\"id\" href=\"#timecompare\">timecompare</a> *<a class=\"id\" href=\"#sync\">sync</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/> <a class=\"id\" href=\"#u64\">u64</a> <a class=\"id\" href=\"#source_tstamp\">source_tstamp</a>);", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * timecompare_update - update offset and skew by measuring current offset</span>", 
"<span class=\"comment\"> * @sync:            context for time sync</span>", 
"<span class=\"comment\"> * @source_tstamp:   the result of timecounter_read() or</span>", 
"<span class=\"comment\"> *                   timecounter_cyc2time(), pass zero to force update</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Updates are only done at most once per second.</span>", 
"<span class=\"comment\"> */</span>", 
"static <a class=\"id\" href=\"#inline\">inline</a> void <a class=\"id\" href=\"#timecompare_update\">timecompare_update</a>(struct <a class=\"id\" href=\"#timecompare\">timecompare</a> *<a class=\"id\" href=\"#sync\">sync</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>      <a class=\"id\" href=\"#u64\">u64</a> <a class=\"id\" href=\"#source_tstamp\">source_tstamp</a>)", 
"{", 
"<span class=\"ts\"/>if (!<a class=\"id\" href=\"#source_tstamp\">source_tstamp</a> ||", 
"<span class=\"ts\"/>    (<a class=\"id\" href=\"#s64\">s64</a>)(<a class=\"id\" href=\"#source_tstamp\">source_tstamp</a> - <a class=\"id\" href=\"#sync\">sync</a>-><a class=\"id\" href=\"#last_update\">last_update</a>) >= <a class=\"id\" href=\"#NSEC_PER_SEC\">NSEC_PER_SEC</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#__timecompare_update\">__timecompare_update</a>(<a class=\"id\" href=\"#sync\">sync</a>, <a class=\"id\" href=\"#source_tstamp\">source_tstamp</a>);", 
"}", 
"", 
"#<a class=\"id\" href=\"#endif\">endif</a> <span class=\"comment\">/* _LINUX_TIMECOMPARE_H */</span>", 
];
xr_frag_insert('l/d3/d075e25e506b9a67aa85442ae57aa94fe50f47.xr', __xr_tmp);
