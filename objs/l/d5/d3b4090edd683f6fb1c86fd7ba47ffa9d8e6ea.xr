var __xr_tmp = [
"#<a class=\"id\" href=\"#ifndef\">ifndef</a> <a class=\"id\" href=\"#_LINUX_RCULIST_H\">_LINUX_RCULIST_H</a>", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#_LINUX_RCULIST_H\">_LINUX_RCULIST_H</a>", 
"", 
"#<a class=\"id\" href=\"#ifdef\">ifdef</a> <a class=\"id\" href=\"#__KERNEL__\">__KERNEL__</a>", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * RCU-protected list version</span>", 
"<span class=\"comment\"> */</span>", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#list\">list</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#rcupdate\">rcupdate</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * Insert a new entry between two known consecutive entries.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * This is only for internal list manipulation where we know</span>", 
"<span class=\"comment\"> * the prev/next entries already!</span>", 
"<span class=\"comment\"> */</span>", 
"static <a class=\"id\" href=\"#inline\">inline</a> void <a class=\"id\" href=\"#__list_add_rcu\">__list_add_rcu</a>(struct <a class=\"id\" href=\"#list_head\">list_head</a> *<a class=\"id\" href=\"#new\">new</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/>struct <a class=\"id\" href=\"#list_head\">list_head</a> *<a class=\"id\" href=\"#prev\">prev</a>, struct <a class=\"id\" href=\"#list_head\">list_head</a> *<a class=\"id\" href=\"#next\">next</a>)", 
"{", 
"<span class=\"ts\"/><a class=\"id\" href=\"#new\">new</a>-><a class=\"id\" href=\"#next\">next</a> = <a class=\"id\" href=\"#next\">next</a>;", 
"<span class=\"ts\"/><a class=\"id\" href=\"#new\">new</a>-><a class=\"id\" href=\"#prev\">prev</a> = <a class=\"id\" href=\"#prev\">prev</a>;", 
"<span class=\"ts\"/><a class=\"id\" href=\"#rcu_assign_pointer\">rcu_assign_pointer</a>(<a class=\"id\" href=\"#prev\">prev</a>-><a class=\"id\" href=\"#next\">next</a>, <a class=\"id\" href=\"#new\">new</a>);", 
"<span class=\"ts\"/><a class=\"id\" href=\"#next\">next</a>-><a class=\"id\" href=\"#prev\">prev</a> = <a class=\"id\" href=\"#new\">new</a>;", 
"}", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * list_add_rcu - add a new entry to rcu-protected list</span>", 
"<span class=\"comment\"> * @new: new entry to be added</span>", 
"<span class=\"comment\"> * @head: list head to add it after</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Insert a new entry after the specified head.</span>", 
"<span class=\"comment\"> * This is good for implementing stacks.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * The caller must take whatever precautions are necessary</span>", 
"<span class=\"comment\"> * (such as holding appropriate locks) to avoid racing</span>", 
"<span class=\"comment\"> * with another list-mutation primitive, such as list_add_rcu()</span>", 
"<span class=\"comment\"> * or list_del_rcu(), running on this same list.</span>", 
"<span class=\"comment\"> * However, it is perfectly legal to run concurrently with</span>", 
"<span class=\"comment\"> * the _rcu list-traversal primitives, such as</span>", 
"<span class=\"comment\"> * list_for_each_entry_rcu().</span>", 
"<span class=\"comment\"> */</span>", 
"static <a class=\"id\" href=\"#inline\">inline</a> void <a class=\"id\" href=\"#list_add_rcu\">list_add_rcu</a>(struct <a class=\"id\" href=\"#list_head\">list_head</a> *<a class=\"id\" href=\"#new\">new</a>, struct <a class=\"id\" href=\"#list_head\">list_head</a> *<a class=\"id\" href=\"#head\">head</a>)", 
"{", 
"<span class=\"ts\"/><a class=\"id\" href=\"#__list_add_rcu\">__list_add_rcu</a>(<a class=\"id\" href=\"#new\">new</a>, <a class=\"id\" href=\"#head\">head</a>, <a class=\"id\" href=\"#head\">head</a>-><a class=\"id\" href=\"#next\">next</a>);", 
"}", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * list_add_tail_rcu - add a new entry to rcu-protected list</span>", 
"<span class=\"comment\"> * @new: new entry to be added</span>", 
"<span class=\"comment\"> * @head: list head to add it before</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Insert a new entry before the specified head.</span>", 
"<span class=\"comment\"> * This is useful for implementing queues.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * The caller must take whatever precautions are necessary</span>", 
"<span class=\"comment\"> * (such as holding appropriate locks) to avoid racing</span>", 
"<span class=\"comment\"> * with another list-mutation primitive, such as list_add_tail_rcu()</span>", 
"<span class=\"comment\"> * or list_del_rcu(), running on this same list.</span>", 
"<span class=\"comment\"> * However, it is perfectly legal to run concurrently with</span>", 
"<span class=\"comment\"> * the _rcu list-traversal primitives, such as</span>", 
"<span class=\"comment\"> * list_for_each_entry_rcu().</span>", 
"<span class=\"comment\"> */</span>", 
"static <a class=\"id\" href=\"#inline\">inline</a> void <a class=\"id\" href=\"#list_add_tail_rcu\">list_add_tail_rcu</a>(struct <a class=\"id\" href=\"#list_head\">list_head</a> *<a class=\"id\" href=\"#new\">new</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>struct <a class=\"id\" href=\"#list_head\">list_head</a> *<a class=\"id\" href=\"#head\">head</a>)", 
"{", 
"<span class=\"ts\"/><a class=\"id\" href=\"#__list_add_rcu\">__list_add_rcu</a>(<a class=\"id\" href=\"#new\">new</a>, <a class=\"id\" href=\"#head\">head</a>-><a class=\"id\" href=\"#prev\">prev</a>, <a class=\"id\" href=\"#head\">head</a>);", 
"}", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * list_del_rcu - deletes entry from list without re-initialization</span>", 
"<span class=\"comment\"> * @entry: the element to delete from the list.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Note: list_empty() on entry does not return true after this,</span>", 
"<span class=\"comment\"> * the entry is in an undefined state. It is useful for RCU based</span>", 
"<span class=\"comment\"> * lockfree traversal.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * In particular, it means that we can not poison the forward</span>", 
"<span class=\"comment\"> * pointers that may still be used for walking the list.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * The caller must take whatever precautions are necessary</span>", 
"<span class=\"comment\"> * (such as holding appropriate locks) to avoid racing</span>", 
"<span class=\"comment\"> * with another list-mutation primitive, such as list_del_rcu()</span>", 
"<span class=\"comment\"> * or list_add_rcu(), running on this same list.</span>", 
"<span class=\"comment\"> * However, it is perfectly legal to run concurrently with</span>", 
"<span class=\"comment\"> * the _rcu list-traversal primitives, such as</span>", 
"<span class=\"comment\"> * list_for_each_entry_rcu().</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Note that the caller is not permitted to immediately free</span>", 
"<span class=\"comment\"> * the newly deleted entry.  Instead, either synchronize_rcu()</span>", 
"<span class=\"comment\"> * or call_rcu() must be used to defer freeing until an RCU</span>", 
"<span class=\"comment\"> * grace period has elapsed.</span>", 
"<span class=\"comment\"> */</span>", 
"static <a class=\"id\" href=\"#inline\">inline</a> void <a class=\"id\" href=\"#list_del_rcu\">list_del_rcu</a>(struct <a class=\"id\" href=\"#list_head\">list_head</a> *<a class=\"id\" href=\"#entry\">entry</a>)", 
"{", 
"<span class=\"ts\"/><a class=\"id\" href=\"#__list_del\">__list_del</a>(<a class=\"id\" href=\"#entry\">entry</a>-><a class=\"id\" href=\"#prev\">prev</a>, <a class=\"id\" href=\"#entry\">entry</a>-><a class=\"id\" href=\"#next\">next</a>);", 
"<span class=\"ts\"/><a class=\"id\" href=\"#entry\">entry</a>-><a class=\"id\" href=\"#prev\">prev</a> = <a class=\"id\" href=\"#LIST_POISON2\">LIST_POISON2</a>;", 
"}", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * hlist_del_init_rcu - deletes entry from hash list with re-initialization</span>", 
"<span class=\"comment\"> * @n: the element to delete from the hash list.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Note: list_unhashed() on the node return true after this. It is</span>", 
"<span class=\"comment\"> * useful for RCU based read lockfree traversal if the writer side</span>", 
"<span class=\"comment\"> * must know if the list entry is still hashed or already unhashed.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * In particular, it means that we can not poison the forward pointers</span>", 
"<span class=\"comment\"> * that may still be used for walking the hash list and we can only</span>", 
"<span class=\"comment\"> * zero the pprev pointer so list_unhashed() will return true after</span>", 
"<span class=\"comment\"> * this.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * The caller must take whatever precautions are necessary (such as</span>", 
"<span class=\"comment\"> * holding appropriate locks) to avoid racing with another</span>", 
"<span class=\"comment\"> * list-mutation primitive, such as hlist_add_head_rcu() or</span>", 
"<span class=\"comment\"> * hlist_del_rcu(), running on this same list.  However, it is</span>", 
"<span class=\"comment\"> * perfectly legal to run concurrently with the _rcu list-traversal</span>", 
"<span class=\"comment\"> * primitives, such as hlist_for_each_entry_rcu().</span>", 
"<span class=\"comment\"> */</span>", 
"static <a class=\"id\" href=\"#inline\">inline</a> void <a class=\"id\" href=\"#hlist_del_init_rcu\">hlist_del_init_rcu</a>(struct <a class=\"id\" href=\"#hlist_node\">hlist_node</a> *<a class=\"id\" href=\"#n\">n</a>)", 
"{", 
"<span class=\"ts\"/>if (!<a class=\"id\" href=\"#hlist_unhashed\">hlist_unhashed</a>(<a class=\"id\" href=\"#n\">n</a>)) {", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#__hlist_del\">__hlist_del</a>(<a class=\"id\" href=\"#n\">n</a>);", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#n\">n</a>-><a class=\"id\" href=\"#pprev\">pprev</a> = <a class=\"id\" href=\"#NULL\">NULL</a>;", 
"<span class=\"ts\"/>}", 
"}", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * list_replace_rcu - replace old entry by new one</span>", 
"<span class=\"comment\"> * @old : the element to be replaced</span>", 
"<span class=\"comment\"> * @new : the new element to insert</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * The @old entry will be replaced with the @new entry atomically.</span>", 
"<span class=\"comment\"> * Note: @old should not be empty.</span>", 
"<span class=\"comment\"> */</span>", 
"static <a class=\"id\" href=\"#inline\">inline</a> void <a class=\"id\" href=\"#list_replace_rcu\">list_replace_rcu</a>(struct <a class=\"id\" href=\"#list_head\">list_head</a> *<a class=\"id\" href=\"#old\">old</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>struct <a class=\"id\" href=\"#list_head\">list_head</a> *<a class=\"id\" href=\"#new\">new</a>)", 
"{", 
"<span class=\"ts\"/><a class=\"id\" href=\"#new\">new</a>-><a class=\"id\" href=\"#next\">next</a> = <a class=\"id\" href=\"#old\">old</a>-><a class=\"id\" href=\"#next\">next</a>;", 
"<span class=\"ts\"/><a class=\"id\" href=\"#new\">new</a>-><a class=\"id\" href=\"#prev\">prev</a> = <a class=\"id\" href=\"#old\">old</a>-><a class=\"id\" href=\"#prev\">prev</a>;", 
"<span class=\"ts\"/><a class=\"id\" href=\"#rcu_assign_pointer\">rcu_assign_pointer</a>(<a class=\"id\" href=\"#new\">new</a>-><a class=\"id\" href=\"#prev\">prev</a>-><a class=\"id\" href=\"#next\">next</a>, <a class=\"id\" href=\"#new\">new</a>);", 
"<span class=\"ts\"/><a class=\"id\" href=\"#new\">new</a>-><a class=\"id\" href=\"#next\">next</a>-><a class=\"id\" href=\"#prev\">prev</a> = <a class=\"id\" href=\"#new\">new</a>;", 
"<span class=\"ts\"/><a class=\"id\" href=\"#old\">old</a>-><a class=\"id\" href=\"#prev\">prev</a> = <a class=\"id\" href=\"#LIST_POISON2\">LIST_POISON2</a>;", 
"}", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * list_splice_init_rcu - splice an RCU-protected list into an existing list.</span>", 
"<span class=\"comment\"> * @list:<span class=\"ts\"/>the RCU-protected list to splice</span>", 
"<span class=\"comment\"> * @head:<span class=\"ts\"/>the place in the list to splice the first list into</span>", 
"<span class=\"comment\"> * @sync:<span class=\"ts\"/>function to sync: synchronize_rcu(), synchronize_sched(), ...</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * @head can be RCU-read traversed concurrently with this function.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Note that this function blocks.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Important note: the caller must take whatever action is necessary to</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>prevent any other updates to @head.  In principle, it is possible</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>to modify the list as soon as sync() begins execution.</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>If this sort of thing becomes necessary, an alternative version</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>based on call_rcu() could be created.  But only if -really-</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>needed -- there is no shortage of RCU API members.</span>", 
"<span class=\"comment\"> */</span>", 
"static <a class=\"id\" href=\"#inline\">inline</a> void <a class=\"id\" href=\"#list_splice_init_rcu\">list_splice_init_rcu</a>(struct <a class=\"id\" href=\"#list_head\">list_head</a> *<a class=\"id\" href=\"#list\">list</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>struct <a class=\"id\" href=\"#list_head\">list_head</a> *<a class=\"id\" href=\"#head\">head</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>void (*<a class=\"id\" href=\"#sync\">sync</a>)(void))", 
"{", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#list_head\">list_head</a> *<a class=\"id\" href=\"#first\">first</a> = <a class=\"id\" href=\"#list\">list</a>-><a class=\"id\" href=\"#next\">next</a>;", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#list_head\">list_head</a> *<a class=\"id\" href=\"#last\">last</a> = <a class=\"id\" href=\"#list\">list</a>-><a class=\"id\" href=\"#prev\">prev</a>;", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#list_head\">list_head</a> *<a class=\"id\" href=\"#at\">at</a> = <a class=\"id\" href=\"#head\">head</a>-><a class=\"id\" href=\"#next\">next</a>;", 
"", 
"<span class=\"ts\"/>if (<a class=\"id\" href=\"#list_empty\">list_empty</a>(<a class=\"id\" href=\"#head\">head</a>))", 
"<span class=\"ts\"/><span class=\"ts\"/>return;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/* \"first\" and \"last\" tracking list, so initialize it. */</span>", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#INIT_LIST_HEAD\">INIT_LIST_HEAD</a>(<a class=\"id\" href=\"#list\">list</a>);", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * At this point, the list body still points to the source list.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Wait for any readers to finish using the list before splicing</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * the list body into the new list.  Any new readers will see</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * an empty list.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#sync\">sync</a>();", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Readers are finished with the source list, so perform splice.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * The order is important if the new list is global and accessible</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * to concurrent RCU readers.  Note that RCU readers are not</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * permitted to traverse the prev pointers without excluding</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * this function.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#last\">last</a>-><a class=\"id\" href=\"#next\">next</a> = <a class=\"id\" href=\"#at\">at</a>;", 
"<span class=\"ts\"/><a class=\"id\" href=\"#rcu_assign_pointer\">rcu_assign_pointer</a>(<a class=\"id\" href=\"#head\">head</a>-><a class=\"id\" href=\"#next\">next</a>, <a class=\"id\" href=\"#first\">first</a>);", 
"<span class=\"ts\"/><a class=\"id\" href=\"#first\">first</a>-><a class=\"id\" href=\"#prev\">prev</a> = <a class=\"id\" href=\"#head\">head</a>;", 
"<span class=\"ts\"/><a class=\"id\" href=\"#at\">at</a>-><a class=\"id\" href=\"#prev\">prev</a> = <a class=\"id\" href=\"#last\">last</a>;", 
"}", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * list_entry_rcu - get the struct for this entry</span>", 
"<span class=\"comment\"> * @ptr:        the &amp;struct list_head pointer.</span>", 
"<span class=\"comment\"> * @type:       the type of the struct this is embedded in.</span>", 
"<span class=\"comment\"> * @member:     the name of the list_struct within the struct.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * This primitive may safely run concurrently with the _rcu list-mutation</span>", 
"<span class=\"comment\"> * primitives such as list_add_rcu() as long as it's guarded by rcu_read_lock().</span>", 
"<span class=\"comment\"> */</span>", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#list_entry_rcu\">list_entry_rcu</a>(<a class=\"id\" href=\"#ptr\">ptr</a>, <a class=\"id\" href=\"#type\">type</a>, <a class=\"id\" href=\"#member\">member</a>) \\", 
"<span class=\"ts\"/><a class=\"id\" href=\"#container_of\">container_of</a>(<a class=\"id\" href=\"#rcu_dereference_raw\">rcu_dereference_raw</a>(<a class=\"id\" href=\"#ptr\">ptr</a>), <a class=\"id\" href=\"#type\">type</a>, <a class=\"id\" href=\"#member\">member</a>)", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * list_first_entry_rcu - get the first element from a list</span>", 
"<span class=\"comment\"> * @ptr:        the list head to take the element from.</span>", 
"<span class=\"comment\"> * @type:       the type of the struct this is embedded in.</span>", 
"<span class=\"comment\"> * @member:     the name of the list_struct within the struct.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Note, that list is expected to be not empty.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * This primitive may safely run concurrently with the _rcu list-mutation</span>", 
"<span class=\"comment\"> * primitives such as list_add_rcu() as long as it's guarded by rcu_read_lock().</span>", 
"<span class=\"comment\"> */</span>", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#list_first_entry_rcu\">list_first_entry_rcu</a>(<a class=\"id\" href=\"#ptr\">ptr</a>, <a class=\"id\" href=\"#type\">type</a>, <a class=\"id\" href=\"#member\">member</a>) \\", 
"<span class=\"ts\"/><a class=\"id\" href=\"#list_entry_rcu\">list_entry_rcu</a>((<a class=\"id\" href=\"#ptr\">ptr</a>)-><a class=\"id\" href=\"#next\">next</a>, <a class=\"id\" href=\"#type\">type</a>, <a class=\"id\" href=\"#member\">member</a>)", 
"", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#__list_for_each_rcu\">__list_for_each_rcu</a>(<a class=\"id\" href=\"#pos\">pos</a>, <a class=\"id\" href=\"#head\">head</a>) \\", 
"<span class=\"ts\"/>for (<a class=\"id\" href=\"#pos\">pos</a> = <a class=\"id\" href=\"#rcu_dereference_raw\">rcu_dereference_raw</a>((<a class=\"id\" href=\"#head\">head</a>)-><a class=\"id\" href=\"#next\">next</a>); \\", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#pos\">pos</a> != (<a class=\"id\" href=\"#head\">head</a>); \\", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#pos\">pos</a> = <a class=\"id\" href=\"#rcu_dereference_raw\">rcu_dereference_raw</a>(<a class=\"id\" href=\"#pos\">pos</a>-><a class=\"id\" href=\"#next\">next</a>))", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * list_for_each_entry_rcu<span class=\"ts\"/>-<span class=\"ts\"/>iterate over rcu list of given type</span>", 
"<span class=\"comment\"> * @pos:<span class=\"ts\"/>the type * to use as a loop cursor.</span>", 
"<span class=\"comment\"> * @head:<span class=\"ts\"/>the head for your list.</span>", 
"<span class=\"comment\"> * @member:<span class=\"ts\"/>the name of the list_struct within the struct.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * This list-traversal primitive may safely run concurrently with</span>", 
"<span class=\"comment\"> * the _rcu list-mutation primitives such as list_add_rcu()</span>", 
"<span class=\"comment\"> * as long as the traversal is guarded by rcu_read_lock().</span>", 
"<span class=\"comment\"> */</span>", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#list_for_each_entry_rcu\">list_for_each_entry_rcu</a>(<a class=\"id\" href=\"#pos\">pos</a>, <a class=\"id\" href=\"#head\">head</a>, <a class=\"id\" href=\"#member\">member</a>) \\", 
"<span class=\"ts\"/>for (<a class=\"id\" href=\"#pos\">pos</a> = <a class=\"id\" href=\"#list_entry_rcu\">list_entry_rcu</a>((<a class=\"id\" href=\"#head\">head</a>)-><a class=\"id\" href=\"#next\">next</a>, <a class=\"id\" href=\"#typeof\">typeof</a>(*<a class=\"id\" href=\"#pos\">pos</a>), <a class=\"id\" href=\"#member\">member</a>); \\", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#prefetch\">prefetch</a>(<a class=\"id\" href=\"#pos\">pos</a>-><a class=\"id\" href=\"#member\">member</a>.<a class=\"id\" href=\"#next\">next</a>), &amp;<a class=\"id\" href=\"#pos\">pos</a>-><a class=\"id\" href=\"#member\">member</a> != (<a class=\"id\" href=\"#head\">head</a>); \\", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#pos\">pos</a> = <a class=\"id\" href=\"#list_entry_rcu\">list_entry_rcu</a>(<a class=\"id\" href=\"#pos\">pos</a>-><a class=\"id\" href=\"#member\">member</a>.<a class=\"id\" href=\"#next\">next</a>, <a class=\"id\" href=\"#typeof\">typeof</a>(*<a class=\"id\" href=\"#pos\">pos</a>), <a class=\"id\" href=\"#member\">member</a>))", 
"", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * list_for_each_continue_rcu</span>", 
"<span class=\"comment\"> * @pos:<span class=\"ts\"/>the &amp;struct list_head to use as a loop cursor.</span>", 
"<span class=\"comment\"> * @head:<span class=\"ts\"/>the head for your list.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Iterate over an rcu-protected list, continuing after current point.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * This list-traversal primitive may safely run concurrently with</span>", 
"<span class=\"comment\"> * the _rcu list-mutation primitives such as list_add_rcu()</span>", 
"<span class=\"comment\"> * as long as the traversal is guarded by rcu_read_lock().</span>", 
"<span class=\"comment\"> */</span>", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#list_for_each_continue_rcu\">list_for_each_continue_rcu</a>(<a class=\"id\" href=\"#pos\">pos</a>, <a class=\"id\" href=\"#head\">head</a>) \\", 
"<span class=\"ts\"/>for ((<a class=\"id\" href=\"#pos\">pos</a>) = <a class=\"id\" href=\"#rcu_dereference_raw\">rcu_dereference_raw</a>((<a class=\"id\" href=\"#pos\">pos</a>)-><a class=\"id\" href=\"#next\">next</a>); \\", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#prefetch\">prefetch</a>((<a class=\"id\" href=\"#pos\">pos</a>)-><a class=\"id\" href=\"#next\">next</a>), (<a class=\"id\" href=\"#pos\">pos</a>) != (<a class=\"id\" href=\"#head\">head</a>); \\", 
"<span class=\"ts\"/><span class=\"ts\"/>(<a class=\"id\" href=\"#pos\">pos</a>) = <a class=\"id\" href=\"#rcu_dereference_raw\">rcu_dereference_raw</a>((<a class=\"id\" href=\"#pos\">pos</a>)-><a class=\"id\" href=\"#next\">next</a>))", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * list_for_each_entry_continue_rcu - continue iteration over list of given type</span>", 
"<span class=\"comment\"> * @pos:<span class=\"ts\"/>the type * to use as a loop cursor.</span>", 
"<span class=\"comment\"> * @head:<span class=\"ts\"/>the head for your list.</span>", 
"<span class=\"comment\"> * @member:<span class=\"ts\"/>the name of the list_struct within the struct.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Continue to iterate over list of given type, continuing after</span>", 
"<span class=\"comment\"> * the current position.</span>", 
"<span class=\"comment\"> */</span>", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#list_for_each_entry_continue_rcu\">list_for_each_entry_continue_rcu</a>(<a class=\"id\" href=\"#pos\">pos</a>, <a class=\"id\" href=\"#head\">head</a>, <a class=\"id\" href=\"#member\">member</a>) <span class=\"ts\"/><span class=\"ts\"/>\\", 
"<span class=\"ts\"/>for (<a class=\"id\" href=\"#pos\">pos</a> = <a class=\"id\" href=\"#list_entry_rcu\">list_entry_rcu</a>(<a class=\"id\" href=\"#pos\">pos</a>-><a class=\"id\" href=\"#member\">member</a>.<a class=\"id\" href=\"#next\">next</a>, <a class=\"id\" href=\"#typeof\">typeof</a>(*<a class=\"id\" href=\"#pos\">pos</a>), <a class=\"id\" href=\"#member\">member</a>); \\", 
"<span class=\"ts\"/>     <a class=\"id\" href=\"#prefetch\">prefetch</a>(<a class=\"id\" href=\"#pos\">pos</a>-><a class=\"id\" href=\"#member\">member</a>.<a class=\"id\" href=\"#next\">next</a>), &amp;<a class=\"id\" href=\"#pos\">pos</a>-><a class=\"id\" href=\"#member\">member</a> != (<a class=\"id\" href=\"#head\">head</a>);<span class=\"ts\"/>\\", 
"<span class=\"ts\"/>     <a class=\"id\" href=\"#pos\">pos</a> = <a class=\"id\" href=\"#list_entry_rcu\">list_entry_rcu</a>(<a class=\"id\" href=\"#pos\">pos</a>-><a class=\"id\" href=\"#member\">member</a>.<a class=\"id\" href=\"#next\">next</a>, <a class=\"id\" href=\"#typeof\">typeof</a>(*<a class=\"id\" href=\"#pos\">pos</a>), <a class=\"id\" href=\"#member\">member</a>))", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * hlist_del_rcu - deletes entry from hash list without re-initialization</span>", 
"<span class=\"comment\"> * @n: the element to delete from the hash list.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Note: list_unhashed() on entry does not return true after this,</span>", 
"<span class=\"comment\"> * the entry is in an undefined state. It is useful for RCU based</span>", 
"<span class=\"comment\"> * lockfree traversal.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * In particular, it means that we can not poison the forward</span>", 
"<span class=\"comment\"> * pointers that may still be used for walking the hash list.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * The caller must take whatever precautions are necessary</span>", 
"<span class=\"comment\"> * (such as holding appropriate locks) to avoid racing</span>", 
"<span class=\"comment\"> * with another list-mutation primitive, such as hlist_add_head_rcu()</span>", 
"<span class=\"comment\"> * or hlist_del_rcu(), running on this same list.</span>", 
"<span class=\"comment\"> * However, it is perfectly legal to run concurrently with</span>", 
"<span class=\"comment\"> * the _rcu list-traversal primitives, such as</span>", 
"<span class=\"comment\"> * hlist_for_each_entry().</span>", 
"<span class=\"comment\"> */</span>", 
"static <a class=\"id\" href=\"#inline\">inline</a> void <a class=\"id\" href=\"#hlist_del_rcu\">hlist_del_rcu</a>(struct <a class=\"id\" href=\"#hlist_node\">hlist_node</a> *<a class=\"id\" href=\"#n\">n</a>)", 
"{", 
"<span class=\"ts\"/><a class=\"id\" href=\"#__hlist_del\">__hlist_del</a>(<a class=\"id\" href=\"#n\">n</a>);", 
"<span class=\"ts\"/><a class=\"id\" href=\"#n\">n</a>-><a class=\"id\" href=\"#pprev\">pprev</a> = <a class=\"id\" href=\"#LIST_POISON2\">LIST_POISON2</a>;", 
"}", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * hlist_replace_rcu - replace old entry by new one</span>", 
"<span class=\"comment\"> * @old : the element to be replaced</span>", 
"<span class=\"comment\"> * @new : the new element to insert</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * The @old entry will be replaced with the @new entry atomically.</span>", 
"<span class=\"comment\"> */</span>", 
"static <a class=\"id\" href=\"#inline\">inline</a> void <a class=\"id\" href=\"#hlist_replace_rcu\">hlist_replace_rcu</a>(struct <a class=\"id\" href=\"#hlist_node\">hlist_node</a> *<a class=\"id\" href=\"#old\">old</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>struct <a class=\"id\" href=\"#hlist_node\">hlist_node</a> *<a class=\"id\" href=\"#new\">new</a>)", 
"{", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#hlist_node\">hlist_node</a> *<a class=\"id\" href=\"#next\">next</a> = <a class=\"id\" href=\"#old\">old</a>-><a class=\"id\" href=\"#next\">next</a>;", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#new\">new</a>-><a class=\"id\" href=\"#next\">next</a> = <a class=\"id\" href=\"#next\">next</a>;", 
"<span class=\"ts\"/><a class=\"id\" href=\"#new\">new</a>-><a class=\"id\" href=\"#pprev\">pprev</a> = <a class=\"id\" href=\"#old\">old</a>-><a class=\"id\" href=\"#pprev\">pprev</a>;", 
"<span class=\"ts\"/><a class=\"id\" href=\"#rcu_assign_pointer\">rcu_assign_pointer</a>(*<a class=\"id\" href=\"#new\">new</a>-><a class=\"id\" href=\"#pprev\">pprev</a>, <a class=\"id\" href=\"#new\">new</a>);", 
"<span class=\"ts\"/>if (<a class=\"id\" href=\"#next\">next</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#new\">new</a>-><a class=\"id\" href=\"#next\">next</a>-><a class=\"id\" href=\"#pprev\">pprev</a> = &amp;<a class=\"id\" href=\"#new\">new</a>-><a class=\"id\" href=\"#next\">next</a>;", 
];
xr_frag_insert('l/d5/d3b4090edd683f6fb1c86fd7ba47ffa9d8e6ea.xr', __xr_tmp);
