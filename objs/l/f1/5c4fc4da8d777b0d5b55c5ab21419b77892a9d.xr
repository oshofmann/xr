var __xr_tmp = [
"#<a class=\"id\" href=\"#ifndef\">ifndef</a> <a class=\"id\" href=\"#_XEN_MULTICALLS_H\">_XEN_MULTICALLS_H</a>", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#_XEN_MULTICALLS_H\">_XEN_MULTICALLS_H</a>", 
"", 
"#<a class=\"id\" href=\"#include\">include</a> \"xen-ops.h\"", 
"", 
"<span class=\"comment\">/* Multicalls */</span>", 
"struct <a class=\"id\" href=\"#multicall_space\">multicall_space</a>", 
"{", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#multicall_entry\">multicall_entry</a> *<a class=\"id\" href=\"#mc\">mc</a>;", 
"<span class=\"ts\"/>void *<a class=\"id\" href=\"#args\">args</a>;", 
"};", 
"", 
"<span class=\"comment\">/* Allocate room for a multicall and its args */</span>", 
"struct <a class=\"id\" href=\"#multicall_space\">multicall_space</a> <a class=\"id\" href=\"#__xen_mc_entry\">__xen_mc_entry</a>(<a class=\"id\" href=\"#size_t\">size_t</a> <a class=\"id\" href=\"#args\">args</a>);", 
"", 
"<a class=\"id\" href=\"#DECLARE_PER_CPU\">DECLARE_PER_CPU</a>(unsigned long, <a class=\"id\" href=\"#xen_mc_irq_flags\">xen_mc_irq_flags</a>);", 
"", 
"<span class=\"comment\">/* Call to start a batch of multiple __xen_mc_entry()s.  Must be</span>", 
"<span class=\"comment\">   paired with xen_mc_issue() */</span>", 
"static <a class=\"id\" href=\"#inline\">inline</a> void <a class=\"id\" href=\"#xen_mc_batch\">xen_mc_batch</a>(void)", 
"{", 
"<span class=\"ts\"/>unsigned long <a class=\"id\" href=\"#flags\">flags</a>;", 
"<span class=\"ts\"/><span class=\"comment\">/* need to disable interrupts until this entry is complete */</span>", 
"<span class=\"ts\"/><a class=\"id\" href=\"#local_irq_save\">local_irq_save</a>(<a class=\"id\" href=\"#flags\">flags</a>);", 
"<span class=\"ts\"/><a class=\"id\" href=\"#__get_cpu_var\">__get_cpu_var</a>(<a class=\"id\" href=\"#xen_mc_irq_flags\">xen_mc_irq_flags</a>) = <a class=\"id\" href=\"#flags\">flags</a>;", 
"}", 
"", 
"static <a class=\"id\" href=\"#inline\">inline</a> struct <a class=\"id\" href=\"#multicall_space\">multicall_space</a> <a class=\"id\" href=\"#xen_mc_entry\">xen_mc_entry</a>(<a class=\"id\" href=\"#size_t\">size_t</a> <a class=\"id\" href=\"#args\">args</a>)", 
"{", 
"<span class=\"ts\"/><a class=\"id\" href=\"#xen_mc_batch\">xen_mc_batch</a>();", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#__xen_mc_entry\">__xen_mc_entry</a>(<a class=\"id\" href=\"#args\">args</a>);", 
"}", 
"", 
"<span class=\"comment\">/* Flush all pending multicalls */</span>", 
"void <a class=\"id\" href=\"#xen_mc_flush\">xen_mc_flush</a>(void);", 
"", 
"<span class=\"comment\">/* Issue a multicall if we're not in a lazy mode */</span>", 
"static <a class=\"id\" href=\"#inline\">inline</a> void <a class=\"id\" href=\"#xen_mc_issue\">xen_mc_issue</a>(unsigned <a class=\"id\" href=\"#mode\">mode</a>)", 
"{", 
"<span class=\"ts\"/>if ((<a class=\"id\" href=\"#paravirt_get_lazy_mode\">paravirt_get_lazy_mode</a>() &amp; <a class=\"id\" href=\"#mode\">mode</a>) == 0)", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#xen_mc_flush\">xen_mc_flush</a>();", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/* restore flags saved in xen_mc_batch */</span>", 
"<span class=\"ts\"/><a class=\"id\" href=\"#local_irq_restore\">local_irq_restore</a>(<a class=\"id\" href=\"#percpu_read\">percpu_read</a>(<a class=\"id\" href=\"#xen_mc_irq_flags\">xen_mc_irq_flags</a>));", 
"}", 
"", 
"<span class=\"comment\">/* Set up a callback to be called when the current batch is flushed */</span>", 
"void <a class=\"id\" href=\"#xen_mc_callback\">xen_mc_callback</a>(void (*<a class=\"id\" href=\"#fn\">fn</a>)(void *), void *<a class=\"id\" href=\"#data\">data</a>);", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * Try to extend the arguments of the previous multicall command.  The</span>", 
"<span class=\"comment\"> * previous command's op must match.  If it does, then it attempts to</span>", 
"<span class=\"comment\"> * extend the argument space allocated to the multicall entry by</span>", 
"<span class=\"comment\"> * arg_size bytes.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * The returned multicall_space will return with mc pointing to the</span>", 
"<span class=\"comment\"> * command on success, or NULL on failure, and args pointing to the</span>", 
"<span class=\"comment\"> * newly allocated space.</span>", 
"<span class=\"comment\"> */</span>", 
"struct <a class=\"id\" href=\"#multicall_space\">multicall_space</a> <a class=\"id\" href=\"#xen_mc_extend_args\">xen_mc_extend_args</a>(unsigned long <a class=\"id\" href=\"#op\">op</a>, <a class=\"id\" href=\"#size_t\">size_t</a> <a class=\"id\" href=\"#arg_size\">arg_size</a>);", 
"", 
"#<a class=\"id\" href=\"#endif\">endif</a> <span class=\"comment\">/* _XEN_MULTICALLS_H */</span>", 
];
xr_frag_insert('l/f1/5c4fc4da8d777b0d5b55c5ab21419b77892a9d.xr', __xr_tmp);
