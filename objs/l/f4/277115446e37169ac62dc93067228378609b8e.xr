var __xr_tmp = [
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> *  kernel/cpuset.c</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> *  Processor and Memory placement constraints for sets of tasks.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> *  Copyright (C) 2003 BULL SA.</span>", 
"<span class=\"comment\"> *  Copyright (C) 2004-2007 Silicon Graphics, Inc.</span>", 
"<span class=\"comment\"> *  Copyright (C) 2006 Google, Inc</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> *  Portions derived from Patrick Mochel's sysfs code.</span>", 
"<span class=\"comment\"> *  sysfs is Copyright (c) 2001-3 Patrick Mochel</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> *  2003-10-10 Written by Simon Derr.</span>", 
"<span class=\"comment\"> *  2003-10-22 Updates by Stephen Hemminger.</span>", 
"<span class=\"comment\"> *  2004 May-July Rework by Paul Jackson.</span>", 
"<span class=\"comment\"> *  2006 Rework by Paul Menage to use generic cgroups</span>", 
"<span class=\"comment\"> *  2008 Rework of the scheduler domains and CPU hotplug handling</span>", 
"<span class=\"comment\"> *       by Max Krasnyansky</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> *  This file is subject to the terms and conditions of the GNU General Public</span>", 
"<span class=\"comment\"> *  License.  See the file COPYING in the main directory of the Linux</span>", 
"<span class=\"comment\"> *  distribution for more details.</span>", 
"<span class=\"comment\"> */</span>", 
"", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#cpu\">cpu</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#cpumask\">cpumask</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#cpuset\">cpuset</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#err\">err</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#errno\">errno</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#file\">file</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#fs\">fs</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#init\">init</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#interrupt\">interrupt</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#kernel\">kernel</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#kmod\">kmod</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#list\">list</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#mempolicy\">mempolicy</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#mm\">mm</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#memory\">memory</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#module\">module</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#mount\">mount</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#namei\">namei</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#pagemap\">pagemap</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#proc_fs\">proc_fs</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#rcupdate\">rcupdate</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#sched\">sched</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#seq_file\">seq_file</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#security\">security</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#slab\">slab</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#spinlock\">spinlock</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#stat\">stat</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#string\">string</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#time\">time</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#backing\">backing</a>-<a class=\"id\" href=\"#dev\">dev</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#sort\">sort</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#asm\">asm</a>/<a class=\"id\" href=\"#uaccess\">uaccess</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#asm\">asm</a>/<a class=\"id\" href=\"#atomic\">atomic</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#mutex\">mutex</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#workqueue\">workqueue</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"#<a class=\"id\" href=\"#include\">include</a> &lt;<a class=\"id\" href=\"#linux\">linux</a>/<a class=\"id\" href=\"#cgroup\">cgroup</a>.<a class=\"id\" href=\"#h\">h</a>&gt;", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * Workqueue for cpuset related tasks.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Using kevent workqueue may cause deadlock when memory_migrate</span>", 
"<span class=\"comment\"> * is set. So we create a separate workqueue thread for cpuset.</span>", 
"<span class=\"comment\"> */</span>", 
"static struct <a class=\"id\" href=\"#workqueue_struct\">workqueue_struct</a> *<a class=\"id\" href=\"#cpuset_wq\">cpuset_wq</a>;", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * Tracks how many cpusets are currently defined in system.</span>", 
"<span class=\"comment\"> * When there is only one cpuset (the root cpuset) we can</span>", 
"<span class=\"comment\"> * short circuit some hooks.</span>", 
"<span class=\"comment\"> */</span>", 
"int <a class=\"id\" href=\"#number_of_cpusets\">number_of_cpusets</a> <a class=\"id\" href=\"#__read_mostly\">__read_mostly</a>;", 
"", 
"<span class=\"comment\">/* Forward declare cgroup structures */</span>", 
"struct <a class=\"id\" href=\"#cgroup_subsys\">cgroup_subsys</a> <a class=\"id\" href=\"#cpuset_subsys\">cpuset_subsys</a>;", 
"struct <a class=\"id\" href=\"#cpuset\">cpuset</a>;", 
"", 
"<span class=\"comment\">/* See \"Frequency meter\" comments, below. */</span>", 
"", 
"struct <a class=\"id\" href=\"#fmeter\">fmeter</a> {", 
"<span class=\"ts\"/>int <a class=\"id\" href=\"#cnt\">cnt</a>;<span class=\"ts\"/><span class=\"ts\"/><span class=\"comment\">/* unprocessed events count */</span>", 
"<span class=\"ts\"/>int <a class=\"id\" href=\"#val\">val</a>;<span class=\"ts\"/><span class=\"ts\"/><span class=\"comment\">/* most recent output value */</span>", 
"<span class=\"ts\"/><a class=\"id\" href=\"#time_t\">time_t</a> <a class=\"id\" href=\"#time\">time</a>;<span class=\"ts\"/><span class=\"ts\"/><span class=\"comment\">/* clock (secs) when val computed */</span>", 
"<span class=\"ts\"/><a class=\"id\" href=\"#spinlock_t\">spinlock_t</a> <a class=\"id\" href=\"#lock\">lock</a>;<span class=\"ts\"/><span class=\"comment\">/* guards read or write of above */</span>", 
"};", 
"", 
"struct <a class=\"id\" href=\"#cpuset\">cpuset</a> {", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#cgroup_subsys_state\">cgroup_subsys_state</a> <a class=\"id\" href=\"#css\">css</a>;", 
"", 
"<span class=\"ts\"/>unsigned long <a class=\"id\" href=\"#flags\">flags</a>;<span class=\"ts\"/><span class=\"ts\"/><span class=\"comment\">/* \"unsigned long\" so bitops work */</span>", 
"<span class=\"ts\"/><a class=\"id\" href=\"#cpumask_var_t\">cpumask_var_t</a> <a class=\"id\" href=\"#cpus_allowed\">cpus_allowed</a>;<span class=\"ts\"/><span class=\"comment\">/* CPUs allowed to tasks in cpuset */</span>", 
"<span class=\"ts\"/><a class=\"id\" href=\"#nodemask_t\">nodemask_t</a> <a class=\"id\" href=\"#mems_allowed\">mems_allowed</a>;<span class=\"ts\"/><span class=\"comment\">/* Memory Nodes allowed to tasks */</span>", 
"", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#cpuset\">cpuset</a> *<a class=\"id\" href=\"#parent\">parent</a>;<span class=\"ts\"/><span class=\"ts\"/><span class=\"comment\">/* my parent */</span>", 
"", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#fmeter\">fmeter</a> <a class=\"id\" href=\"#fmeter\">fmeter</a>;<span class=\"ts\"/><span class=\"ts\"/><span class=\"comment\">/* memory_pressure filter */</span>", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/* partition number for rebuild_sched_domains() */</span>", 
"<span class=\"ts\"/>int <a class=\"id\" href=\"#pn\">pn</a>;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/* for custom sched domain */</span>", 
"<span class=\"ts\"/>int <a class=\"id\" href=\"#relax_domain_level\">relax_domain_level</a>;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/* used for walking a cpuset hierarchy */</span>", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#list_head\">list_head</a> <a class=\"id\" href=\"#stack_list\">stack_list</a>;", 
"};", 
"", 
"<span class=\"comment\">/* Retrieve the cpuset for a cgroup */</span>", 
"static <a class=\"id\" href=\"#inline\">inline</a> struct <a class=\"id\" href=\"#cpuset\">cpuset</a> *<a class=\"id\" href=\"#cgroup_cs\">cgroup_cs</a>(struct <a class=\"id\" href=\"#cgroup\">cgroup</a> *<a class=\"id\" href=\"#cont\">cont</a>)", 
"{", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#container_of\">container_of</a>(<a class=\"id\" href=\"#cgroup_subsys_state\">cgroup_subsys_state</a>(<a class=\"id\" href=\"#cont\">cont</a>, <a class=\"id\" href=\"#cpuset_subsys_id\">cpuset_subsys_id</a>),", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>    struct <a class=\"id\" href=\"#cpuset\">cpuset</a>, <a class=\"id\" href=\"#css\">css</a>);", 
"}", 
"", 
"<span class=\"comment\">/* Retrieve the cpuset for a task */</span>", 
"static <a class=\"id\" href=\"#inline\">inline</a> struct <a class=\"id\" href=\"#cpuset\">cpuset</a> *<a class=\"id\" href=\"#task_cs\">task_cs</a>(struct <a class=\"id\" href=\"#task_struct\">task_struct</a> *<a class=\"id\" href=\"#task\">task</a>)", 
"{", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#container_of\">container_of</a>(<a class=\"id\" href=\"#task_subsys_state\">task_subsys_state</a>(<a class=\"id\" href=\"#task\">task</a>, <a class=\"id\" href=\"#cpuset_subsys_id\">cpuset_subsys_id</a>),", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>    struct <a class=\"id\" href=\"#cpuset\">cpuset</a>, <a class=\"id\" href=\"#css\">css</a>);", 
"}", 
"", 
"<span class=\"comment\">/* bits in struct cpuset flags field */</span>", 
"typedef enum {", 
"<span class=\"ts\"/><a class=\"id\" href=\"#CS_CPU_EXCLUSIVE\">CS_CPU_EXCLUSIVE</a>,", 
"<span class=\"ts\"/><a class=\"id\" href=\"#CS_MEM_EXCLUSIVE\">CS_MEM_EXCLUSIVE</a>,", 
"<span class=\"ts\"/><a class=\"id\" href=\"#CS_MEM_HARDWALL\">CS_MEM_HARDWALL</a>,", 
"<span class=\"ts\"/><a class=\"id\" href=\"#CS_MEMORY_MIGRATE\">CS_MEMORY_MIGRATE</a>,", 
"<span class=\"ts\"/><a class=\"id\" href=\"#CS_SCHED_LOAD_BALANCE\">CS_SCHED_LOAD_BALANCE</a>,", 
"<span class=\"ts\"/><a class=\"id\" href=\"#CS_SPREAD_PAGE\">CS_SPREAD_PAGE</a>,", 
"<span class=\"ts\"/><a class=\"id\" href=\"#CS_SPREAD_SLAB\">CS_SPREAD_SLAB</a>,", 
"} <a class=\"id\" href=\"#cpuset_flagbits_t\">cpuset_flagbits_t</a>;", 
"", 
"<span class=\"comment\">/* convenient tests for these bits */</span>", 
"static <a class=\"id\" href=\"#inline\">inline</a> int <a class=\"id\" href=\"#is_cpu_exclusive\">is_cpu_exclusive</a>(const struct <a class=\"id\" href=\"#cpuset\">cpuset</a> *<a class=\"id\" href=\"#cs\">cs</a>)", 
"{", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#test_bit\">test_bit</a>(<a class=\"id\" href=\"#CS_CPU_EXCLUSIVE\">CS_CPU_EXCLUSIVE</a>, &amp;<a class=\"id\" href=\"#cs\">cs</a>-><a class=\"id\" href=\"#flags\">flags</a>);", 
"}", 
"", 
"static <a class=\"id\" href=\"#inline\">inline</a> int <a class=\"id\" href=\"#is_mem_exclusive\">is_mem_exclusive</a>(const struct <a class=\"id\" href=\"#cpuset\">cpuset</a> *<a class=\"id\" href=\"#cs\">cs</a>)", 
"{", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#test_bit\">test_bit</a>(<a class=\"id\" href=\"#CS_MEM_EXCLUSIVE\">CS_MEM_EXCLUSIVE</a>, &amp;<a class=\"id\" href=\"#cs\">cs</a>-><a class=\"id\" href=\"#flags\">flags</a>);", 
"}", 
"", 
"static <a class=\"id\" href=\"#inline\">inline</a> int <a class=\"id\" href=\"#is_mem_hardwall\">is_mem_hardwall</a>(const struct <a class=\"id\" href=\"#cpuset\">cpuset</a> *<a class=\"id\" href=\"#cs\">cs</a>)", 
"{", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#test_bit\">test_bit</a>(<a class=\"id\" href=\"#CS_MEM_HARDWALL\">CS_MEM_HARDWALL</a>, &amp;<a class=\"id\" href=\"#cs\">cs</a>-><a class=\"id\" href=\"#flags\">flags</a>);", 
"}", 
"", 
"static <a class=\"id\" href=\"#inline\">inline</a> int <a class=\"id\" href=\"#is_sched_load_balance\">is_sched_load_balance</a>(const struct <a class=\"id\" href=\"#cpuset\">cpuset</a> *<a class=\"id\" href=\"#cs\">cs</a>)", 
"{", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#test_bit\">test_bit</a>(<a class=\"id\" href=\"#CS_SCHED_LOAD_BALANCE\">CS_SCHED_LOAD_BALANCE</a>, &amp;<a class=\"id\" href=\"#cs\">cs</a>-><a class=\"id\" href=\"#flags\">flags</a>);", 
"}", 
"", 
"static <a class=\"id\" href=\"#inline\">inline</a> int <a class=\"id\" href=\"#is_memory_migrate\">is_memory_migrate</a>(const struct <a class=\"id\" href=\"#cpuset\">cpuset</a> *<a class=\"id\" href=\"#cs\">cs</a>)", 
"{", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#test_bit\">test_bit</a>(<a class=\"id\" href=\"#CS_MEMORY_MIGRATE\">CS_MEMORY_MIGRATE</a>, &amp;<a class=\"id\" href=\"#cs\">cs</a>-><a class=\"id\" href=\"#flags\">flags</a>);", 
"}", 
"", 
"static <a class=\"id\" href=\"#inline\">inline</a> int <a class=\"id\" href=\"#is_spread_page\">is_spread_page</a>(const struct <a class=\"id\" href=\"#cpuset\">cpuset</a> *<a class=\"id\" href=\"#cs\">cs</a>)", 
"{", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#test_bit\">test_bit</a>(<a class=\"id\" href=\"#CS_SPREAD_PAGE\">CS_SPREAD_PAGE</a>, &amp;<a class=\"id\" href=\"#cs\">cs</a>-><a class=\"id\" href=\"#flags\">flags</a>);", 
"}", 
"", 
"static <a class=\"id\" href=\"#inline\">inline</a> int <a class=\"id\" href=\"#is_spread_slab\">is_spread_slab</a>(const struct <a class=\"id\" href=\"#cpuset\">cpuset</a> *<a class=\"id\" href=\"#cs\">cs</a>)", 
"{", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#test_bit\">test_bit</a>(<a class=\"id\" href=\"#CS_SPREAD_SLAB\">CS_SPREAD_SLAB</a>, &amp;<a class=\"id\" href=\"#cs\">cs</a>-><a class=\"id\" href=\"#flags\">flags</a>);", 
"}", 
"", 
"static struct <a class=\"id\" href=\"#cpuset\">cpuset</a> <a class=\"id\" href=\"#top_cpuset\">top_cpuset</a> = {", 
"<span class=\"ts\"/>.<a class=\"id\" href=\"#flags\">flags</a> = ((1 << <a class=\"id\" href=\"#CS_CPU_EXCLUSIVE\">CS_CPU_EXCLUSIVE</a>) | (1 << <a class=\"id\" href=\"#CS_MEM_EXCLUSIVE\">CS_MEM_EXCLUSIVE</a>)),", 
"};", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * There are two global mutexes guarding cpuset structures.  The first</span>", 
"<span class=\"comment\"> * is the main control groups cgroup_mutex, accessed via</span>", 
"<span class=\"comment\"> * cgroup_lock()/cgroup_unlock().  The second is the cpuset-specific</span>", 
"<span class=\"comment\"> * callback_mutex, below. They can nest.  It is ok to first take</span>", 
"<span class=\"comment\"> * cgroup_mutex, then nest callback_mutex.  We also require taking</span>", 
"<span class=\"comment\"> * task_lock() when dereferencing a task's cpuset pointer.  See \"The</span>", 
"<span class=\"comment\"> * task_lock() exception\", at the end of this comment.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * A task must hold both mutexes to modify cpusets.  If a task</span>", 
"<span class=\"comment\"> * holds cgroup_mutex, then it blocks others wanting that mutex,</span>", 
"<span class=\"comment\"> * ensuring that it is the only task able to also acquire callback_mutex</span>", 
"<span class=\"comment\"> * and be able to modify cpusets.  It can perform various checks on</span>", 
"<span class=\"comment\"> * the cpuset structure first, knowing nothing will change.  It can</span>", 
"<span class=\"comment\"> * also allocate memory while just holding cgroup_mutex.  While it is</span>", 
"<span class=\"comment\"> * performing these checks, various callback routines can briefly</span>", 
"<span class=\"comment\"> * acquire callback_mutex to query cpusets.  Once it is ready to make</span>", 
"<span class=\"comment\"> * the changes, it takes callback_mutex, blocking everyone else.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Calls to the kernel memory allocator can not be made while holding</span>", 
"<span class=\"comment\"> * callback_mutex, as that would risk double tripping on callback_mutex</span>", 
"<span class=\"comment\"> * from one of the callbacks into the cpuset code from within</span>", 
"<span class=\"comment\"> * __alloc_pages().</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * If a task is only holding callback_mutex, then it has read-only</span>", 
"<span class=\"comment\"> * access to cpusets.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Now, the task_struct fields mems_allowed and mempolicy may be changed</span>", 
"<span class=\"comment\"> * by other task, we use alloc_lock in the task_struct fields to protect</span>", 
"<span class=\"comment\"> * them.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * The cpuset_common_file_read() handlers only hold callback_mutex across</span>", 
"<span class=\"comment\"> * small pieces of code, such as when reading out possibly multi-word</span>", 
"<span class=\"comment\"> * cpumasks and nodemasks.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Accessing a task's cpuset should be done in accordance with the</span>", 
"<span class=\"comment\"> * guidelines for accessing subsystem state in kernel/cgroup.c</span>", 
"<span class=\"comment\"> */</span>", 
"", 
"static <a class=\"id\" href=\"#DEFINE_MUTEX\">DEFINE_MUTEX</a>(<a class=\"id\" href=\"#callback_mutex\">callback_mutex</a>);", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * cpuset_buffer_lock protects both the cpuset_name and cpuset_nodelist</span>", 
"<span class=\"comment\"> * buffers.  They are statically allocated to prevent using excess stack</span>", 
"<span class=\"comment\"> * when calling cpuset_print_task_mems_allowed().</span>", 
"<span class=\"comment\"> */</span>", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#CPUSET_NAME_LEN\">CPUSET_NAME_LEN</a><span class=\"ts\"/><span class=\"ts\"/>(128)", 
"#<a class=\"id\" href=\"#define\">define</a><span class=\"ts\"/><a class=\"id\" href=\"#CPUSET_NODELIST_LEN\">CPUSET_NODELIST_LEN</a><span class=\"ts\"/>(256)", 
"static char <a class=\"id\" href=\"#cpuset_name\">cpuset_name</a>[<a class=\"id\" href=\"#CPUSET_NAME_LEN\">CPUSET_NAME_LEN</a>];", 
"static char <a class=\"id\" href=\"#cpuset_nodelist\">cpuset_nodelist</a>[<a class=\"id\" href=\"#CPUSET_NODELIST_LEN\">CPUSET_NODELIST_LEN</a>];", 
"static <a class=\"id\" href=\"#DEFINE_SPINLOCK\">DEFINE_SPINLOCK</a>(<a class=\"id\" href=\"#cpuset_buffer_lock\">cpuset_buffer_lock</a>);", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * This is ugly, but preserves the userspace API for existing cpuset</span>", 
"<span class=\"comment\"> * users. If someone tries to mount the \"cpuset\" filesystem, we</span>", 
"<span class=\"comment\"> * silently switch it to mount \"cgroup\" instead</span>", 
"<span class=\"comment\"> */</span>", 
"static int <a class=\"id\" href=\"#cpuset_get_sb\">cpuset_get_sb</a>(struct <a class=\"id\" href=\"#file_system_type\">file_system_type</a> *<a class=\"id\" href=\"#fs_type\">fs_type</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/> int <a class=\"id\" href=\"#flags\">flags</a>, const char *<a class=\"id\" href=\"#unused_dev_name\">unused_dev_name</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/> void *<a class=\"id\" href=\"#data\">data</a>, struct <a class=\"id\" href=\"#vfsmount\">vfsmount</a> *<a class=\"id\" href=\"#mnt\">mnt</a>)", 
"{", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#file_system_type\">file_system_type</a> *<a class=\"id\" href=\"#cgroup_fs\">cgroup_fs</a> = <a class=\"id\" href=\"#get_fs_type\">get_fs_type</a>(\"cgroup\");", 
"<span class=\"ts\"/>int <a class=\"id\" href=\"#ret\">ret</a> = -<a class=\"id\" href=\"#ENODEV\">ENODEV</a>;", 
"<span class=\"ts\"/>if (<a class=\"id\" href=\"#cgroup_fs\">cgroup_fs</a>) {", 
"<span class=\"ts\"/><span class=\"ts\"/>char <a class=\"id\" href=\"#mountopts\">mountopts</a>[] =", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>\"cpuset,noprefix,\"", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>\"release_agent=/sbin/cpuset_release_agent\";", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#ret\">ret</a> = <a class=\"id\" href=\"#cgroup_fs\">cgroup_fs</a>-><a class=\"id\" href=\"#get_sb\">get_sb</a>(<a class=\"id\" href=\"#cgroup_fs\">cgroup_fs</a>, <a class=\"id\" href=\"#flags\">flags</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>   <a class=\"id\" href=\"#unused_dev_name\">unused_dev_name</a>, <a class=\"id\" href=\"#mountopts\">mountopts</a>, <a class=\"id\" href=\"#mnt\">mnt</a>);", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#put_filesystem\">put_filesystem</a>(<a class=\"id\" href=\"#cgroup_fs\">cgroup_fs</a>);", 
"<span class=\"ts\"/>}", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#ret\">ret</a>;", 
"}", 
"", 
"static struct <a class=\"id\" href=\"#file_system_type\">file_system_type</a> <a class=\"id\" href=\"#cpuset_fs_type\">cpuset_fs_type</a> = {", 
"<span class=\"ts\"/>.<a class=\"id\" href=\"#name\">name</a> = \"cpuset\",", 
"<span class=\"ts\"/>.<a class=\"id\" href=\"#get_sb\">get_sb</a> = <a class=\"id\" href=\"#cpuset_get_sb\">cpuset_get_sb</a>,", 
"};", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * Return in pmask the portion of a cpusets's cpus_allowed that</span>", 
"<span class=\"comment\"> * are online.  If none are online, walk up the cpuset hierarchy</span>", 
"<span class=\"comment\"> * until we find one that does have some online cpus.  If we get</span>", 
"<span class=\"comment\"> * all the way to the top and still haven't found any online cpus,</span>", 
"<span class=\"comment\"> * return cpu_online_map.  Or if passed a NULL cs from an exit'ing</span>", 
"<span class=\"comment\"> * task, return cpu_online_map.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * One way or another, we guarantee to return some non-empty subset</span>", 
"<span class=\"comment\"> * of cpu_online_map.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Call with callback_mutex held.</span>", 
"<span class=\"comment\"> */</span>", 
"", 
"static void <a class=\"id\" href=\"#guarantee_online_cpus\">guarantee_online_cpus</a>(const struct <a class=\"id\" href=\"#cpuset\">cpuset</a> *<a class=\"id\" href=\"#cs\">cs</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>  struct <a class=\"id\" href=\"#cpumask\">cpumask</a> *<a class=\"id\" href=\"#pmask\">pmask</a>)", 
"{", 
"<span class=\"ts\"/>while (<a class=\"id\" href=\"#cs\">cs</a> && !<a class=\"id\" href=\"#cpumask_intersects\">cpumask_intersects</a>(<a class=\"id\" href=\"#cs\">cs</a>-><a class=\"id\" href=\"#cpus_allowed\">cpus_allowed</a>, <a class=\"id\" href=\"#cpu_online_mask\">cpu_online_mask</a>))", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#cs\">cs</a> = <a class=\"id\" href=\"#cs\">cs</a>-><a class=\"id\" href=\"#parent\">parent</a>;", 
"<span class=\"ts\"/>if (<a class=\"id\" href=\"#cs\">cs</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#cpumask_and\">cpumask_and</a>(<a class=\"id\" href=\"#pmask\">pmask</a>, <a class=\"id\" href=\"#cs\">cs</a>-><a class=\"id\" href=\"#cpus_allowed\">cpus_allowed</a>, <a class=\"id\" href=\"#cpu_online_mask\">cpu_online_mask</a>);", 
"<span class=\"ts\"/>else", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#cpumask_copy\">cpumask_copy</a>(<a class=\"id\" href=\"#pmask\">pmask</a>, <a class=\"id\" href=\"#cpu_online_mask\">cpu_online_mask</a>);", 
"<span class=\"ts\"/><a class=\"id\" href=\"#BUG_ON\">BUG_ON</a>(!<a class=\"id\" href=\"#cpumask_intersects\">cpumask_intersects</a>(<a class=\"id\" href=\"#pmask\">pmask</a>, <a class=\"id\" href=\"#cpu_online_mask\">cpu_online_mask</a>));", 
"}", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * Return in *pmask the portion of a cpusets's mems_allowed that</span>", 
"<span class=\"comment\"> * are online, with memory.  If none are online with memory, walk</span>", 
"<span class=\"comment\"> * up the cpuset hierarchy until we find one that does have some</span>", 
"<span class=\"comment\"> * online mems.  If we get all the way to the top and still haven't</span>", 
"<span class=\"comment\"> * found any online mems, return node_states[N_HIGH_MEMORY].</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * One way or another, we guarantee to return some non-empty subset</span>", 
"<span class=\"comment\"> * of node_states[N_HIGH_MEMORY].</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Call with callback_mutex held.</span>", 
"<span class=\"comment\"> */</span>", 
"", 
"static void <a class=\"id\" href=\"#guarantee_online_mems\">guarantee_online_mems</a>(const struct <a class=\"id\" href=\"#cpuset\">cpuset</a> *<a class=\"id\" href=\"#cs\">cs</a>, <a class=\"id\" href=\"#nodemask_t\">nodemask_t</a> *<a class=\"id\" href=\"#pmask\">pmask</a>)", 
"{", 
"<span class=\"ts\"/>while (<a class=\"id\" href=\"#cs\">cs</a> && !<a class=\"id\" href=\"#nodes_intersects\">nodes_intersects</a>(<a class=\"id\" href=\"#cs\">cs</a>-><a class=\"id\" href=\"#mems_allowed\">mems_allowed</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#node_states\">node_states</a>[<a class=\"id\" href=\"#N_HIGH_MEMORY\">N_HIGH_MEMORY</a>]))", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#cs\">cs</a> = <a class=\"id\" href=\"#cs\">cs</a>-><a class=\"id\" href=\"#parent\">parent</a>;", 
"<span class=\"ts\"/>if (<a class=\"id\" href=\"#cs\">cs</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#nodes_and\">nodes_and</a>(*<a class=\"id\" href=\"#pmask\">pmask</a>, <a class=\"id\" href=\"#cs\">cs</a>-><a class=\"id\" href=\"#mems_allowed\">mems_allowed</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#node_states\">node_states</a>[<a class=\"id\" href=\"#N_HIGH_MEMORY\">N_HIGH_MEMORY</a>]);", 
"<span class=\"ts\"/>else", 
"<span class=\"ts\"/><span class=\"ts\"/>*<a class=\"id\" href=\"#pmask\">pmask</a> = <a class=\"id\" href=\"#node_states\">node_states</a>[<a class=\"id\" href=\"#N_HIGH_MEMORY\">N_HIGH_MEMORY</a>];", 
"<span class=\"ts\"/><a class=\"id\" href=\"#BUG_ON\">BUG_ON</a>(!<a class=\"id\" href=\"#nodes_intersects\">nodes_intersects</a>(*<a class=\"id\" href=\"#pmask\">pmask</a>, <a class=\"id\" href=\"#node_states\">node_states</a>[<a class=\"id\" href=\"#N_HIGH_MEMORY\">N_HIGH_MEMORY</a>]));", 
"}", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * update task's spread flag if cpuset's page/slab spread flag is set</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Called with callback_mutex/cgroup_mutex held</span>", 
"<span class=\"comment\"> */</span>", 
"static void <a class=\"id\" href=\"#cpuset_update_task_spread_flag\">cpuset_update_task_spread_flag</a>(struct <a class=\"id\" href=\"#cpuset\">cpuset</a> *<a class=\"id\" href=\"#cs\">cs</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>struct <a class=\"id\" href=\"#task_struct\">task_struct</a> *<a class=\"id\" href=\"#tsk\">tsk</a>)", 
"{", 
"<span class=\"ts\"/>if (<a class=\"id\" href=\"#is_spread_page\">is_spread_page</a>(<a class=\"id\" href=\"#cs\">cs</a>))", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#tsk\">tsk</a>-><a class=\"id\" href=\"#flags\">flags</a> |= <a class=\"id\" href=\"#PF_SPREAD_PAGE\">PF_SPREAD_PAGE</a>;", 
"<span class=\"ts\"/>else", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#tsk\">tsk</a>-><a class=\"id\" href=\"#flags\">flags</a> &= ~<a class=\"id\" href=\"#PF_SPREAD_PAGE\">PF_SPREAD_PAGE</a>;", 
"<span class=\"ts\"/>if (<a class=\"id\" href=\"#is_spread_slab\">is_spread_slab</a>(<a class=\"id\" href=\"#cs\">cs</a>))", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#tsk\">tsk</a>-><a class=\"id\" href=\"#flags\">flags</a> |= <a class=\"id\" href=\"#PF_SPREAD_SLAB\">PF_SPREAD_SLAB</a>;", 
"<span class=\"ts\"/>else", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#tsk\">tsk</a>-><a class=\"id\" href=\"#flags\">flags</a> &= ~<a class=\"id\" href=\"#PF_SPREAD_SLAB\">PF_SPREAD_SLAB</a>;", 
"}", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * is_cpuset_subset(p, q) - Is cpuset p a subset of cpuset q?</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * One cpuset is a subset of another if all its allowed CPUs and</span>", 
"<span class=\"comment\"> * Memory Nodes are a subset of the other, and its exclusive flags</span>", 
"<span class=\"comment\"> * are only set if the other's are set.  Call holding cgroup_mutex.</span>", 
"<span class=\"comment\"> */</span>", 
"", 
"static int <a class=\"id\" href=\"#is_cpuset_subset\">is_cpuset_subset</a>(const struct <a class=\"id\" href=\"#cpuset\">cpuset</a> *<a class=\"id\" href=\"#p\">p</a>, const struct <a class=\"id\" href=\"#cpuset\">cpuset</a> *<a class=\"id\" href=\"#q\">q</a>)", 
"{", 
"<span class=\"ts\"/>return<span class=\"ts\"/><a class=\"id\" href=\"#cpumask_subset\">cpumask_subset</a>(<a class=\"id\" href=\"#p\">p</a>-><a class=\"id\" href=\"#cpus_allowed\">cpus_allowed</a>, <a class=\"id\" href=\"#q\">q</a>-><a class=\"id\" href=\"#cpus_allowed\">cpus_allowed</a>) &&", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#nodes_subset\">nodes_subset</a>(<a class=\"id\" href=\"#p\">p</a>-><a class=\"id\" href=\"#mems_allowed\">mems_allowed</a>, <a class=\"id\" href=\"#q\">q</a>-><a class=\"id\" href=\"#mems_allowed\">mems_allowed</a>) &&", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#is_cpu_exclusive\">is_cpu_exclusive</a>(<a class=\"id\" href=\"#p\">p</a>) <= <a class=\"id\" href=\"#is_cpu_exclusive\">is_cpu_exclusive</a>(<a class=\"id\" href=\"#q\">q</a>) &&", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#is_mem_exclusive\">is_mem_exclusive</a>(<a class=\"id\" href=\"#p\">p</a>) <= <a class=\"id\" href=\"#is_mem_exclusive\">is_mem_exclusive</a>(<a class=\"id\" href=\"#q\">q</a>);", 
"}", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * alloc_trial_cpuset - allocate a trial cpuset</span>", 
"<span class=\"comment\"> * @cs: the cpuset that the trial cpuset duplicates</span>", 
"<span class=\"comment\"> */</span>", 
"static struct <a class=\"id\" href=\"#cpuset\">cpuset</a> *<a class=\"id\" href=\"#alloc_trial_cpuset\">alloc_trial_cpuset</a>(const struct <a class=\"id\" href=\"#cpuset\">cpuset</a> *<a class=\"id\" href=\"#cs\">cs</a>)", 
"{", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#cpuset\">cpuset</a> *<a class=\"id\" href=\"#trial\">trial</a>;", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#trial\">trial</a> = <a class=\"id\" href=\"#kmemdup\">kmemdup</a>(<a class=\"id\" href=\"#cs\">cs</a>, sizeof(*<a class=\"id\" href=\"#cs\">cs</a>), <a class=\"id\" href=\"#GFP_KERNEL\">GFP_KERNEL</a>);", 
"<span class=\"ts\"/>if (!<a class=\"id\" href=\"#trial\">trial</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/>return <a class=\"id\" href=\"#NULL\">NULL</a>;", 
"", 
"<span class=\"ts\"/>if (!<a class=\"id\" href=\"#alloc_cpumask_var\">alloc_cpumask_var</a>(&amp;<a class=\"id\" href=\"#trial\">trial</a>-><a class=\"id\" href=\"#cpus_allowed\">cpus_allowed</a>, <a class=\"id\" href=\"#GFP_KERNEL\">GFP_KERNEL</a>)) {", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#kfree\">kfree</a>(<a class=\"id\" href=\"#trial\">trial</a>);", 
"<span class=\"ts\"/><span class=\"ts\"/>return <a class=\"id\" href=\"#NULL\">NULL</a>;", 
"<span class=\"ts\"/>}", 
"<span class=\"ts\"/><a class=\"id\" href=\"#cpumask_copy\">cpumask_copy</a>(<a class=\"id\" href=\"#trial\">trial</a>-><a class=\"id\" href=\"#cpus_allowed\">cpus_allowed</a>, <a class=\"id\" href=\"#cs\">cs</a>-><a class=\"id\" href=\"#cpus_allowed\">cpus_allowed</a>);", 
"", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#trial\">trial</a>;", 
"}", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * free_trial_cpuset - free the trial cpuset</span>", 
"<span class=\"comment\"> * @trial: the trial cpuset to be freed</span>", 
"<span class=\"comment\"> */</span>", 
"static void <a class=\"id\" href=\"#free_trial_cpuset\">free_trial_cpuset</a>(struct <a class=\"id\" href=\"#cpuset\">cpuset</a> *<a class=\"id\" href=\"#trial\">trial</a>)", 
"{", 
"<span class=\"ts\"/><a class=\"id\" href=\"#free_cpumask_var\">free_cpumask_var</a>(<a class=\"id\" href=\"#trial\">trial</a>-><a class=\"id\" href=\"#cpus_allowed\">cpus_allowed</a>);", 
"<span class=\"ts\"/><a class=\"id\" href=\"#kfree\">kfree</a>(<a class=\"id\" href=\"#trial\">trial</a>);", 
"}", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * validate_change() - Used to validate that any proposed cpuset change</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/><span class=\"ts\"/>       follows the structural rules for cpusets.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * If we replaced the flag and mask values of the current cpuset</span>", 
"<span class=\"comment\"> * (cur) with those values in the trial cpuset (trial), would</span>", 
"<span class=\"comment\"> * our various subset and exclusive rules still be valid?  Presumes</span>", 
"<span class=\"comment\"> * cgroup_mutex held.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * 'cur' is the address of an actual, in-use cpuset.  Operations</span>", 
"<span class=\"comment\"> * such as list traversal that depend on the actual address of the</span>", 
"<span class=\"comment\"> * cpuset in the list must use cur below, not trial.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * 'trial' is the address of bulk structure copy of cur, with</span>", 
"<span class=\"comment\"> * perhaps one or more of the fields cpus_allowed, mems_allowed,</span>", 
"<span class=\"comment\"> * or flags changed to new, trial values.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Return 0 if valid, -errno if not.</span>", 
"<span class=\"comment\"> */</span>", 
"", 
"static int <a class=\"id\" href=\"#validate_change\">validate_change</a>(const struct <a class=\"id\" href=\"#cpuset\">cpuset</a> *<a class=\"id\" href=\"#cur\">cur</a>, const struct <a class=\"id\" href=\"#cpuset\">cpuset</a> *<a class=\"id\" href=\"#trial\">trial</a>)", 
"{", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#cgroup\">cgroup</a> *<a class=\"id\" href=\"#cont\">cont</a>;", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#cpuset\">cpuset</a> *<a class=\"id\" href=\"#c\">c</a>, *<a class=\"id\" href=\"#par\">par</a>;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/* Each of our child cpusets must be a subset of us */</span>", 
"<span class=\"ts\"/><a class=\"id\" href=\"#list_for_each_entry\">list_for_each_entry</a>(<a class=\"id\" href=\"#cont\">cont</a>, &amp;<a class=\"id\" href=\"#cur\">cur</a>-><a class=\"id\" href=\"#css\">css</a>.<a class=\"id\" href=\"#cgroup\">cgroup</a>-><a class=\"id\" href=\"#children\">children</a>, <a class=\"id\" href=\"#sibling\">sibling</a>) {", 
"<span class=\"ts\"/><span class=\"ts\"/>if (!<a class=\"id\" href=\"#is_cpuset_subset\">is_cpuset_subset</a>(<a class=\"id\" href=\"#cgroup_cs\">cgroup_cs</a>(<a class=\"id\" href=\"#cont\">cont</a>), <a class=\"id\" href=\"#trial\">trial</a>))", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>return -<a class=\"id\" href=\"#EBUSY\">EBUSY</a>;", 
"<span class=\"ts\"/>}", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/* Remaining checks don't apply to root cpuset */</span>", 
"<span class=\"ts\"/>if (<a class=\"id\" href=\"#cur\">cur</a> == &amp;<a class=\"id\" href=\"#top_cpuset\">top_cpuset</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/>return 0;", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#par\">par</a> = <a class=\"id\" href=\"#cur\">cur</a>-><a class=\"id\" href=\"#parent\">parent</a>;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/* We must be a subset of our parent cpuset */</span>", 
"<span class=\"ts\"/>if (!<a class=\"id\" href=\"#is_cpuset_subset\">is_cpuset_subset</a>(<a class=\"id\" href=\"#trial\">trial</a>, <a class=\"id\" href=\"#par\">par</a>))", 
"<span class=\"ts\"/><span class=\"ts\"/>return -<a class=\"id\" href=\"#EACCES\">EACCES</a>;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * If either I or some sibling (!= me) is exclusive, we can't</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * overlap</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/><a class=\"id\" href=\"#list_for_each_entry\">list_for_each_entry</a>(<a class=\"id\" href=\"#cont\">cont</a>, &amp;<a class=\"id\" href=\"#par\">par</a>-><a class=\"id\" href=\"#css\">css</a>.<a class=\"id\" href=\"#cgroup\">cgroup</a>-><a class=\"id\" href=\"#children\">children</a>, <a class=\"id\" href=\"#sibling\">sibling</a>) {", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#c\">c</a> = <a class=\"id\" href=\"#cgroup_cs\">cgroup_cs</a>(<a class=\"id\" href=\"#cont\">cont</a>);", 
"<span class=\"ts\"/><span class=\"ts\"/>if ((<a class=\"id\" href=\"#is_cpu_exclusive\">is_cpu_exclusive</a>(<a class=\"id\" href=\"#trial\">trial</a>) || <a class=\"id\" href=\"#is_cpu_exclusive\">is_cpu_exclusive</a>(<a class=\"id\" href=\"#c\">c</a>)) &&", 
"<span class=\"ts\"/><span class=\"ts\"/>    <a class=\"id\" href=\"#c\">c</a> != <a class=\"id\" href=\"#cur\">cur</a> &&", 
"<span class=\"ts\"/><span class=\"ts\"/>    <a class=\"id\" href=\"#cpumask_intersects\">cpumask_intersects</a>(<a class=\"id\" href=\"#trial\">trial</a>-><a class=\"id\" href=\"#cpus_allowed\">cpus_allowed</a>, <a class=\"id\" href=\"#c\">c</a>-><a class=\"id\" href=\"#cpus_allowed\">cpus_allowed</a>))", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>return -<a class=\"id\" href=\"#EINVAL\">EINVAL</a>;", 
"<span class=\"ts\"/><span class=\"ts\"/>if ((<a class=\"id\" href=\"#is_mem_exclusive\">is_mem_exclusive</a>(<a class=\"id\" href=\"#trial\">trial</a>) || <a class=\"id\" href=\"#is_mem_exclusive\">is_mem_exclusive</a>(<a class=\"id\" href=\"#c\">c</a>)) &&", 
"<span class=\"ts\"/><span class=\"ts\"/>    <a class=\"id\" href=\"#c\">c</a> != <a class=\"id\" href=\"#cur\">cur</a> &&", 
"<span class=\"ts\"/><span class=\"ts\"/>    <a class=\"id\" href=\"#nodes_intersects\">nodes_intersects</a>(<a class=\"id\" href=\"#trial\">trial</a>-><a class=\"id\" href=\"#mems_allowed\">mems_allowed</a>, <a class=\"id\" href=\"#c\">c</a>-><a class=\"id\" href=\"#mems_allowed\">mems_allowed</a>))", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>return -<a class=\"id\" href=\"#EINVAL\">EINVAL</a>;", 
"<span class=\"ts\"/>}", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/* Cpusets with tasks can't have empty cpus_allowed or mems_allowed */</span>", 
"<span class=\"ts\"/>if (<a class=\"id\" href=\"#cgroup_task_count\">cgroup_task_count</a>(<a class=\"id\" href=\"#cur\">cur</a>-><a class=\"id\" href=\"#css\">css</a>.<a class=\"id\" href=\"#cgroup\">cgroup</a>)) {", 
"<span class=\"ts\"/><span class=\"ts\"/>if (<a class=\"id\" href=\"#cpumask_empty\">cpumask_empty</a>(<a class=\"id\" href=\"#trial\">trial</a>-><a class=\"id\" href=\"#cpus_allowed\">cpus_allowed</a>) ||", 
"<span class=\"ts\"/><span class=\"ts\"/>    <a class=\"id\" href=\"#nodes_empty\">nodes_empty</a>(<a class=\"id\" href=\"#trial\">trial</a>-><a class=\"id\" href=\"#mems_allowed\">mems_allowed</a>)) {", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>return -<a class=\"id\" href=\"#ENOSPC\">ENOSPC</a>;", 
"<span class=\"ts\"/><span class=\"ts\"/>}", 
"<span class=\"ts\"/>}", 
"", 
"<span class=\"ts\"/>return 0;", 
"}", 
"", 
"#<a class=\"id\" href=\"#ifdef\">ifdef</a> <a class=\"id\" href=\"#CONFIG_SMP\">CONFIG_SMP</a>", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * Helper routine for generate_sched_domains().</span>", 
"<span class=\"comment\"> * Do cpusets a, b have overlapping cpus_allowed masks?</span>", 
"<span class=\"comment\"> */</span>", 
"static int <a class=\"id\" href=\"#cpusets_overlap\">cpusets_overlap</a>(struct <a class=\"id\" href=\"#cpuset\">cpuset</a> *<a class=\"id\" href=\"#a\">a</a>, struct <a class=\"id\" href=\"#cpuset\">cpuset</a> *<a class=\"id\" href=\"#b\">b</a>)", 
"{", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#cpumask_intersects\">cpumask_intersects</a>(<a class=\"id\" href=\"#a\">a</a>-><a class=\"id\" href=\"#cpus_allowed\">cpus_allowed</a>, <a class=\"id\" href=\"#b\">b</a>-><a class=\"id\" href=\"#cpus_allowed\">cpus_allowed</a>);", 
"}", 
"", 
"static void", 
"<a class=\"id\" href=\"#update_domain_attr\">update_domain_attr</a>(struct <a class=\"id\" href=\"#sched_domain_attr\">sched_domain_attr</a> *<a class=\"id\" href=\"#dattr\">dattr</a>, struct <a class=\"id\" href=\"#cpuset\">cpuset</a> *<a class=\"id\" href=\"#c\">c</a>)", 
"{", 
"<span class=\"ts\"/>if (<a class=\"id\" href=\"#dattr\">dattr</a>-><a class=\"id\" href=\"#relax_domain_level\">relax_domain_level</a> &lt; <a class=\"id\" href=\"#c\">c</a>-><a class=\"id\" href=\"#relax_domain_level\">relax_domain_level</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#dattr\">dattr</a>-><a class=\"id\" href=\"#relax_domain_level\">relax_domain_level</a> = <a class=\"id\" href=\"#c\">c</a>-><a class=\"id\" href=\"#relax_domain_level\">relax_domain_level</a>;", 
"<span class=\"ts\"/>return;", 
"}", 
"", 
"static void", 
"<a class=\"id\" href=\"#update_domain_attr_tree\">update_domain_attr_tree</a>(struct <a class=\"id\" href=\"#sched_domain_attr\">sched_domain_attr</a> *<a class=\"id\" href=\"#dattr\">dattr</a>, struct <a class=\"id\" href=\"#cpuset\">cpuset</a> *<a class=\"id\" href=\"#c\">c</a>)", 
"{", 
"<span class=\"ts\"/><a class=\"id\" href=\"#LIST_HEAD\">LIST_HEAD</a>(<a class=\"id\" href=\"#q\">q</a>);", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#list_add\">list_add</a>(&amp;<a class=\"id\" href=\"#c\">c</a>-><a class=\"id\" href=\"#stack_list\">stack_list</a>, &amp;<a class=\"id\" href=\"#q\">q</a>);", 
"<span class=\"ts\"/>while (!<a class=\"id\" href=\"#list_empty\">list_empty</a>(&amp;<a class=\"id\" href=\"#q\">q</a>)) {", 
"<span class=\"ts\"/><span class=\"ts\"/>struct <a class=\"id\" href=\"#cpuset\">cpuset</a> *<a class=\"id\" href=\"#cp\">cp</a>;", 
"<span class=\"ts\"/><span class=\"ts\"/>struct <a class=\"id\" href=\"#cgroup\">cgroup</a> *<a class=\"id\" href=\"#cont\">cont</a>;", 
"<span class=\"ts\"/><span class=\"ts\"/>struct <a class=\"id\" href=\"#cpuset\">cpuset</a> *<a class=\"id\" href=\"#child\">child</a>;", 
"", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#cp\">cp</a> = <a class=\"id\" href=\"#list_first_entry\">list_first_entry</a>(&amp;<a class=\"id\" href=\"#q\">q</a>, struct <a class=\"id\" href=\"#cpuset\">cpuset</a>, <a class=\"id\" href=\"#stack_list\">stack_list</a>);", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#list_del\">list_del</a>(<a class=\"id\" href=\"#q\">q</a>.<a class=\"id\" href=\"#next\">next</a>);", 
"", 
"<span class=\"ts\"/><span class=\"ts\"/>if (<a class=\"id\" href=\"#cpumask_empty\">cpumask_empty</a>(<a class=\"id\" href=\"#cp\">cp</a>-><a class=\"id\" href=\"#cpus_allowed\">cpus_allowed</a>))", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>continue;", 
"", 
"<span class=\"ts\"/><span class=\"ts\"/>if (<a class=\"id\" href=\"#is_sched_load_balance\">is_sched_load_balance</a>(<a class=\"id\" href=\"#cp\">cp</a>))", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#update_domain_attr\">update_domain_attr</a>(<a class=\"id\" href=\"#dattr\">dattr</a>, <a class=\"id\" href=\"#cp\">cp</a>);", 
"", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#list_for_each_entry\">list_for_each_entry</a>(<a class=\"id\" href=\"#cont\">cont</a>, &amp;<a class=\"id\" href=\"#cp\">cp</a>-><a class=\"id\" href=\"#css\">css</a>.<a class=\"id\" href=\"#cgroup\">cgroup</a>-><a class=\"id\" href=\"#children\">children</a>, <a class=\"id\" href=\"#sibling\">sibling</a>) {", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#child\">child</a> = <a class=\"id\" href=\"#cgroup_cs\">cgroup_cs</a>(<a class=\"id\" href=\"#cont\">cont</a>);", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#list_add_tail\">list_add_tail</a>(&amp;<a class=\"id\" href=\"#child\">child</a>-><a class=\"id\" href=\"#stack_list\">stack_list</a>, &amp;<a class=\"id\" href=\"#q\">q</a>);", 
"<span class=\"ts\"/><span class=\"ts\"/>}", 
"<span class=\"ts\"/>}", 
"}", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * generate_sched_domains()</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * This function builds a partial partition of the systems CPUs</span>", 
"<span class=\"comment\"> * A 'partial partition' is a set of non-overlapping subsets whose</span>", 
"<span class=\"comment\"> * union is a subset of that set.</span>", 
"<span class=\"comment\"> * The output of this function needs to be passed to kernel/sched.c</span>", 
"<span class=\"comment\"> * partition_sched_domains() routine, which will rebuild the scheduler's</span>", 
"<span class=\"comment\"> * load balancing domains (sched domains) as specified by that partial</span>", 
"<span class=\"comment\"> * partition.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * See \"What is sched_load_balance\" in Documentation/cgroups/cpusets.txt</span>", 
"<span class=\"comment\"> * for a background explanation of this.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Does not return errors, on the theory that the callers of this</span>", 
"<span class=\"comment\"> * routine would rather not worry about failures to rebuild sched</span>", 
"<span class=\"comment\"> * domains when operating in the severe memory shortage situations</span>", 
"<span class=\"comment\"> * that could cause allocation failures below.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Must be called with cgroup_lock held.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * The three key local variables below are:</span>", 
"<span class=\"comment\"> *    q  - a linked-list queue of cpuset pointers, used to implement a</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>   top-down scan of all cpusets.  This scan loads a pointer</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>   to each cpuset marked is_sched_load_balance into the</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>   array 'csa'.  For our purposes, rebuilding the schedulers</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>   sched domains, we can ignore !is_sched_load_balance cpusets.</span>", 
"<span class=\"comment\"> *  csa  - (for CpuSet Array) Array of pointers to all the cpusets</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>   that need to be load balanced, for convenient iterative</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>   access by the subsequent code that finds the best partition,</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>   i.e the set of domains (subsets) of CPUs such that the</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>   cpus_allowed of every cpuset marked is_sched_load_balance</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>   is a subset of one of these domains, while there are as</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>   many such domains as possible, each as small as possible.</span>", 
"<span class=\"comment\"> * doms  - Conversion of 'csa' to an array of cpumasks, for passing to</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>   the kernel/sched.c routine partition_sched_domains() in a</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>   convenient format, that can be easily compared to the prior</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>   value to determine what partition elements (sched domains)</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>   were changed (added or removed.)</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Finding the best partition (set of domains):</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>The triple nested loops below over i, j, k scan over the</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>load balanced cpusets (using the array of cpuset pointers in</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>csa[]) looking for pairs of cpusets that have overlapping</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>cpus_allowed, but which don't have the same 'pn' partition</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>number and gives them in the same partition number.  It keeps</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>looping on the 'restart' label until it can no longer find</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>any such pairs.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>The union of the cpus_allowed masks from the set of</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>all cpusets having the same 'pn' value then form the one</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>element of the partition (one sched domain) to be passed to</span>", 
"<span class=\"comment\"> *<span class=\"ts\"/>partition_sched_domains().</span>", 
"<span class=\"comment\"> */</span>", 
"static int <a class=\"id\" href=\"#generate_sched_domains\">generate_sched_domains</a>(<a class=\"id\" href=\"#cpumask_var_t\">cpumask_var_t</a> **<a class=\"id\" href=\"#domains\">domains</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>struct <a class=\"id\" href=\"#sched_domain_attr\">sched_domain_attr</a> **<a class=\"id\" href=\"#attributes\">attributes</a>)", 
"{", 
"<span class=\"ts\"/><a class=\"id\" href=\"#LIST_HEAD\">LIST_HEAD</a>(<a class=\"id\" href=\"#q\">q</a>);<span class=\"ts\"/><span class=\"ts\"/><span class=\"comment\">/* queue of cpusets to be scanned */</span>", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#cpuset\">cpuset</a> *<a class=\"id\" href=\"#cp\">cp</a>;<span class=\"ts\"/><span class=\"comment\">/* scans q */</span>", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#cpuset\">cpuset</a> **<a class=\"id\" href=\"#csa\">csa</a>;<span class=\"ts\"/><span class=\"comment\">/* array of all cpuset ptrs */</span>", 
"<span class=\"ts\"/>int <a class=\"id\" href=\"#csn\">csn</a>;<span class=\"ts\"/><span class=\"ts\"/><span class=\"comment\">/* how many cpuset ptrs in csa so far */</span>", 
"<span class=\"ts\"/>int <a class=\"id\" href=\"#i\">i</a>, <a class=\"id\" href=\"#j\">j</a>, <a class=\"id\" href=\"#k\">k</a>;<span class=\"ts\"/><span class=\"ts\"/><span class=\"comment\">/* indices for partition finding loops */</span>", 
"<span class=\"ts\"/><a class=\"id\" href=\"#cpumask_var_t\">cpumask_var_t</a> *<a class=\"id\" href=\"#doms\">doms</a>;<span class=\"ts\"/><span class=\"comment\">/* resulting partition; i.e. sched domains */</span>", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#sched_domain_attr\">sched_domain_attr</a> *<a class=\"id\" href=\"#dattr\">dattr</a>;  <span class=\"comment\">/* attributes for custom domains */</span>", 
"<span class=\"ts\"/>int <a class=\"id\" href=\"#ndoms\">ndoms</a> = 0;<span class=\"ts\"/><span class=\"ts\"/><span class=\"comment\">/* number of sched domains in result */</span>", 
"<span class=\"ts\"/>int <a class=\"id\" href=\"#nslot\">nslot</a>;<span class=\"ts\"/><span class=\"ts\"/><span class=\"comment\">/* next empty doms[] struct cpumask slot */</span>", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#doms\">doms</a> = <a class=\"id\" href=\"#NULL\">NULL</a>;", 
"<span class=\"ts\"/><a class=\"id\" href=\"#dattr\">dattr</a> = <a class=\"id\" href=\"#NULL\">NULL</a>;", 
"<span class=\"ts\"/><a class=\"id\" href=\"#csa\">csa</a> = <a class=\"id\" href=\"#NULL\">NULL</a>;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/* Special case for the 99% of systems with one, full, sched domain */</span>", 
"<span class=\"ts\"/>if (<a class=\"id\" href=\"#is_sched_load_balance\">is_sched_load_balance</a>(&amp;<a class=\"id\" href=\"#top_cpuset\">top_cpuset</a>)) {", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#ndoms\">ndoms</a> = 1;", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#doms\">doms</a> = <a class=\"id\" href=\"#alloc_sched_domains\">alloc_sched_domains</a>(<a class=\"id\" href=\"#ndoms\">ndoms</a>);", 
"<span class=\"ts\"/><span class=\"ts\"/>if (!<a class=\"id\" href=\"#doms\">doms</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>goto <a class=\"id\" href=\"#done\">done</a>;", 
"", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#dattr\">dattr</a> = <a class=\"id\" href=\"#kmalloc\">kmalloc</a>(sizeof(struct <a class=\"id\" href=\"#sched_domain_attr\">sched_domain_attr</a>), <a class=\"id\" href=\"#GFP_KERNEL\">GFP_KERNEL</a>);", 
"<span class=\"ts\"/><span class=\"ts\"/>if (<a class=\"id\" href=\"#dattr\">dattr</a>) {", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>*<a class=\"id\" href=\"#dattr\">dattr</a> = <a class=\"id\" href=\"#SD_ATTR_INIT\">SD_ATTR_INIT</a>;", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#update_domain_attr_tree\">update_domain_attr_tree</a>(<a class=\"id\" href=\"#dattr\">dattr</a>, &amp;<a class=\"id\" href=\"#top_cpuset\">top_cpuset</a>);", 
"<span class=\"ts\"/><span class=\"ts\"/>}", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#cpumask_copy\">cpumask_copy</a>(<a class=\"id\" href=\"#doms\">doms</a>[0], <a class=\"id\" href=\"#top_cpuset\">top_cpuset</a>.<a class=\"id\" href=\"#cpus_allowed\">cpus_allowed</a>);", 
"", 
"<span class=\"ts\"/><span class=\"ts\"/>goto <a class=\"id\" href=\"#done\">done</a>;", 
"<span class=\"ts\"/>}", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#csa\">csa</a> = <a class=\"id\" href=\"#kmalloc\">kmalloc</a>(<a class=\"id\" href=\"#number_of_cpusets\">number_of_cpusets</a> * sizeof(<a class=\"id\" href=\"#cp\">cp</a>), <a class=\"id\" href=\"#GFP_KERNEL\">GFP_KERNEL</a>);", 
"<span class=\"ts\"/>if (!<a class=\"id\" href=\"#csa\">csa</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/>goto <a class=\"id\" href=\"#done\">done</a>;", 
"<span class=\"ts\"/><a class=\"id\" href=\"#csn\">csn</a> = 0;", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#list_add\">list_add</a>(&amp;<a class=\"id\" href=\"#top_cpuset\">top_cpuset</a>.<a class=\"id\" href=\"#stack_list\">stack_list</a>, &amp;<a class=\"id\" href=\"#q\">q</a>);", 
"<span class=\"ts\"/>while (!<a class=\"id\" href=\"#list_empty\">list_empty</a>(&amp;<a class=\"id\" href=\"#q\">q</a>)) {", 
"<span class=\"ts\"/><span class=\"ts\"/>struct <a class=\"id\" href=\"#cgroup\">cgroup</a> *<a class=\"id\" href=\"#cont\">cont</a>;", 
"<span class=\"ts\"/><span class=\"ts\"/>struct <a class=\"id\" href=\"#cpuset\">cpuset</a> *<a class=\"id\" href=\"#child\">child</a>;   <span class=\"comment\">/* scans child cpusets of cp */</span>", 
"", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#cp\">cp</a> = <a class=\"id\" href=\"#list_first_entry\">list_first_entry</a>(&amp;<a class=\"id\" href=\"#q\">q</a>, struct <a class=\"id\" href=\"#cpuset\">cpuset</a>, <a class=\"id\" href=\"#stack_list\">stack_list</a>);", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#list_del\">list_del</a>(<a class=\"id\" href=\"#q\">q</a>.<a class=\"id\" href=\"#next\">next</a>);", 
"", 
"<span class=\"ts\"/><span class=\"ts\"/>if (<a class=\"id\" href=\"#cpumask_empty\">cpumask_empty</a>(<a class=\"id\" href=\"#cp\">cp</a>-><a class=\"id\" href=\"#cpus_allowed\">cpus_allowed</a>))", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>continue;", 
"", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/><span class=\"ts\"/> * All child cpusets contain a subset of the parent's cpus, so</span>", 
"<span class=\"comment\"><span class=\"ts\"/><span class=\"ts\"/> * just skip them, and then we call update_domain_attr_tree()</span>", 
"<span class=\"comment\"><span class=\"ts\"/><span class=\"ts\"/> * to calc relax_domain_level of the corresponding sched</span>", 
"<span class=\"comment\"><span class=\"ts\"/><span class=\"ts\"/> * domain.</span>", 
"<span class=\"comment\"><span class=\"ts\"/><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/><span class=\"ts\"/>if (<a class=\"id\" href=\"#is_sched_load_balance\">is_sched_load_balance</a>(<a class=\"id\" href=\"#cp\">cp</a>)) {", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#csa\">csa</a>[<a class=\"id\" href=\"#csn\">csn</a>++] = <a class=\"id\" href=\"#cp\">cp</a>;", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>continue;", 
"<span class=\"ts\"/><span class=\"ts\"/>}", 
"", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#list_for_each_entry\">list_for_each_entry</a>(<a class=\"id\" href=\"#cont\">cont</a>, &amp;<a class=\"id\" href=\"#cp\">cp</a>-><a class=\"id\" href=\"#css\">css</a>.<a class=\"id\" href=\"#cgroup\">cgroup</a>-><a class=\"id\" href=\"#children\">children</a>, <a class=\"id\" href=\"#sibling\">sibling</a>) {", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#child\">child</a> = <a class=\"id\" href=\"#cgroup_cs\">cgroup_cs</a>(<a class=\"id\" href=\"#cont\">cont</a>);", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#list_add_tail\">list_add_tail</a>(&amp;<a class=\"id\" href=\"#child\">child</a>-><a class=\"id\" href=\"#stack_list\">stack_list</a>, &amp;<a class=\"id\" href=\"#q\">q</a>);", 
"<span class=\"ts\"/><span class=\"ts\"/>}", 
"  <span class=\"ts\"/>}", 
"", 
"<span class=\"ts\"/>for (<a class=\"id\" href=\"#i\">i</a> = 0; <a class=\"id\" href=\"#i\">i</a> &lt; <a class=\"id\" href=\"#csn\">csn</a>; <a class=\"id\" href=\"#i\">i</a>++)", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#csa\">csa</a>[<a class=\"id\" href=\"#i\">i</a>]-><a class=\"id\" href=\"#pn\">pn</a> = <a class=\"id\" href=\"#i\">i</a>;", 
"<span class=\"ts\"/><a class=\"id\" href=\"#ndoms\">ndoms</a> = <a class=\"id\" href=\"#csn\">csn</a>;", 
"", 
"<a class=\"id\" href=\"#restart\">restart</a>:", 
"<span class=\"ts\"/><span class=\"comment\">/* Find the best partition (set of sched domains) */</span>", 
"<span class=\"ts\"/>for (<a class=\"id\" href=\"#i\">i</a> = 0; <a class=\"id\" href=\"#i\">i</a> &lt; <a class=\"id\" href=\"#csn\">csn</a>; <a class=\"id\" href=\"#i\">i</a>++) {", 
"<span class=\"ts\"/><span class=\"ts\"/>struct <a class=\"id\" href=\"#cpuset\">cpuset</a> *<a class=\"id\" href=\"#a\">a</a> = <a class=\"id\" href=\"#csa\">csa</a>[<a class=\"id\" href=\"#i\">i</a>];", 
"<span class=\"ts\"/><span class=\"ts\"/>int <a class=\"id\" href=\"#apn\">apn</a> = <a class=\"id\" href=\"#a\">a</a>-><a class=\"id\" href=\"#pn\">pn</a>;", 
"", 
"<span class=\"ts\"/><span class=\"ts\"/>for (<a class=\"id\" href=\"#j\">j</a> = 0; <a class=\"id\" href=\"#j\">j</a> &lt; <a class=\"id\" href=\"#csn\">csn</a>; <a class=\"id\" href=\"#j\">j</a>++) {", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>struct <a class=\"id\" href=\"#cpuset\">cpuset</a> *<a class=\"id\" href=\"#b\">b</a> = <a class=\"id\" href=\"#csa\">csa</a>[<a class=\"id\" href=\"#j\">j</a>];", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>int <a class=\"id\" href=\"#bpn\">bpn</a> = <a class=\"id\" href=\"#b\">b</a>-><a class=\"id\" href=\"#pn\">pn</a>;", 
"", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>if (<a class=\"id\" href=\"#apn\">apn</a> != <a class=\"id\" href=\"#bpn\">bpn</a> && <a class=\"id\" href=\"#cpusets_overlap\">cpusets_overlap</a>(<a class=\"id\" href=\"#a\">a</a>, <a class=\"id\" href=\"#b\">b</a>)) {", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>for (<a class=\"id\" href=\"#k\">k</a> = 0; <a class=\"id\" href=\"#k\">k</a> &lt; <a class=\"id\" href=\"#csn\">csn</a>; <a class=\"id\" href=\"#k\">k</a>++) {", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>struct <a class=\"id\" href=\"#cpuset\">cpuset</a> *<a class=\"id\" href=\"#c\">c</a> = <a class=\"id\" href=\"#csa\">csa</a>[<a class=\"id\" href=\"#k\">k</a>];", 
"", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>if (<a class=\"id\" href=\"#c\">c</a>-><a class=\"id\" href=\"#pn\">pn</a> == <a class=\"id\" href=\"#bpn\">bpn</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#c\">c</a>-><a class=\"id\" href=\"#pn\">pn</a> = <a class=\"id\" href=\"#apn\">apn</a>;", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>}", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#ndoms\">ndoms</a>--;<span class=\"ts\"/><span class=\"comment\">/* one less element */</span>", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>goto <a class=\"id\" href=\"#restart\">restart</a>;", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>}", 
"<span class=\"ts\"/><span class=\"ts\"/>}", 
"<span class=\"ts\"/>}", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Now we know how many domains to create.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Convert &lt;csn, csa&gt; to &lt;ndoms, doms&gt; and populate cpu masks.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/><a class=\"id\" href=\"#doms\">doms</a> = <a class=\"id\" href=\"#alloc_sched_domains\">alloc_sched_domains</a>(<a class=\"id\" href=\"#ndoms\">ndoms</a>);", 
"<span class=\"ts\"/>if (!<a class=\"id\" href=\"#doms\">doms</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/>goto <a class=\"id\" href=\"#done\">done</a>;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * The rest of the code, including the scheduler, can deal with</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * dattr==NULL case. No need to abort if alloc fails.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/><a class=\"id\" href=\"#dattr\">dattr</a> = <a class=\"id\" href=\"#kmalloc\">kmalloc</a>(<a class=\"id\" href=\"#ndoms\">ndoms</a> * sizeof(struct <a class=\"id\" href=\"#sched_domain_attr\">sched_domain_attr</a>), <a class=\"id\" href=\"#GFP_KERNEL\">GFP_KERNEL</a>);", 
"", 
"<span class=\"ts\"/>for (<a class=\"id\" href=\"#nslot\">nslot</a> = 0, <a class=\"id\" href=\"#i\">i</a> = 0; <a class=\"id\" href=\"#i\">i</a> &lt; <a class=\"id\" href=\"#csn\">csn</a>; <a class=\"id\" href=\"#i\">i</a>++) {", 
"<span class=\"ts\"/><span class=\"ts\"/>struct <a class=\"id\" href=\"#cpuset\">cpuset</a> *<a class=\"id\" href=\"#a\">a</a> = <a class=\"id\" href=\"#csa\">csa</a>[<a class=\"id\" href=\"#i\">i</a>];", 
"<span class=\"ts\"/><span class=\"ts\"/>struct <a class=\"id\" href=\"#cpumask\">cpumask</a> *<a class=\"id\" href=\"#dp\">dp</a>;", 
"<span class=\"ts\"/><span class=\"ts\"/>int <a class=\"id\" href=\"#apn\">apn</a> = <a class=\"id\" href=\"#a\">a</a>-><a class=\"id\" href=\"#pn\">pn</a>;", 
"", 
"<span class=\"ts\"/><span class=\"ts\"/>if (<a class=\"id\" href=\"#apn\">apn</a> &lt; 0) {", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"comment\">/* Skip completed partitions */</span>", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>continue;", 
"<span class=\"ts\"/><span class=\"ts\"/>}", 
"", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#dp\">dp</a> = <a class=\"id\" href=\"#doms\">doms</a>[<a class=\"id\" href=\"#nslot\">nslot</a>];", 
"", 
"<span class=\"ts\"/><span class=\"ts\"/>if (<a class=\"id\" href=\"#nslot\">nslot</a> == <a class=\"id\" href=\"#ndoms\">ndoms</a>) {", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>static int <a class=\"id\" href=\"#warnings\">warnings</a> = 10;", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>if (<a class=\"id\" href=\"#warnings\">warnings</a>) {", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#printk\">printk</a>(<a class=\"id\" href=\"#KERN_WARNING\">KERN_WARNING</a>", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/> \"rebuild_sched_domains confused:\"", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>  \" nslot %d, ndoms %d, csn %d, i %d,\"", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>  \" apn %d\\n\",", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>  <a class=\"id\" href=\"#nslot\">nslot</a>, <a class=\"id\" href=\"#ndoms\">ndoms</a>, <a class=\"id\" href=\"#csn\">csn</a>, <a class=\"id\" href=\"#i\">i</a>, <a class=\"id\" href=\"#apn\">apn</a>);", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#warnings\">warnings</a>--;", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>}", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>continue;", 
"<span class=\"ts\"/><span class=\"ts\"/>}", 
"", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#cpumask_clear\">cpumask_clear</a>(<a class=\"id\" href=\"#dp\">dp</a>);", 
"<span class=\"ts\"/><span class=\"ts\"/>if (<a class=\"id\" href=\"#dattr\">dattr</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>*(<a class=\"id\" href=\"#dattr\">dattr</a> + <a class=\"id\" href=\"#nslot\">nslot</a>) = <a class=\"id\" href=\"#SD_ATTR_INIT\">SD_ATTR_INIT</a>;", 
"<span class=\"ts\"/><span class=\"ts\"/>for (<a class=\"id\" href=\"#j\">j</a> = <a class=\"id\" href=\"#i\">i</a>; <a class=\"id\" href=\"#j\">j</a> &lt; <a class=\"id\" href=\"#csn\">csn</a>; <a class=\"id\" href=\"#j\">j</a>++) {", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>struct <a class=\"id\" href=\"#cpuset\">cpuset</a> *<a class=\"id\" href=\"#b\">b</a> = <a class=\"id\" href=\"#csa\">csa</a>[<a class=\"id\" href=\"#j\">j</a>];", 
"", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>if (<a class=\"id\" href=\"#apn\">apn</a> == <a class=\"id\" href=\"#b\">b</a>-><a class=\"id\" href=\"#pn\">pn</a>) {", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#cpumask_or\">cpumask_or</a>(<a class=\"id\" href=\"#dp\">dp</a>, <a class=\"id\" href=\"#dp\">dp</a>, <a class=\"id\" href=\"#b\">b</a>-><a class=\"id\" href=\"#cpus_allowed\">cpus_allowed</a>);", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>if (<a class=\"id\" href=\"#dattr\">dattr</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#update_domain_attr_tree\">update_domain_attr_tree</a>(<a class=\"id\" href=\"#dattr\">dattr</a> + <a class=\"id\" href=\"#nslot\">nslot</a>, <a class=\"id\" href=\"#b\">b</a>);", 
"", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"comment\">/* Done with this partition */</span>", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#b\">b</a>-><a class=\"id\" href=\"#pn\">pn</a> = -1;", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>}", 
"<span class=\"ts\"/><span class=\"ts\"/>}", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#nslot\">nslot</a>++;", 
"<span class=\"ts\"/>}", 
"<span class=\"ts\"/><a class=\"id\" href=\"#BUG_ON\">BUG_ON</a>(<a class=\"id\" href=\"#nslot\">nslot</a> != <a class=\"id\" href=\"#ndoms\">ndoms</a>);", 
"", 
"<a class=\"id\" href=\"#done\">done</a>:", 
"<span class=\"ts\"/><a class=\"id\" href=\"#kfree\">kfree</a>(<a class=\"id\" href=\"#csa\">csa</a>);", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Fallback to the default domain if kmalloc() failed.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * See comments in partition_sched_domains().</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>if (<a class=\"id\" href=\"#doms\">doms</a> == <a class=\"id\" href=\"#NULL\">NULL</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#ndoms\">ndoms</a> = 1;", 
"", 
"<span class=\"ts\"/>*<a class=\"id\" href=\"#domains\">domains</a>    = <a class=\"id\" href=\"#doms\">doms</a>;", 
"<span class=\"ts\"/>*<a class=\"id\" href=\"#attributes\">attributes</a> = <a class=\"id\" href=\"#dattr\">dattr</a>;", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#ndoms\">ndoms</a>;", 
"}", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * Rebuild scheduler domains.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Call with neither cgroup_mutex held nor within get_online_cpus().</span>", 
"<span class=\"comment\"> * Takes both cgroup_mutex and get_online_cpus().</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Cannot be directly called from cpuset code handling changes</span>", 
"<span class=\"comment\"> * to the cpuset pseudo-filesystem, because it cannot be called</span>", 
"<span class=\"comment\"> * from code that already holds cgroup_mutex.</span>", 
"<span class=\"comment\"> */</span>", 
"static void <a class=\"id\" href=\"#do_rebuild_sched_domains\">do_rebuild_sched_domains</a>(struct <a class=\"id\" href=\"#work_struct\">work_struct</a> *<a class=\"id\" href=\"#unused\">unused</a>)", 
"{", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#sched_domain_attr\">sched_domain_attr</a> *<a class=\"id\" href=\"#attr\">attr</a>;", 
"<span class=\"ts\"/><a class=\"id\" href=\"#cpumask_var_t\">cpumask_var_t</a> *<a class=\"id\" href=\"#doms\">doms</a>;", 
"<span class=\"ts\"/>int <a class=\"id\" href=\"#ndoms\">ndoms</a>;", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#get_online_cpus\">get_online_cpus</a>();", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/* Generate domain masks and attrs */</span>", 
"<span class=\"ts\"/><a class=\"id\" href=\"#cgroup_lock\">cgroup_lock</a>();", 
"<span class=\"ts\"/><a class=\"id\" href=\"#ndoms\">ndoms</a> = <a class=\"id\" href=\"#generate_sched_domains\">generate_sched_domains</a>(&amp;<a class=\"id\" href=\"#doms\">doms</a>, &amp;<a class=\"id\" href=\"#attr\">attr</a>);", 
"<span class=\"ts\"/><a class=\"id\" href=\"#cgroup_unlock\">cgroup_unlock</a>();", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/* Have scheduler rebuild the domains */</span>", 
"<span class=\"ts\"/><a class=\"id\" href=\"#partition_sched_domains\">partition_sched_domains</a>(<a class=\"id\" href=\"#ndoms\">ndoms</a>, <a class=\"id\" href=\"#doms\">doms</a>, <a class=\"id\" href=\"#attr\">attr</a>);", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#put_online_cpus\">put_online_cpus</a>();", 
"}", 
"#else <span class=\"comment\">/* !CONFIG_SMP */</span>", 
"static void <a class=\"id\" href=\"#do_rebuild_sched_domains\">do_rebuild_sched_domains</a>(struct <a class=\"id\" href=\"#work_struct\">work_struct</a> *<a class=\"id\" href=\"#unused\">unused</a>)", 
"{", 
"}", 
"", 
"static int <a class=\"id\" href=\"#generate_sched_domains\">generate_sched_domains</a>(<a class=\"id\" href=\"#cpumask_var_t\">cpumask_var_t</a> **<a class=\"id\" href=\"#domains\">domains</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>struct <a class=\"id\" href=\"#sched_domain_attr\">sched_domain_attr</a> **<a class=\"id\" href=\"#attributes\">attributes</a>)", 
"{", 
"<span class=\"ts\"/>*<a class=\"id\" href=\"#domains\">domains</a> = <a class=\"id\" href=\"#NULL\">NULL</a>;", 
"<span class=\"ts\"/>return 1;", 
"}", 
"#<a class=\"id\" href=\"#endif\">endif</a> <span class=\"comment\">/* CONFIG_SMP */</span>", 
"", 
"static <a class=\"id\" href=\"#DECLARE_WORK\">DECLARE_WORK</a>(<a class=\"id\" href=\"#rebuild_sched_domains_work\">rebuild_sched_domains_work</a>, <a class=\"id\" href=\"#do_rebuild_sched_domains\">do_rebuild_sched_domains</a>);", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * Rebuild scheduler domains, asynchronously via workqueue.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * If the flag 'sched_load_balance' of any cpuset with non-empty</span>", 
"<span class=\"comment\"> * 'cpus' changes, or if the 'cpus' allowed changes in any cpuset</span>", 
"<span class=\"comment\"> * which has that flag enabled, or if any cpuset with a non-empty</span>", 
"<span class=\"comment\"> * 'cpus' is removed, then call this routine to rebuild the</span>", 
"<span class=\"comment\"> * scheduler's dynamic sched domains.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * The rebuild_sched_domains() and partition_sched_domains()</span>", 
"<span class=\"comment\"> * routines must nest cgroup_lock() inside get_online_cpus(),</span>", 
"<span class=\"comment\"> * but such cpuset changes as these must nest that locking the</span>", 
"<span class=\"comment\"> * other way, holding cgroup_lock() for much of the code.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * So in order to avoid an ABBA deadlock, the cpuset code handling</span>", 
"<span class=\"comment\"> * these user changes delegates the actual sched domain rebuilding</span>", 
"<span class=\"comment\"> * to a separate workqueue thread, which ends up processing the</span>", 
"<span class=\"comment\"> * above do_rebuild_sched_domains() function.</span>", 
"<span class=\"comment\"> */</span>", 
"static void <a class=\"id\" href=\"#async_rebuild_sched_domains\">async_rebuild_sched_domains</a>(void)", 
"{", 
"<span class=\"ts\"/><a class=\"id\" href=\"#queue_work\">queue_work</a>(<a class=\"id\" href=\"#cpuset_wq\">cpuset_wq</a>, &amp;<a class=\"id\" href=\"#rebuild_sched_domains_work\">rebuild_sched_domains_work</a>);", 
"}", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * Accomplishes the same scheduler domain rebuild as the above</span>", 
"<span class=\"comment\"> * async_rebuild_sched_domains(), however it directly calls the</span>", 
"<span class=\"comment\"> * rebuild routine synchronously rather than calling it via an</span>", 
"<span class=\"comment\"> * asynchronous work thread.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * This can only be called from code that is not holding</span>", 
"<span class=\"comment\"> * cgroup_mutex (not nested in a cgroup_lock() call.)</span>", 
"<span class=\"comment\"> */</span>", 
"void <a class=\"id\" href=\"#rebuild_sched_domains\">rebuild_sched_domains</a>(void)", 
"{", 
"<span class=\"ts\"/><a class=\"id\" href=\"#do_rebuild_sched_domains\">do_rebuild_sched_domains</a>(<a class=\"id\" href=\"#NULL\">NULL</a>);", 
"}", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * cpuset_test_cpumask - test a task's cpus_allowed versus its cpuset's</span>", 
"<span class=\"comment\"> * @tsk: task to test</span>", 
"<span class=\"comment\"> * @scan: struct cgroup_scanner contained in its struct cpuset_hotplug_scanner</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Call with cgroup_mutex held.  May take callback_mutex during call.</span>", 
"<span class=\"comment\"> * Called for each task in a cgroup by cgroup_scan_tasks().</span>", 
"<span class=\"comment\"> * Return nonzero if this tasks's cpus_allowed mask should be changed (in other</span>", 
"<span class=\"comment\"> * words, if its mask is not equal to its cpuset's mask).</span>", 
"<span class=\"comment\"> */</span>", 
"static int <a class=\"id\" href=\"#cpuset_test_cpumask\">cpuset_test_cpumask</a>(struct <a class=\"id\" href=\"#task_struct\">task_struct</a> *<a class=\"id\" href=\"#tsk\">tsk</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>       struct <a class=\"id\" href=\"#cgroup_scanner\">cgroup_scanner</a> *<a class=\"id\" href=\"#scan\">scan</a>)", 
"{", 
"<span class=\"ts\"/>return !<a class=\"id\" href=\"#cpumask_equal\">cpumask_equal</a>(&amp;<a class=\"id\" href=\"#tsk\">tsk</a>-><a class=\"id\" href=\"#cpus_allowed\">cpus_allowed</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>(<a class=\"id\" href=\"#cgroup_cs\">cgroup_cs</a>(<a class=\"id\" href=\"#scan\">scan</a>-><a class=\"id\" href=\"#cg\">cg</a>))-><a class=\"id\" href=\"#cpus_allowed\">cpus_allowed</a>);", 
"}", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * cpuset_change_cpumask - make a task's cpus_allowed the same as its cpuset's</span>", 
"<span class=\"comment\"> * @tsk: task to test</span>", 
"<span class=\"comment\"> * @scan: struct cgroup_scanner containing the cgroup of the task</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Called by cgroup_scan_tasks() for each task in a cgroup whose</span>", 
"<span class=\"comment\"> * cpus_allowed mask needs to be changed.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * We don't need to re-check for the cgroup/cpuset membership, since we're</span>", 
"<span class=\"comment\"> * holding cgroup_lock() at this point.</span>", 
"<span class=\"comment\"> */</span>", 
"static void <a class=\"id\" href=\"#cpuset_change_cpumask\">cpuset_change_cpumask</a>(struct <a class=\"id\" href=\"#task_struct\">task_struct</a> *<a class=\"id\" href=\"#tsk\">tsk</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>  struct <a class=\"id\" href=\"#cgroup_scanner\">cgroup_scanner</a> *<a class=\"id\" href=\"#scan\">scan</a>)", 
"{", 
"<span class=\"ts\"/><a class=\"id\" href=\"#set_cpus_allowed_ptr\">set_cpus_allowed_ptr</a>(<a class=\"id\" href=\"#tsk\">tsk</a>, ((<a class=\"id\" href=\"#cgroup_cs\">cgroup_cs</a>(<a class=\"id\" href=\"#scan\">scan</a>-><a class=\"id\" href=\"#cg\">cg</a>))-><a class=\"id\" href=\"#cpus_allowed\">cpus_allowed</a>));", 
"}", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * update_tasks_cpumask - Update the cpumasks of tasks in the cpuset.</span>", 
"<span class=\"comment\"> * @cs: the cpuset in which each task's cpus_allowed mask needs to be changed</span>", 
"<span class=\"comment\"> * @heap: if NULL, defer allocating heap memory to cgroup_scan_tasks()</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Called with cgroup_mutex held</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * The cgroup_scan_tasks() function will scan all the tasks in a cgroup,</span>", 
"<span class=\"comment\"> * calling callback functions for each.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * No return value. It's guaranteed that cgroup_scan_tasks() always returns 0</span>", 
"<span class=\"comment\"> * if @heap != NULL.</span>", 
"<span class=\"comment\"> */</span>", 
"static void <a class=\"id\" href=\"#update_tasks_cpumask\">update_tasks_cpumask</a>(struct <a class=\"id\" href=\"#cpuset\">cpuset</a> *<a class=\"id\" href=\"#cs\">cs</a>, struct <a class=\"id\" href=\"#ptr_heap\">ptr_heap</a> *<a class=\"id\" href=\"#heap\">heap</a>)", 
"{", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#cgroup_scanner\">cgroup_scanner</a> <a class=\"id\" href=\"#scan\">scan</a>;", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#scan\">scan</a>.<a class=\"id\" href=\"#cg\">cg</a> = <a class=\"id\" href=\"#cs\">cs</a>-><a class=\"id\" href=\"#css\">css</a>.<a class=\"id\" href=\"#cgroup\">cgroup</a>;", 
"<span class=\"ts\"/><a class=\"id\" href=\"#scan\">scan</a>.<a class=\"id\" href=\"#test_task\">test_task</a> = <a class=\"id\" href=\"#cpuset_test_cpumask\">cpuset_test_cpumask</a>;", 
"<span class=\"ts\"/><a class=\"id\" href=\"#scan\">scan</a>.<a class=\"id\" href=\"#process_task\">process_task</a> = <a class=\"id\" href=\"#cpuset_change_cpumask\">cpuset_change_cpumask</a>;", 
"<span class=\"ts\"/><a class=\"id\" href=\"#scan\">scan</a>.<a class=\"id\" href=\"#heap\">heap</a> = <a class=\"id\" href=\"#heap\">heap</a>;", 
"<span class=\"ts\"/><a class=\"id\" href=\"#cgroup_scan_tasks\">cgroup_scan_tasks</a>(&amp;<a class=\"id\" href=\"#scan\">scan</a>);", 
"}", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * update_cpumask - update the cpus_allowed mask of a cpuset and all tasks in it</span>", 
"<span class=\"comment\"> * @cs: the cpuset to consider</span>", 
"<span class=\"comment\"> * @buf: buffer of cpu numbers written to this cpuset</span>", 
"<span class=\"comment\"> */</span>", 
"static int <a class=\"id\" href=\"#update_cpumask\">update_cpumask</a>(struct <a class=\"id\" href=\"#cpuset\">cpuset</a> *<a class=\"id\" href=\"#cs\">cs</a>, struct <a class=\"id\" href=\"#cpuset\">cpuset</a> *<a class=\"id\" href=\"#trialcs\">trialcs</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>  const char *<a class=\"id\" href=\"#buf\">buf</a>)", 
"{", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#ptr_heap\">ptr_heap</a> <a class=\"id\" href=\"#heap\">heap</a>;", 
"<span class=\"ts\"/>int <a class=\"id\" href=\"#retval\">retval</a>;", 
"<span class=\"ts\"/>int <a class=\"id\" href=\"#is_load_balanced\">is_load_balanced</a>;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/* top_cpuset.cpus_allowed tracks cpu_online_map; it's read-only */</span>", 
"<span class=\"ts\"/>if (<a class=\"id\" href=\"#cs\">cs</a> == &amp;<a class=\"id\" href=\"#top_cpuset\">top_cpuset</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/>return -<a class=\"id\" href=\"#EACCES\">EACCES</a>;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * An empty cpus_allowed is ok only if the cpuset has no tasks.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Since cpulist_parse() fails on an empty mask, we special case</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * that parsing.  The validate_change() call ensures that cpusets</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * with tasks have cpus.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>if (!*<a class=\"id\" href=\"#buf\">buf</a>) {", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#cpumask_clear\">cpumask_clear</a>(<a class=\"id\" href=\"#trialcs\">trialcs</a>-><a class=\"id\" href=\"#cpus_allowed\">cpus_allowed</a>);", 
"<span class=\"ts\"/>} else {", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#retval\">retval</a> = <a class=\"id\" href=\"#cpulist_parse\">cpulist_parse</a>(<a class=\"id\" href=\"#buf\">buf</a>, <a class=\"id\" href=\"#trialcs\">trialcs</a>-><a class=\"id\" href=\"#cpus_allowed\">cpus_allowed</a>);", 
"<span class=\"ts\"/><span class=\"ts\"/>if (<a class=\"id\" href=\"#retval\">retval</a> &lt; 0)", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>return <a class=\"id\" href=\"#retval\">retval</a>;", 
"", 
"<span class=\"ts\"/><span class=\"ts\"/>if (!<a class=\"id\" href=\"#cpumask_subset\">cpumask_subset</a>(<a class=\"id\" href=\"#trialcs\">trialcs</a>-><a class=\"id\" href=\"#cpus_allowed\">cpus_allowed</a>, <a class=\"id\" href=\"#cpu_active_mask\">cpu_active_mask</a>))", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>return -<a class=\"id\" href=\"#EINVAL\">EINVAL</a>;", 
"<span class=\"ts\"/>}", 
"<span class=\"ts\"/><a class=\"id\" href=\"#retval\">retval</a> = <a class=\"id\" href=\"#validate_change\">validate_change</a>(<a class=\"id\" href=\"#cs\">cs</a>, <a class=\"id\" href=\"#trialcs\">trialcs</a>);", 
"<span class=\"ts\"/>if (<a class=\"id\" href=\"#retval\">retval</a> &lt; 0)", 
"<span class=\"ts\"/><span class=\"ts\"/>return <a class=\"id\" href=\"#retval\">retval</a>;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/* Nothing to do if the cpus didn't change */</span>", 
"<span class=\"ts\"/>if (<a class=\"id\" href=\"#cpumask_equal\">cpumask_equal</a>(<a class=\"id\" href=\"#cs\">cs</a>-><a class=\"id\" href=\"#cpus_allowed\">cpus_allowed</a>, <a class=\"id\" href=\"#trialcs\">trialcs</a>-><a class=\"id\" href=\"#cpus_allowed\">cpus_allowed</a>))", 
"<span class=\"ts\"/><span class=\"ts\"/>return 0;", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#retval\">retval</a> = <a class=\"id\" href=\"#heap_init\">heap_init</a>(&amp;<a class=\"id\" href=\"#heap\">heap</a>, <a class=\"id\" href=\"#PAGE_SIZE\">PAGE_SIZE</a>, <a class=\"id\" href=\"#GFP_KERNEL\">GFP_KERNEL</a>, <a class=\"id\" href=\"#NULL\">NULL</a>);", 
"<span class=\"ts\"/>if (<a class=\"id\" href=\"#retval\">retval</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/>return <a class=\"id\" href=\"#retval\">retval</a>;", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#is_load_balanced\">is_load_balanced</a> = <a class=\"id\" href=\"#is_sched_load_balance\">is_sched_load_balance</a>(<a class=\"id\" href=\"#trialcs\">trialcs</a>);", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#mutex_lock\">mutex_lock</a>(&amp;<a class=\"id\" href=\"#callback_mutex\">callback_mutex</a>);", 
"<span class=\"ts\"/><a class=\"id\" href=\"#cpumask_copy\">cpumask_copy</a>(<a class=\"id\" href=\"#cs\">cs</a>-><a class=\"id\" href=\"#cpus_allowed\">cpus_allowed</a>, <a class=\"id\" href=\"#trialcs\">trialcs</a>-><a class=\"id\" href=\"#cpus_allowed\">cpus_allowed</a>);", 
"<span class=\"ts\"/><a class=\"id\" href=\"#mutex_unlock\">mutex_unlock</a>(&amp;<a class=\"id\" href=\"#callback_mutex\">callback_mutex</a>);", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Scan tasks in the cpuset, and update the cpumasks of any</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * that need an update.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/><a class=\"id\" href=\"#update_tasks_cpumask\">update_tasks_cpumask</a>(<a class=\"id\" href=\"#cs\">cs</a>, &amp;<a class=\"id\" href=\"#heap\">heap</a>);", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#heap_free\">heap_free</a>(&amp;<a class=\"id\" href=\"#heap\">heap</a>);", 
"", 
"<span class=\"ts\"/>if (<a class=\"id\" href=\"#is_load_balanced\">is_load_balanced</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#async_rebuild_sched_domains\">async_rebuild_sched_domains</a>();", 
"<span class=\"ts\"/>return 0;", 
"}", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * cpuset_migrate_mm</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> *    Migrate memory region from one set of nodes to another.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> *    Temporarilly set tasks mems_allowed to target nodes of migration,</span>", 
"<span class=\"comment\"> *    so that the migration code can allocate pages on these nodes.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> *    Call holding cgroup_mutex, so current's cpuset won't change</span>", 
"<span class=\"comment\"> *    during this call, as manage_mutex holds off any cpuset_attach()</span>", 
"<span class=\"comment\"> *    calls.  Therefore we don't need to take task_lock around the</span>", 
"<span class=\"comment\"> *    call to guarantee_online_mems(), as we know no one is changing</span>", 
"<span class=\"comment\"> *    our task's cpuset.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> *    While the mm_struct we are migrating is typically from some</span>", 
"<span class=\"comment\"> *    other task, the task_struct mems_allowed that we are hacking</span>", 
"<span class=\"comment\"> *    is for our current task, which must allocate new pages for that</span>", 
"<span class=\"comment\"> *    migrating memory region.</span>", 
"<span class=\"comment\"> */</span>", 
"", 
"static void <a class=\"id\" href=\"#cpuset_migrate_mm\">cpuset_migrate_mm</a>(struct <a class=\"id\" href=\"#mm_struct\">mm_struct</a> *<a class=\"id\" href=\"#mm\">mm</a>, const <a class=\"id\" href=\"#nodemask_t\">nodemask_t</a> *<a class=\"id\" href=\"#from\">from</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>const <a class=\"id\" href=\"#nodemask_t\">nodemask_t</a> *<a class=\"id\" href=\"#to\">to</a>)", 
"{", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#task_struct\">task_struct</a> *<a class=\"id\" href=\"#tsk\">tsk</a> = <a class=\"id\" href=\"#current\">current</a>;", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#tsk\">tsk</a>-><a class=\"id\" href=\"#mems_allowed\">mems_allowed</a> = *<a class=\"id\" href=\"#to\">to</a>;", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#do_migrate_pages\">do_migrate_pages</a>(<a class=\"id\" href=\"#mm\">mm</a>, <a class=\"id\" href=\"#from\">from</a>, <a class=\"id\" href=\"#to\">to</a>, <a class=\"id\" href=\"#MPOL_MF_MOVE_ALL\">MPOL_MF_MOVE_ALL</a>);", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#guarantee_online_mems\">guarantee_online_mems</a>(<a class=\"id\" href=\"#task_cs\">task_cs</a>(<a class=\"id\" href=\"#tsk\">tsk</a>),&amp;<a class=\"id\" href=\"#tsk\">tsk</a>-><a class=\"id\" href=\"#mems_allowed\">mems_allowed</a>);", 
"}", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * cpuset_change_task_nodemask - change task's mems_allowed and mempolicy</span>", 
"<span class=\"comment\"> * @tsk: the task to change</span>", 
"<span class=\"comment\"> * @newmems: new nodes that the task will be set</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * In order to avoid seeing no nodes if the old and new nodes are disjoint,</span>", 
"<span class=\"comment\"> * we structure updates as setting all new allowed nodes, then clearing newly</span>", 
"<span class=\"comment\"> * disallowed ones.</span>", 
"<span class=\"comment\"> */</span>", 
"static void <a class=\"id\" href=\"#cpuset_change_task_nodemask\">cpuset_change_task_nodemask</a>(struct <a class=\"id\" href=\"#task_struct\">task_struct</a> *<a class=\"id\" href=\"#tsk\">tsk</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#nodemask_t\">nodemask_t</a> *<a class=\"id\" href=\"#newmems\">newmems</a>)", 
"{", 
"<a class=\"id\" href=\"#repeat\">repeat</a>:", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Allow tasks that have access to memory reserves because they have</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * been OOM killed to get memory anywhere.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>if (<a class=\"id\" href=\"#unlikely\">unlikely</a>(<a class=\"id\" href=\"#test_thread_flag\">test_thread_flag</a>(<a class=\"id\" href=\"#TIF_MEMDIE\">TIF_MEMDIE</a>)))", 
"<span class=\"ts\"/><span class=\"ts\"/>return;", 
"<span class=\"ts\"/>if (<a class=\"id\" href=\"#current\">current</a>-><a class=\"id\" href=\"#flags\">flags</a> &amp; <a class=\"id\" href=\"#PF_EXITING\">PF_EXITING</a>) <span class=\"comment\">/* Let dying task have memory */</span>", 
"<span class=\"ts\"/><span class=\"ts\"/>return;", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#task_lock\">task_lock</a>(<a class=\"id\" href=\"#tsk\">tsk</a>);", 
"<span class=\"ts\"/><a class=\"id\" href=\"#nodes_or\">nodes_or</a>(<a class=\"id\" href=\"#tsk\">tsk</a>-><a class=\"id\" href=\"#mems_allowed\">mems_allowed</a>, <a class=\"id\" href=\"#tsk\">tsk</a>-><a class=\"id\" href=\"#mems_allowed\">mems_allowed</a>, *<a class=\"id\" href=\"#newmems\">newmems</a>);", 
"<span class=\"ts\"/><a class=\"id\" href=\"#mpol_rebind_task\">mpol_rebind_task</a>(<a class=\"id\" href=\"#tsk\">tsk</a>, <a class=\"id\" href=\"#newmems\">newmems</a>, <a class=\"id\" href=\"#MPOL_REBIND_STEP1\">MPOL_REBIND_STEP1</a>);", 
"", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * ensure checking -&gt;mems_allowed_change_disable after setting all new</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * allowed nodes.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * the read-side task can see an nodemask with new allowed nodes and</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * old allowed nodes. and if it allocates page when cpuset clears newly</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * disallowed ones continuous, it can see the new allowed bits.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * And if setting all new allowed nodes is after the checking, setting</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * all new allowed nodes and clearing newly disallowed ones will be done</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * continuous, and the read-side task may find no node to alloc page.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/><a class=\"id\" href=\"#smp_mb\">smp_mb</a>();", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Allocation of memory is very fast, we needn't sleep when waiting</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * for the read-side.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>while (<a class=\"id\" href=\"#ACCESS_ONCE\">ACCESS_ONCE</a>(<a class=\"id\" href=\"#tsk\">tsk</a>-><a class=\"id\" href=\"#mems_allowed_change_disable\">mems_allowed_change_disable</a>)) {", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#task_unlock\">task_unlock</a>(<a class=\"id\" href=\"#tsk\">tsk</a>);", 
"<span class=\"ts\"/><span class=\"ts\"/>if (!<a class=\"id\" href=\"#task_curr\">task_curr</a>(<a class=\"id\" href=\"#tsk\">tsk</a>))", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#yield\">yield</a>();", 
"<span class=\"ts\"/><span class=\"ts\"/>goto <a class=\"id\" href=\"#repeat\">repeat</a>;", 
"<span class=\"ts\"/>}", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * ensure checking -&gt;mems_allowed_change_disable before clearing all new</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * disallowed nodes.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> *</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * if clearing newly disallowed bits before the checking, the read-side</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * task may find no node to alloc page.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/><a class=\"id\" href=\"#smp_mb\">smp_mb</a>();", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#mpol_rebind_task\">mpol_rebind_task</a>(<a class=\"id\" href=\"#tsk\">tsk</a>, <a class=\"id\" href=\"#newmems\">newmems</a>, <a class=\"id\" href=\"#MPOL_REBIND_STEP2\">MPOL_REBIND_STEP2</a>);", 
"<span class=\"ts\"/><a class=\"id\" href=\"#tsk\">tsk</a>-><a class=\"id\" href=\"#mems_allowed\">mems_allowed</a> = *<a class=\"id\" href=\"#newmems\">newmems</a>;", 
"<span class=\"ts\"/><a class=\"id\" href=\"#task_unlock\">task_unlock</a>(<a class=\"id\" href=\"#tsk\">tsk</a>);", 
"}", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * Update task's mems_allowed and rebind its mempolicy and vmas' mempolicy</span>", 
"<span class=\"comment\"> * of it to cpuset's new mems_allowed, and migrate pages to new nodes if</span>", 
"<span class=\"comment\"> * memory_migrate flag is set. Called with cgroup_mutex held.</span>", 
"<span class=\"comment\"> */</span>", 
"static void <a class=\"id\" href=\"#cpuset_change_nodemask\">cpuset_change_nodemask</a>(struct <a class=\"id\" href=\"#task_struct\">task_struct</a> *<a class=\"id\" href=\"#p\">p</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>   struct <a class=\"id\" href=\"#cgroup_scanner\">cgroup_scanner</a> *<a class=\"id\" href=\"#scan\">scan</a>)", 
"{", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#mm_struct\">mm_struct</a> *<a class=\"id\" href=\"#mm\">mm</a>;", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#cpuset\">cpuset</a> *<a class=\"id\" href=\"#cs\">cs</a>;", 
"<span class=\"ts\"/>int <a class=\"id\" href=\"#migrate\">migrate</a>;", 
"<span class=\"ts\"/>const <a class=\"id\" href=\"#nodemask_t\">nodemask_t</a> *<a class=\"id\" href=\"#oldmem\">oldmem</a> = <a class=\"id\" href=\"#scan\">scan</a>-><a class=\"id\" href=\"#data\">data</a>;", 
"<span class=\"ts\"/><a class=\"id\" href=\"#NODEMASK_ALLOC\">NODEMASK_ALLOC</a>(<a class=\"id\" href=\"#nodemask_t\">nodemask_t</a>, <a class=\"id\" href=\"#newmems\">newmems</a>, <a class=\"id\" href=\"#GFP_KERNEL\">GFP_KERNEL</a>);", 
"", 
"<span class=\"ts\"/>if (!<a class=\"id\" href=\"#newmems\">newmems</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/>return;", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#cs\">cs</a> = <a class=\"id\" href=\"#cgroup_cs\">cgroup_cs</a>(<a class=\"id\" href=\"#scan\">scan</a>-><a class=\"id\" href=\"#cg\">cg</a>);", 
"<span class=\"ts\"/><a class=\"id\" href=\"#guarantee_online_mems\">guarantee_online_mems</a>(<a class=\"id\" href=\"#cs\">cs</a>, <a class=\"id\" href=\"#newmems\">newmems</a>);", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#cpuset_change_task_nodemask\">cpuset_change_task_nodemask</a>(<a class=\"id\" href=\"#p\">p</a>, <a class=\"id\" href=\"#newmems\">newmems</a>);", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#NODEMASK_FREE\">NODEMASK_FREE</a>(<a class=\"id\" href=\"#newmems\">newmems</a>);", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#mm\">mm</a> = <a class=\"id\" href=\"#get_task_mm\">get_task_mm</a>(<a class=\"id\" href=\"#p\">p</a>);", 
"<span class=\"ts\"/>if (!<a class=\"id\" href=\"#mm\">mm</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/>return;", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#migrate\">migrate</a> = <a class=\"id\" href=\"#is_memory_migrate\">is_memory_migrate</a>(<a class=\"id\" href=\"#cs\">cs</a>);", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#mpol_rebind_mm\">mpol_rebind_mm</a>(<a class=\"id\" href=\"#mm\">mm</a>, &amp;<a class=\"id\" href=\"#cs\">cs</a>-><a class=\"id\" href=\"#mems_allowed\">mems_allowed</a>);", 
"<span class=\"ts\"/>if (<a class=\"id\" href=\"#migrate\">migrate</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#cpuset_migrate_mm\">cpuset_migrate_mm</a>(<a class=\"id\" href=\"#mm\">mm</a>, <a class=\"id\" href=\"#oldmem\">oldmem</a>, &amp;<a class=\"id\" href=\"#cs\">cs</a>-><a class=\"id\" href=\"#mems_allowed\">mems_allowed</a>);", 
"<span class=\"ts\"/><a class=\"id\" href=\"#mmput\">mmput</a>(<a class=\"id\" href=\"#mm\">mm</a>);", 
"}", 
"", 
"static void *<a class=\"id\" href=\"#cpuset_being_rebound\">cpuset_being_rebound</a>;", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * update_tasks_nodemask - Update the nodemasks of tasks in the cpuset.</span>", 
"<span class=\"comment\"> * @cs: the cpuset in which each task's mems_allowed mask needs to be changed</span>", 
"<span class=\"comment\"> * @oldmem: old mems_allowed of cpuset cs</span>", 
"<span class=\"comment\"> * @heap: if NULL, defer allocating heap memory to cgroup_scan_tasks()</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Called with cgroup_mutex held</span>", 
"<span class=\"comment\"> * No return value. It's guaranteed that cgroup_scan_tasks() always returns 0</span>", 
"<span class=\"comment\"> * if @heap != NULL.</span>", 
"<span class=\"comment\"> */</span>", 
"static void <a class=\"id\" href=\"#update_tasks_nodemask\">update_tasks_nodemask</a>(struct <a class=\"id\" href=\"#cpuset\">cpuset</a> *<a class=\"id\" href=\"#cs\">cs</a>, const <a class=\"id\" href=\"#nodemask_t\">nodemask_t</a> *<a class=\"id\" href=\"#oldmem\">oldmem</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/> struct <a class=\"id\" href=\"#ptr_heap\">ptr_heap</a> *<a class=\"id\" href=\"#heap\">heap</a>)", 
"{", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#cgroup_scanner\">cgroup_scanner</a> <a class=\"id\" href=\"#scan\">scan</a>;", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#cpuset_being_rebound\">cpuset_being_rebound</a> = <a class=\"id\" href=\"#cs\">cs</a>;<span class=\"ts\"/><span class=\"ts\"/><span class=\"comment\">/* causes mpol_dup() rebind */</span>", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#scan\">scan</a>.<a class=\"id\" href=\"#cg\">cg</a> = <a class=\"id\" href=\"#cs\">cs</a>-><a class=\"id\" href=\"#css\">css</a>.<a class=\"id\" href=\"#cgroup\">cgroup</a>;", 
"<span class=\"ts\"/><a class=\"id\" href=\"#scan\">scan</a>.<a class=\"id\" href=\"#test_task\">test_task</a> = <a class=\"id\" href=\"#NULL\">NULL</a>;", 
"<span class=\"ts\"/><a class=\"id\" href=\"#scan\">scan</a>.<a class=\"id\" href=\"#process_task\">process_task</a> = <a class=\"id\" href=\"#cpuset_change_nodemask\">cpuset_change_nodemask</a>;", 
"<span class=\"ts\"/><a class=\"id\" href=\"#scan\">scan</a>.<a class=\"id\" href=\"#heap\">heap</a> = <a class=\"id\" href=\"#heap\">heap</a>;", 
"<span class=\"ts\"/><a class=\"id\" href=\"#scan\">scan</a>.<a class=\"id\" href=\"#data\">data</a> = (<a class=\"id\" href=\"#nodemask_t\">nodemask_t</a> *)<a class=\"id\" href=\"#oldmem\">oldmem</a>;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * The mpol_rebind_mm() call takes mmap_sem, which we couldn't</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * take while holding tasklist_lock.  Forks can happen - the</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * mpol_dup() cpuset_being_rebound check will catch such forks,</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * and rebind their vma mempolicies too.  Because we still hold</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * the global cgroup_mutex, we know that no other rebind effort</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * will be contending for the global variable cpuset_being_rebound.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * It's ok if we rebind the same mm twice; mpol_rebind_mm()</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * is idempotent.  Also migrate pages in each mm to new nodes.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/><a class=\"id\" href=\"#cgroup_scan_tasks\">cgroup_scan_tasks</a>(&amp;<a class=\"id\" href=\"#scan\">scan</a>);", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/* We're done rebinding vmas to this cpuset's new mems_allowed. */</span>", 
"<span class=\"ts\"/><a class=\"id\" href=\"#cpuset_being_rebound\">cpuset_being_rebound</a> = <a class=\"id\" href=\"#NULL\">NULL</a>;", 
"}", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * Handle user request to change the 'mems' memory placement</span>", 
"<span class=\"comment\"> * of a cpuset.  Needs to validate the request, update the</span>", 
"<span class=\"comment\"> * cpusets mems_allowed, and for each task in the cpuset,</span>", 
"<span class=\"comment\"> * update mems_allowed and rebind task's mempolicy and any vma</span>", 
"<span class=\"comment\"> * mempolicies and if the cpuset is marked 'memory_migrate',</span>", 
"<span class=\"comment\"> * migrate the tasks pages to the new memory.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Call with cgroup_mutex held.  May take callback_mutex during call.</span>", 
"<span class=\"comment\"> * Will take tasklist_lock, scan tasklist for tasks in cpuset cs,</span>", 
"<span class=\"comment\"> * lock each such tasks mm-&gt;mmap_sem, scan its vma's and rebind</span>", 
"<span class=\"comment\"> * their mempolicies to the cpusets new mems_allowed.</span>", 
"<span class=\"comment\"> */</span>", 
"static int <a class=\"id\" href=\"#update_nodemask\">update_nodemask</a>(struct <a class=\"id\" href=\"#cpuset\">cpuset</a> *<a class=\"id\" href=\"#cs\">cs</a>, struct <a class=\"id\" href=\"#cpuset\">cpuset</a> *<a class=\"id\" href=\"#trialcs\">trialcs</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>   const char *<a class=\"id\" href=\"#buf\">buf</a>)", 
"{", 
"<span class=\"ts\"/><a class=\"id\" href=\"#NODEMASK_ALLOC\">NODEMASK_ALLOC</a>(<a class=\"id\" href=\"#nodemask_t\">nodemask_t</a>, <a class=\"id\" href=\"#oldmem\">oldmem</a>, <a class=\"id\" href=\"#GFP_KERNEL\">GFP_KERNEL</a>);", 
"<span class=\"ts\"/>int <a class=\"id\" href=\"#retval\">retval</a>;", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#ptr_heap\">ptr_heap</a> <a class=\"id\" href=\"#heap\">heap</a>;", 
"", 
"<span class=\"ts\"/>if (!<a class=\"id\" href=\"#oldmem\">oldmem</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/>return -<a class=\"id\" href=\"#ENOMEM\">ENOMEM</a>;", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * top_cpuset.mems_allowed tracks node_stats[N_HIGH_MEMORY];</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * it's read-only</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>if (<a class=\"id\" href=\"#cs\">cs</a> == &amp;<a class=\"id\" href=\"#top_cpuset\">top_cpuset</a>) {", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#retval\">retval</a> = -<a class=\"id\" href=\"#EACCES\">EACCES</a>;", 
"<span class=\"ts\"/><span class=\"ts\"/>goto <a class=\"id\" href=\"#done\">done</a>;", 
"<span class=\"ts\"/>}", 
"", 
"<span class=\"ts\"/><span class=\"comment\">/*</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * An empty mems_allowed is ok iff there are no tasks in the cpuset.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * Since nodelist_parse() fails on an empty mask, we special case</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * that parsing.  The validate_change() call ensures that cpusets</span>", 
"<span class=\"comment\"><span class=\"ts\"/> * with tasks have memory.</span>", 
"<span class=\"comment\"><span class=\"ts\"/> */</span>", 
"<span class=\"ts\"/>if (!*<a class=\"id\" href=\"#buf\">buf</a>) {", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#nodes_clear\">nodes_clear</a>(<a class=\"id\" href=\"#trialcs\">trialcs</a>-><a class=\"id\" href=\"#mems_allowed\">mems_allowed</a>);", 
"<span class=\"ts\"/>} else {", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#retval\">retval</a> = <a class=\"id\" href=\"#nodelist_parse\">nodelist_parse</a>(<a class=\"id\" href=\"#buf\">buf</a>, <a class=\"id\" href=\"#trialcs\">trialcs</a>-><a class=\"id\" href=\"#mems_allowed\">mems_allowed</a>);", 
"<span class=\"ts\"/><span class=\"ts\"/>if (<a class=\"id\" href=\"#retval\">retval</a> &lt; 0)", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>goto <a class=\"id\" href=\"#done\">done</a>;", 
"", 
"<span class=\"ts\"/><span class=\"ts\"/>if (!<a class=\"id\" href=\"#nodes_subset\">nodes_subset</a>(<a class=\"id\" href=\"#trialcs\">trialcs</a>-><a class=\"id\" href=\"#mems_allowed\">mems_allowed</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#node_states\">node_states</a>[<a class=\"id\" href=\"#N_HIGH_MEMORY\">N_HIGH_MEMORY</a>])) {", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#retval\">retval</a> =  -<a class=\"id\" href=\"#EINVAL\">EINVAL</a>;", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>goto <a class=\"id\" href=\"#done\">done</a>;", 
"<span class=\"ts\"/><span class=\"ts\"/>}", 
"<span class=\"ts\"/>}", 
"<span class=\"ts\"/>*<a class=\"id\" href=\"#oldmem\">oldmem</a> = <a class=\"id\" href=\"#cs\">cs</a>-><a class=\"id\" href=\"#mems_allowed\">mems_allowed</a>;", 
"<span class=\"ts\"/>if (<a class=\"id\" href=\"#nodes_equal\">nodes_equal</a>(*<a class=\"id\" href=\"#oldmem\">oldmem</a>, <a class=\"id\" href=\"#trialcs\">trialcs</a>-><a class=\"id\" href=\"#mems_allowed\">mems_allowed</a>)) {", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#retval\">retval</a> = 0;<span class=\"ts\"/><span class=\"ts\"/><span class=\"comment\">/* Too easy - nothing to do */</span>", 
"<span class=\"ts\"/><span class=\"ts\"/>goto <a class=\"id\" href=\"#done\">done</a>;", 
"<span class=\"ts\"/>}", 
"<span class=\"ts\"/><a class=\"id\" href=\"#retval\">retval</a> = <a class=\"id\" href=\"#validate_change\">validate_change</a>(<a class=\"id\" href=\"#cs\">cs</a>, <a class=\"id\" href=\"#trialcs\">trialcs</a>);", 
"<span class=\"ts\"/>if (<a class=\"id\" href=\"#retval\">retval</a> &lt; 0)", 
"<span class=\"ts\"/><span class=\"ts\"/>goto <a class=\"id\" href=\"#done\">done</a>;", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#retval\">retval</a> = <a class=\"id\" href=\"#heap_init\">heap_init</a>(&amp;<a class=\"id\" href=\"#heap\">heap</a>, <a class=\"id\" href=\"#PAGE_SIZE\">PAGE_SIZE</a>, <a class=\"id\" href=\"#GFP_KERNEL\">GFP_KERNEL</a>, <a class=\"id\" href=\"#NULL\">NULL</a>);", 
"<span class=\"ts\"/>if (<a class=\"id\" href=\"#retval\">retval</a> &lt; 0)", 
"<span class=\"ts\"/><span class=\"ts\"/>goto <a class=\"id\" href=\"#done\">done</a>;", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#mutex_lock\">mutex_lock</a>(&amp;<a class=\"id\" href=\"#callback_mutex\">callback_mutex</a>);", 
"<span class=\"ts\"/><a class=\"id\" href=\"#cs\">cs</a>-><a class=\"id\" href=\"#mems_allowed\">mems_allowed</a> = <a class=\"id\" href=\"#trialcs\">trialcs</a>-><a class=\"id\" href=\"#mems_allowed\">mems_allowed</a>;", 
"<span class=\"ts\"/><a class=\"id\" href=\"#mutex_unlock\">mutex_unlock</a>(&amp;<a class=\"id\" href=\"#callback_mutex\">callback_mutex</a>);", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#update_tasks_nodemask\">update_tasks_nodemask</a>(<a class=\"id\" href=\"#cs\">cs</a>, <a class=\"id\" href=\"#oldmem\">oldmem</a>, &amp;<a class=\"id\" href=\"#heap\">heap</a>);", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#heap_free\">heap_free</a>(&amp;<a class=\"id\" href=\"#heap\">heap</a>);", 
"<a class=\"id\" href=\"#done\">done</a>:", 
"<span class=\"ts\"/><a class=\"id\" href=\"#NODEMASK_FREE\">NODEMASK_FREE</a>(<a class=\"id\" href=\"#oldmem\">oldmem</a>);", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#retval\">retval</a>;", 
"}", 
"", 
"int <a class=\"id\" href=\"#current_cpuset_is_being_rebound\">current_cpuset_is_being_rebound</a>(void)", 
"{", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#task_cs\">task_cs</a>(<a class=\"id\" href=\"#current\">current</a>) == <a class=\"id\" href=\"#cpuset_being_rebound\">cpuset_being_rebound</a>;", 
"}", 
"", 
"static int <a class=\"id\" href=\"#update_relax_domain_level\">update_relax_domain_level</a>(struct <a class=\"id\" href=\"#cpuset\">cpuset</a> *<a class=\"id\" href=\"#cs\">cs</a>, <a class=\"id\" href=\"#s64\">s64</a> <a class=\"id\" href=\"#val\">val</a>)", 
"{", 
"#<a class=\"id\" href=\"#ifdef\">ifdef</a> <a class=\"id\" href=\"#CONFIG_SMP\">CONFIG_SMP</a>", 
"<span class=\"ts\"/>if (<a class=\"id\" href=\"#val\">val</a> &lt; -1 || <a class=\"id\" href=\"#val\">val</a> >= <a class=\"id\" href=\"#SD_LV_MAX\">SD_LV_MAX</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/>return -<a class=\"id\" href=\"#EINVAL\">EINVAL</a>;", 
"#<a class=\"id\" href=\"#endif\">endif</a>", 
"", 
"<span class=\"ts\"/>if (<a class=\"id\" href=\"#val\">val</a> != <a class=\"id\" href=\"#cs\">cs</a>-><a class=\"id\" href=\"#relax_domain_level\">relax_domain_level</a>) {", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#cs\">cs</a>-><a class=\"id\" href=\"#relax_domain_level\">relax_domain_level</a> = <a class=\"id\" href=\"#val\">val</a>;", 
"<span class=\"ts\"/><span class=\"ts\"/>if (!<a class=\"id\" href=\"#cpumask_empty\">cpumask_empty</a>(<a class=\"id\" href=\"#cs\">cs</a>-><a class=\"id\" href=\"#cpus_allowed\">cpus_allowed</a>) &&", 
"<span class=\"ts\"/><span class=\"ts\"/>    <a class=\"id\" href=\"#is_sched_load_balance\">is_sched_load_balance</a>(<a class=\"id\" href=\"#cs\">cs</a>))", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#async_rebuild_sched_domains\">async_rebuild_sched_domains</a>();", 
"<span class=\"ts\"/>}", 
"", 
"<span class=\"ts\"/>return 0;", 
"}", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * cpuset_change_flag - make a task's spread flags the same as its cpuset's</span>", 
"<span class=\"comment\"> * @tsk: task to be updated</span>", 
"<span class=\"comment\"> * @scan: struct cgroup_scanner containing the cgroup of the task</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Called by cgroup_scan_tasks() for each task in a cgroup.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * We don't need to re-check for the cgroup/cpuset membership, since we're</span>", 
"<span class=\"comment\"> * holding cgroup_lock() at this point.</span>", 
"<span class=\"comment\"> */</span>", 
"static void <a class=\"id\" href=\"#cpuset_change_flag\">cpuset_change_flag</a>(struct <a class=\"id\" href=\"#task_struct\">task_struct</a> *<a class=\"id\" href=\"#tsk\">tsk</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>struct <a class=\"id\" href=\"#cgroup_scanner\">cgroup_scanner</a> *<a class=\"id\" href=\"#scan\">scan</a>)", 
"{", 
"<span class=\"ts\"/><a class=\"id\" href=\"#cpuset_update_task_spread_flag\">cpuset_update_task_spread_flag</a>(<a class=\"id\" href=\"#cgroup_cs\">cgroup_cs</a>(<a class=\"id\" href=\"#scan\">scan</a>-><a class=\"id\" href=\"#cg\">cg</a>), <a class=\"id\" href=\"#tsk\">tsk</a>);", 
"}", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * update_tasks_flags - update the spread flags of tasks in the cpuset.</span>", 
"<span class=\"comment\"> * @cs: the cpuset in which each task's spread flags needs to be changed</span>", 
"<span class=\"comment\"> * @heap: if NULL, defer allocating heap memory to cgroup_scan_tasks()</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Called with cgroup_mutex held</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * The cgroup_scan_tasks() function will scan all the tasks in a cgroup,</span>", 
"<span class=\"comment\"> * calling callback functions for each.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * No return value. It's guaranteed that cgroup_scan_tasks() always returns 0</span>", 
"<span class=\"comment\"> * if @heap != NULL.</span>", 
"<span class=\"comment\"> */</span>", 
"static void <a class=\"id\" href=\"#update_tasks_flags\">update_tasks_flags</a>(struct <a class=\"id\" href=\"#cpuset\">cpuset</a> *<a class=\"id\" href=\"#cs\">cs</a>, struct <a class=\"id\" href=\"#ptr_heap\">ptr_heap</a> *<a class=\"id\" href=\"#heap\">heap</a>)", 
"{", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#cgroup_scanner\">cgroup_scanner</a> <a class=\"id\" href=\"#scan\">scan</a>;", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#scan\">scan</a>.<a class=\"id\" href=\"#cg\">cg</a> = <a class=\"id\" href=\"#cs\">cs</a>-><a class=\"id\" href=\"#css\">css</a>.<a class=\"id\" href=\"#cgroup\">cgroup</a>;", 
"<span class=\"ts\"/><a class=\"id\" href=\"#scan\">scan</a>.<a class=\"id\" href=\"#test_task\">test_task</a> = <a class=\"id\" href=\"#NULL\">NULL</a>;", 
"<span class=\"ts\"/><a class=\"id\" href=\"#scan\">scan</a>.<a class=\"id\" href=\"#process_task\">process_task</a> = <a class=\"id\" href=\"#cpuset_change_flag\">cpuset_change_flag</a>;", 
"<span class=\"ts\"/><a class=\"id\" href=\"#scan\">scan</a>.<a class=\"id\" href=\"#heap\">heap</a> = <a class=\"id\" href=\"#heap\">heap</a>;", 
"<span class=\"ts\"/><a class=\"id\" href=\"#cgroup_scan_tasks\">cgroup_scan_tasks</a>(&amp;<a class=\"id\" href=\"#scan\">scan</a>);", 
"}", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * update_flag - read a 0 or a 1 in a file and update associated flag</span>", 
"<span class=\"comment\"> * bit:<span class=\"ts\"/><span class=\"ts\"/>the bit to update (see cpuset_flagbits_t)</span>", 
"<span class=\"comment\"> * cs:<span class=\"ts\"/><span class=\"ts\"/>the cpuset to update</span>", 
"<span class=\"comment\"> * turning_on: <span class=\"ts\"/>whether the flag is being set or cleared</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Call with cgroup_mutex held.</span>", 
"<span class=\"comment\"> */</span>", 
"", 
"static int <a class=\"id\" href=\"#update_flag\">update_flag</a>(<a class=\"id\" href=\"#cpuset_flagbits_t\">cpuset_flagbits_t</a> <a class=\"id\" href=\"#bit\">bit</a>, struct <a class=\"id\" href=\"#cpuset\">cpuset</a> *<a class=\"id\" href=\"#cs\">cs</a>,", 
"<span class=\"ts\"/><span class=\"ts\"/>       int <a class=\"id\" href=\"#turning_on\">turning_on</a>)", 
"{", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#cpuset\">cpuset</a> *<a class=\"id\" href=\"#trialcs\">trialcs</a>;", 
"<span class=\"ts\"/>int <a class=\"id\" href=\"#balance_flag_changed\">balance_flag_changed</a>;", 
"<span class=\"ts\"/>int <a class=\"id\" href=\"#spread_flag_changed\">spread_flag_changed</a>;", 
"<span class=\"ts\"/>struct <a class=\"id\" href=\"#ptr_heap\">ptr_heap</a> <a class=\"id\" href=\"#heap\">heap</a>;", 
"<span class=\"ts\"/>int <a class=\"id\" href=\"#err\">err</a>;", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#trialcs\">trialcs</a> = <a class=\"id\" href=\"#alloc_trial_cpuset\">alloc_trial_cpuset</a>(<a class=\"id\" href=\"#cs\">cs</a>);", 
"<span class=\"ts\"/>if (!<a class=\"id\" href=\"#trialcs\">trialcs</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/>return -<a class=\"id\" href=\"#ENOMEM\">ENOMEM</a>;", 
"", 
"<span class=\"ts\"/>if (<a class=\"id\" href=\"#turning_on\">turning_on</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#set_bit\">set_bit</a>(<a class=\"id\" href=\"#bit\">bit</a>, &amp;<a class=\"id\" href=\"#trialcs\">trialcs</a>-><a class=\"id\" href=\"#flags\">flags</a>);", 
"<span class=\"ts\"/>else", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#clear_bit\">clear_bit</a>(<a class=\"id\" href=\"#bit\">bit</a>, &amp;<a class=\"id\" href=\"#trialcs\">trialcs</a>-><a class=\"id\" href=\"#flags\">flags</a>);", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#err\">err</a> = <a class=\"id\" href=\"#validate_change\">validate_change</a>(<a class=\"id\" href=\"#cs\">cs</a>, <a class=\"id\" href=\"#trialcs\">trialcs</a>);", 
"<span class=\"ts\"/>if (<a class=\"id\" href=\"#err\">err</a> &lt; 0)", 
"<span class=\"ts\"/><span class=\"ts\"/>goto <a class=\"id\" href=\"#out\">out</a>;", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#err\">err</a> = <a class=\"id\" href=\"#heap_init\">heap_init</a>(&amp;<a class=\"id\" href=\"#heap\">heap</a>, <a class=\"id\" href=\"#PAGE_SIZE\">PAGE_SIZE</a>, <a class=\"id\" href=\"#GFP_KERNEL\">GFP_KERNEL</a>, <a class=\"id\" href=\"#NULL\">NULL</a>);", 
"<span class=\"ts\"/>if (<a class=\"id\" href=\"#err\">err</a> &lt; 0)", 
"<span class=\"ts\"/><span class=\"ts\"/>goto <a class=\"id\" href=\"#out\">out</a>;", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#balance_flag_changed\">balance_flag_changed</a> = (<a class=\"id\" href=\"#is_sched_load_balance\">is_sched_load_balance</a>(<a class=\"id\" href=\"#cs\">cs</a>) !=", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#is_sched_load_balance\">is_sched_load_balance</a>(<a class=\"id\" href=\"#trialcs\">trialcs</a>));", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#spread_flag_changed\">spread_flag_changed</a> = ((<a class=\"id\" href=\"#is_spread_slab\">is_spread_slab</a>(<a class=\"id\" href=\"#cs\">cs</a>) != <a class=\"id\" href=\"#is_spread_slab\">is_spread_slab</a>(<a class=\"id\" href=\"#trialcs\">trialcs</a>))", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>|| (<a class=\"id\" href=\"#is_spread_page\">is_spread_page</a>(<a class=\"id\" href=\"#cs\">cs</a>) != <a class=\"id\" href=\"#is_spread_page\">is_spread_page</a>(<a class=\"id\" href=\"#trialcs\">trialcs</a>)));", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#mutex_lock\">mutex_lock</a>(&amp;<a class=\"id\" href=\"#callback_mutex\">callback_mutex</a>);", 
"<span class=\"ts\"/><a class=\"id\" href=\"#cs\">cs</a>-><a class=\"id\" href=\"#flags\">flags</a> = <a class=\"id\" href=\"#trialcs\">trialcs</a>-><a class=\"id\" href=\"#flags\">flags</a>;", 
"<span class=\"ts\"/><a class=\"id\" href=\"#mutex_unlock\">mutex_unlock</a>(&amp;<a class=\"id\" href=\"#callback_mutex\">callback_mutex</a>);", 
"", 
"<span class=\"ts\"/>if (!<a class=\"id\" href=\"#cpumask_empty\">cpumask_empty</a>(<a class=\"id\" href=\"#trialcs\">trialcs</a>-><a class=\"id\" href=\"#cpus_allowed\">cpus_allowed</a>) && <a class=\"id\" href=\"#balance_flag_changed\">balance_flag_changed</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#async_rebuild_sched_domains\">async_rebuild_sched_domains</a>();", 
"", 
"<span class=\"ts\"/>if (<a class=\"id\" href=\"#spread_flag_changed\">spread_flag_changed</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#update_tasks_flags\">update_tasks_flags</a>(<a class=\"id\" href=\"#cs\">cs</a>, &amp;<a class=\"id\" href=\"#heap\">heap</a>);", 
"<span class=\"ts\"/><a class=\"id\" href=\"#heap_free\">heap_free</a>(&amp;<a class=\"id\" href=\"#heap\">heap</a>);", 
"<a class=\"id\" href=\"#out\">out</a>:", 
"<span class=\"ts\"/><a class=\"id\" href=\"#free_trial_cpuset\">free_trial_cpuset</a>(<a class=\"id\" href=\"#trialcs\">trialcs</a>);", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#err\">err</a>;", 
"}", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * Frequency meter - How fast is some event occurring?</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * These routines manage a digitally filtered, constant time based,</span>", 
"<span class=\"comment\"> * event frequency meter.  There are four routines:</span>", 
"<span class=\"comment\"> *   fmeter_init() - initialize a frequency meter.</span>", 
"<span class=\"comment\"> *   fmeter_markevent() - called each time the event happens.</span>", 
"<span class=\"comment\"> *   fmeter_getrate() - returns the recent rate of such events.</span>", 
"<span class=\"comment\"> *   fmeter_update() - internal routine used to update fmeter.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * A common data structure is passed to each of these routines,</span>", 
"<span class=\"comment\"> * which is used to keep track of the state required to manage the</span>", 
"<span class=\"comment\"> * frequency meter and its digital filter.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * The filter works on the number of events marked per unit time.</span>", 
"<span class=\"comment\"> * The filter is single-pole low-pass recursive (IIR).  The time unit</span>", 
"<span class=\"comment\"> * is 1 second.  Arithmetic is done using 32-bit integers scaled to</span>", 
"<span class=\"comment\"> * simulate 3 decimal digits of precision (multiplied by 1000).</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * With an FM_COEF of 933, and a time base of 1 second, the filter</span>", 
"<span class=\"comment\"> * has a half-life of 10 seconds, meaning that if the events quit</span>", 
"<span class=\"comment\"> * happening, then the rate returned from the fmeter_getrate()</span>", 
"<span class=\"comment\"> * will be cut in half each 10 seconds, until it converges to zero.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * It is not worth doing a real infinitely recursive filter.  If more</span>", 
"<span class=\"comment\"> * than FM_MAXTICKS ticks have elapsed since the last filter event,</span>", 
"<span class=\"comment\"> * just compute FM_MAXTICKS ticks worth, by which point the level</span>", 
"<span class=\"comment\"> * will be stable.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Limit the count of unprocessed events to FM_MAXCNT, so as to avoid</span>", 
"<span class=\"comment\"> * arithmetic overflow in the fmeter_update() routine.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Given the simple 32 bit integer arithmetic used, this meter works</span>", 
"<span class=\"comment\"> * best for reporting rates between one per millisecond (msec) and</span>", 
"<span class=\"comment\"> * one per 32 (approx) seconds.  At constant rates faster than one</span>", 
"<span class=\"comment\"> * per msec it maxes out at values just under 1,000,000.  At constant</span>", 
"<span class=\"comment\"> * rates between one per msec, and one per second it will stabilize</span>", 
"<span class=\"comment\"> * to a value N*1000, where N is the rate of events per second.</span>", 
"<span class=\"comment\"> * At constant rates between one per second and one per 32 seconds,</span>", 
"<span class=\"comment\"> * it will be choppy, moving up on the seconds that have an event,</span>", 
"<span class=\"comment\"> * and then decaying until the next event.  At rates slower than</span>", 
"<span class=\"comment\"> * about one in 32 seconds, it decays all the way back to zero between</span>", 
"<span class=\"comment\"> * each event.</span>", 
"<span class=\"comment\"> */</span>", 
"", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#FM_COEF\">FM_COEF</a> 933<span class=\"ts\"/><span class=\"ts\"/><span class=\"comment\">/* coefficient for half-life of 10 secs */</span>", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#FM_MAXTICKS\">FM_MAXTICKS</a> ((<a class=\"id\" href=\"#time_t\">time_t</a>)99) <span class=\"comment\">/* useless computing more ticks than this */</span>", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#FM_MAXCNT\">FM_MAXCNT</a> 1000000<span class=\"ts\"/><span class=\"comment\">/* limit cnt to avoid overflow */</span>", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#FM_SCALE\">FM_SCALE</a> 1000<span class=\"ts\"/><span class=\"ts\"/><span class=\"comment\">/* faux fixed point scale */</span>", 
"", 
"<span class=\"comment\">/* Initialize a frequency meter */</span>", 
"static void <a class=\"id\" href=\"#fmeter_init\">fmeter_init</a>(struct <a class=\"id\" href=\"#fmeter\">fmeter</a> *<a class=\"id\" href=\"#fmp\">fmp</a>)", 
"{", 
"<span class=\"ts\"/><a class=\"id\" href=\"#fmp\">fmp</a>-><a class=\"id\" href=\"#cnt\">cnt</a> = 0;", 
"<span class=\"ts\"/><a class=\"id\" href=\"#fmp\">fmp</a>-><a class=\"id\" href=\"#val\">val</a> = 0;", 
"<span class=\"ts\"/><a class=\"id\" href=\"#fmp\">fmp</a>-><a class=\"id\" href=\"#time\">time</a> = 0;", 
"<span class=\"ts\"/><a class=\"id\" href=\"#spin_lock_init\">spin_lock_init</a>(&amp;<a class=\"id\" href=\"#fmp\">fmp</a>-><a class=\"id\" href=\"#lock\">lock</a>);", 
"}", 
"", 
"<span class=\"comment\">/* Internal meter update - process cnt events and update value */</span>", 
"static void <a class=\"id\" href=\"#fmeter_update\">fmeter_update</a>(struct <a class=\"id\" href=\"#fmeter\">fmeter</a> *<a class=\"id\" href=\"#fmp\">fmp</a>)", 
"{", 
"<span class=\"ts\"/><a class=\"id\" href=\"#time_t\">time_t</a> <a class=\"id\" href=\"#now\">now</a> = <a class=\"id\" href=\"#get_seconds\">get_seconds</a>();", 
"<span class=\"ts\"/><a class=\"id\" href=\"#time_t\">time_t</a> <a class=\"id\" href=\"#ticks\">ticks</a> = <a class=\"id\" href=\"#now\">now</a> - <a class=\"id\" href=\"#fmp\">fmp</a>-><a class=\"id\" href=\"#time\">time</a>;", 
"", 
"<span class=\"ts\"/>if (<a class=\"id\" href=\"#ticks\">ticks</a> == 0)", 
"<span class=\"ts\"/><span class=\"ts\"/>return;", 
"", 
];
xr_frag_insert('l/f4/277115446e37169ac62dc93067228378609b8e.xr', __xr_tmp);
