var __xr_tmp = [
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * clear_bit() is atomic and may not be reordered.  However, it does</span>", 
"<span class=\"comment\"> * not contain a memory barrier, so if it is used for locking purposes,</span>", 
"<span class=\"comment\"> * you should call smp_mb__before_clear_bit() and/or smp_mb__after_clear_bit()</span>", 
"<span class=\"comment\"> * in order to ensure changes are visible on other processors.</span>", 
"<span class=\"comment\"> */</span>", 
"static <a class=\"id\" href=\"#__always_inline\">__always_inline</a> void", 
"<a class=\"id\" href=\"#clear_bit\">clear_bit</a>(int <a class=\"id\" href=\"#nr\">nr</a>, volatile unsigned long *<a class=\"id\" href=\"#addr\">addr</a>)", 
"{", 
"<span class=\"ts\"/>if (<a class=\"id\" href=\"#IS_IMMEDIATE\">IS_IMMEDIATE</a>(<a class=\"id\" href=\"#nr\">nr</a>)) {", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#asm\">asm</a> volatile(<a class=\"id\" href=\"#LOCK_PREFIX\">LOCK_PREFIX</a> \"andb %1,%0\"", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>: <a class=\"id\" href=\"#CONST_MASK_ADDR\">CONST_MASK_ADDR</a>(<a class=\"id\" href=\"#nr\">nr</a>, <a class=\"id\" href=\"#addr\">addr</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>: \"iq\" ((<a class=\"id\" href=\"#u8\">u8</a>)~<a class=\"id\" href=\"#CONST_MASK\">CONST_MASK</a>(<a class=\"id\" href=\"#nr\">nr</a>)));", 
"<span class=\"ts\"/>} else {", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#asm\">asm</a> volatile(<a class=\"id\" href=\"#LOCK_PREFIX\">LOCK_PREFIX</a> \"btr %1,%0\"", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>: <a class=\"id\" href=\"#BITOP_ADDR\">BITOP_ADDR</a>(<a class=\"id\" href=\"#addr\">addr</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>: \"Ir\" (<a class=\"id\" href=\"#nr\">nr</a>));", 
"<span class=\"ts\"/>}", 
"}", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * clear_bit_unlock - Clears a bit in memory</span>", 
"<span class=\"comment\"> * @nr: Bit to clear</span>", 
"<span class=\"comment\"> * @addr: Address to start counting from</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * clear_bit() is atomic and implies release semantics before the memory</span>", 
"<span class=\"comment\"> * operation. It can be used for an unlock.</span>", 
"<span class=\"comment\"> */</span>", 
"static <a class=\"id\" href=\"#inline\">inline</a> void <a class=\"id\" href=\"#clear_bit_unlock\">clear_bit_unlock</a>(unsigned <a class=\"id\" href=\"#nr\">nr</a>, volatile unsigned long *<a class=\"id\" href=\"#addr\">addr</a>)", 
"{", 
"<span class=\"ts\"/><a class=\"id\" href=\"#barrier\">barrier</a>();", 
"<span class=\"ts\"/><a class=\"id\" href=\"#clear_bit\">clear_bit</a>(<a class=\"id\" href=\"#nr\">nr</a>, <a class=\"id\" href=\"#addr\">addr</a>);", 
"}", 
"", 
"static <a class=\"id\" href=\"#inline\">inline</a> void <a class=\"id\" href=\"#__clear_bit\">__clear_bit</a>(int <a class=\"id\" href=\"#nr\">nr</a>, volatile unsigned long *<a class=\"id\" href=\"#addr\">addr</a>)", 
"{", 
"<span class=\"ts\"/><a class=\"id\" href=\"#asm\">asm</a> volatile(\"btr %1,%0\" : <a class=\"id\" href=\"#ADDR\">ADDR</a> : \"Ir\" (<a class=\"id\" href=\"#nr\">nr</a>));", 
"}", 
"", 
"<span class=\"comment\">/*</span>", 
"<span class=\"comment\"> * __clear_bit_unlock - Clears a bit in memory</span>", 
"<span class=\"comment\"> * @nr: Bit to clear</span>", 
"<span class=\"comment\"> * @addr: Address to start counting from</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * __clear_bit() is non-atomic and implies release semantics before the memory</span>", 
"<span class=\"comment\"> * operation. It can be used for an unlock if no other CPUs can concurrently</span>", 
"<span class=\"comment\"> * modify other bits in the word.</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * No memory barrier is required here, because x86 cannot reorder stores past</span>", 
"<span class=\"comment\"> * older loads. Same principle as spin_unlock.</span>", 
"<span class=\"comment\"> */</span>", 
"static <a class=\"id\" href=\"#inline\">inline</a> void <a class=\"id\" href=\"#__clear_bit_unlock\">__clear_bit_unlock</a>(unsigned <a class=\"id\" href=\"#nr\">nr</a>, volatile unsigned long *<a class=\"id\" href=\"#addr\">addr</a>)", 
"{", 
"<span class=\"ts\"/><a class=\"id\" href=\"#barrier\">barrier</a>();", 
"<span class=\"ts\"/><a class=\"id\" href=\"#__clear_bit\">__clear_bit</a>(<a class=\"id\" href=\"#nr\">nr</a>, <a class=\"id\" href=\"#addr\">addr</a>);", 
"}", 
"", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#smp_mb__before_clear_bit\">smp_mb__before_clear_bit</a>()<span class=\"ts\"/><a class=\"id\" href=\"#barrier\">barrier</a>()", 
"#<a class=\"id\" href=\"#define\">define</a> <a class=\"id\" href=\"#smp_mb__after_clear_bit\">smp_mb__after_clear_bit</a>()<span class=\"ts\"/><a class=\"id\" href=\"#barrier\">barrier</a>()", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * __change_bit - Toggle a bit in memory</span>", 
"<span class=\"comment\"> * @nr: the bit to change</span>", 
"<span class=\"comment\"> * @addr: the address to start counting from</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * Unlike change_bit(), this function is non-atomic and may be reordered.</span>", 
"<span class=\"comment\"> * If it's called on the same region of memory simultaneously, the effect</span>", 
"<span class=\"comment\"> * may be that only one operation succeeds.</span>", 
"<span class=\"comment\"> */</span>", 
"static <a class=\"id\" href=\"#inline\">inline</a> void <a class=\"id\" href=\"#__change_bit\">__change_bit</a>(int <a class=\"id\" href=\"#nr\">nr</a>, volatile unsigned long *<a class=\"id\" href=\"#addr\">addr</a>)", 
"{", 
"<span class=\"ts\"/><a class=\"id\" href=\"#asm\">asm</a> volatile(\"btc %1,%0\" : <a class=\"id\" href=\"#ADDR\">ADDR</a> : \"Ir\" (<a class=\"id\" href=\"#nr\">nr</a>));", 
"}", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * change_bit - Toggle a bit in memory</span>", 
"<span class=\"comment\"> * @nr: Bit to change</span>", 
"<span class=\"comment\"> * @addr: Address to start counting from</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * change_bit() is atomic and may not be reordered.</span>", 
"<span class=\"comment\"> * Note that @nr may be almost arbitrarily large; this function is not</span>", 
"<span class=\"comment\"> * restricted to acting on a single-word quantity.</span>", 
"<span class=\"comment\"> */</span>", 
"static <a class=\"id\" href=\"#inline\">inline</a> void <a class=\"id\" href=\"#change_bit\">change_bit</a>(int <a class=\"id\" href=\"#nr\">nr</a>, volatile unsigned long *<a class=\"id\" href=\"#addr\">addr</a>)", 
"{", 
"<span class=\"ts\"/>if (<a class=\"id\" href=\"#IS_IMMEDIATE\">IS_IMMEDIATE</a>(<a class=\"id\" href=\"#nr\">nr</a>)) {", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#asm\">asm</a> volatile(<a class=\"id\" href=\"#LOCK_PREFIX\">LOCK_PREFIX</a> \"xorb %1,%0\"", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>: <a class=\"id\" href=\"#CONST_MASK_ADDR\">CONST_MASK_ADDR</a>(<a class=\"id\" href=\"#nr\">nr</a>, <a class=\"id\" href=\"#addr\">addr</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>: \"iq\" ((<a class=\"id\" href=\"#u8\">u8</a>)<a class=\"id\" href=\"#CONST_MASK\">CONST_MASK</a>(<a class=\"id\" href=\"#nr\">nr</a>)));", 
"<span class=\"ts\"/>} else {", 
"<span class=\"ts\"/><span class=\"ts\"/><a class=\"id\" href=\"#asm\">asm</a> volatile(<a class=\"id\" href=\"#LOCK_PREFIX\">LOCK_PREFIX</a> \"btc %1,%0\"", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>: <a class=\"id\" href=\"#BITOP_ADDR\">BITOP_ADDR</a>(<a class=\"id\" href=\"#addr\">addr</a>)", 
"<span class=\"ts\"/><span class=\"ts\"/><span class=\"ts\"/>: \"Ir\" (<a class=\"id\" href=\"#nr\">nr</a>));", 
"<span class=\"ts\"/>}", 
"}", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * test_and_set_bit - Set a bit and return its old value</span>", 
"<span class=\"comment\"> * @nr: Bit to set</span>", 
"<span class=\"comment\"> * @addr: Address to count from</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * This operation is atomic and cannot be reordered.</span>", 
"<span class=\"comment\"> * It also implies a memory barrier.</span>", 
"<span class=\"comment\"> */</span>", 
"static <a class=\"id\" href=\"#inline\">inline</a> int <a class=\"id\" href=\"#test_and_set_bit\">test_and_set_bit</a>(int <a class=\"id\" href=\"#nr\">nr</a>, volatile unsigned long *<a class=\"id\" href=\"#addr\">addr</a>)", 
"{", 
"<span class=\"ts\"/>int <a class=\"id\" href=\"#oldbit\">oldbit</a>;", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#asm\">asm</a> volatile(<a class=\"id\" href=\"#LOCK_PREFIX\">LOCK_PREFIX</a> \"bts %2,%1\\n\\t\"", 
"<span class=\"ts\"/><span class=\"ts\"/>     \"sbb %0,%0\" : \"=r\" (<a class=\"id\" href=\"#oldbit\">oldbit</a>), <a class=\"id\" href=\"#ADDR\">ADDR</a> : \"Ir\" (<a class=\"id\" href=\"#nr\">nr</a>) : \"memory\");", 
"", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#oldbit\">oldbit</a>;", 
"}", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * test_and_set_bit_lock - Set a bit and return its old value for lock</span>", 
"<span class=\"comment\"> * @nr: Bit to set</span>", 
"<span class=\"comment\"> * @addr: Address to count from</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * This is the same as test_and_set_bit on x86.</span>", 
"<span class=\"comment\"> */</span>", 
"static <a class=\"id\" href=\"#__always_inline\">__always_inline</a> int", 
"<a class=\"id\" href=\"#test_and_set_bit_lock\">test_and_set_bit_lock</a>(int <a class=\"id\" href=\"#nr\">nr</a>, volatile unsigned long *<a class=\"id\" href=\"#addr\">addr</a>)", 
"{", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#test_and_set_bit\">test_and_set_bit</a>(<a class=\"id\" href=\"#nr\">nr</a>, <a class=\"id\" href=\"#addr\">addr</a>);", 
"}", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * __test_and_set_bit - Set a bit and return its old value</span>", 
"<span class=\"comment\"> * @nr: Bit to set</span>", 
"<span class=\"comment\"> * @addr: Address to count from</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * This operation is non-atomic and can be reordered.</span>", 
"<span class=\"comment\"> * If two examples of this operation race, one can appear to succeed</span>", 
"<span class=\"comment\"> * but actually fail.  You must protect multiple accesses with a lock.</span>", 
"<span class=\"comment\"> */</span>", 
"static <a class=\"id\" href=\"#inline\">inline</a> int <a class=\"id\" href=\"#__test_and_set_bit\">__test_and_set_bit</a>(int <a class=\"id\" href=\"#nr\">nr</a>, volatile unsigned long *<a class=\"id\" href=\"#addr\">addr</a>)", 
"{", 
"<span class=\"ts\"/>int <a class=\"id\" href=\"#oldbit\">oldbit</a>;", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#asm\">asm</a>(\"bts %2,%1\\n\\t\"", 
"<span class=\"ts\"/>    \"sbb %0,%0\"", 
"<span class=\"ts\"/>    : \"=r\" (<a class=\"id\" href=\"#oldbit\">oldbit</a>), <a class=\"id\" href=\"#ADDR\">ADDR</a>", 
"<span class=\"ts\"/>    : \"Ir\" (<a class=\"id\" href=\"#nr\">nr</a>));", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#oldbit\">oldbit</a>;", 
"}", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * test_and_clear_bit - Clear a bit and return its old value</span>", 
"<span class=\"comment\"> * @nr: Bit to clear</span>", 
"<span class=\"comment\"> * @addr: Address to count from</span>", 
"<span class=\"comment\"> *</span>", 
"<span class=\"comment\"> * This operation is atomic and cannot be reordered.</span>", 
"<span class=\"comment\"> * It also implies a memory barrier.</span>", 
"<span class=\"comment\"> */</span>", 
"static <a class=\"id\" href=\"#inline\">inline</a> int <a class=\"id\" href=\"#test_and_clear_bit\">test_and_clear_bit</a>(int <a class=\"id\" href=\"#nr\">nr</a>, volatile unsigned long *<a class=\"id\" href=\"#addr\">addr</a>)", 
"{", 
"<span class=\"ts\"/>int <a class=\"id\" href=\"#oldbit\">oldbit</a>;", 
"", 
"<span class=\"ts\"/><a class=\"id\" href=\"#asm\">asm</a> volatile(<a class=\"id\" href=\"#LOCK_PREFIX\">LOCK_PREFIX</a> \"btr %2,%1\\n\\t\"", 
"<span class=\"ts\"/><span class=\"ts\"/>     \"sbb %0,%0\"", 
"<span class=\"ts\"/><span class=\"ts\"/>     : \"=r\" (<a class=\"id\" href=\"#oldbit\">oldbit</a>), <a class=\"id\" href=\"#ADDR\">ADDR</a> : \"Ir\" (<a class=\"id\" href=\"#nr\">nr</a>) : \"memory\");", 
"", 
"<span class=\"ts\"/>return <a class=\"id\" href=\"#oldbit\">oldbit</a>;", 
"}", 
"", 
"<span class=\"comment\">/**</span>", 
"<span class=\"comment\"> * __test_and_clear_bit - Clear a bit and return its old value</span>", 
];
xr_frag_insert('l/fc/b40d3a18f5288ed26c2d70264ad9f9662e13b2.xr', __xr_tmp);
